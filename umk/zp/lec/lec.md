---
layout: page
title: Языки программирования. Лекции
---

<p>Оглавление</p><p><a href="#_Toc454873506">Раздел 1. Основные конструкции языка	4</a></p><p><a href="#_Toc454873507">Тема 1.1 Операторы языка программирования	4</a></p><p><a href="#_Toc454873508">Лекция 1. Операции и выражения. Структура программы.	4</a></p><p><a href="#_Toc454873509">Лекция 2. Операторы: присваивания, условный, выбора	7</a></p><p><a href="#_Toc454873510">Лекция 3.  Циклы	9</a></p><p><a href="#_Toc454873511">Лекция 4. Программы с ветвлением	13</a></p><p><a href="#_Toc454873512">Лекция 5. Сложные логические условия	18</a></p><p><a href="#_Toc454873513">Лекция 6. Вложенные операторы	22</a></p><p><a href="#_Toc454873514">Лекция 7. Циклы с параметром	27</a></p><p><a href="#_Toc454873515">Раздел 2 Структуры данных	32</a></p><p><a href="#_Toc454873516">Тема 2.1 Массивы	32</a></p><p><a href="#_Toc454873517">Лекция 8. Объявление массива. Инициализация. Действия над массивами.	32</a></p><p><a href="#_Toc454873518">Лекция 9. Обработка массива.	38</a></p><p><a href="#_Toc454873519">Лекция 10. Расчет суммы или количества элементов одномерного массива.	42</a></p><p><a href="#_Toc454873520">Лекция 11. Нахождение максимума и минимума среди элементов двумерного массива	45</a></p><p><a href="#_Toc454873521">Тема 2.2  Строки	50</a></p><p><a href="#_Toc454873522">Лекция 12. Символьный и строковый типы.	50</a></p><p><a href="#_Toc454873523">Лекция 13. Стандартные функции и процедуры для работы со строками	56</a></p><p><a href="#_Toc454873524">Лекция 14. Работа со строковыми переменными	61</a></p><p><a href="#_Toc454873525">Тема 2.3 Множества	66</a></p><p><a href="#_Toc454873526">Лекция 15. Понятие множества. Объявление множества. Операции над множествами	66</a></p><p><a href="#_Toc454873527">Лекция 16. Работа с данными типа множество	70</a></p><p><a href="#_Toc454873528">Тема 2.4 Записи	75</a></p><p><a href="#_Toc454873529">Лекция 17. Определение типа запись	75</a></p><p><a href="#_Toc454873530">Лекция 18. Правила работы с записями	80</a></p><p><a href="#_Toc454873531">Тема 2.5 Файлы	85</a></p><p><a href="#_Toc454873532">Лекция 19. Типы файлов. Организация доступа к файлам	85</a></p><p><a href="#_Toc454873533">Лекция 20. Файлы произвольного доступа. Порядок работы.	90</a></p><p><a href="#_Toc454873534">Лекция 21. Стандартные процедуры и функции для файлов разного типа	94</a></p><p><a href="#_Toc454873535">Лекция 22. Типизированный файл, запись/чтение	99</a></p><p><a href="#_Toc454873536">Лекция 23. Простейшая обработка элементов файла последовательного доступа	104</a></p><p><a href="#_Toc454873537">Лекция 24. Работа с несколькими файлами	109</a></p><p><a href="#_Toc454873538">Лекция 25. Поиск информации в текстовом файле	112</a></p><p><a href="#_Toc454873539">Лекция 26. Указатели. Описание указателей.	116</a></p><p><a href="#_Toc454873540">Лекция 27. Структуры данных на основе указателей	119</a></p><p><a href="#_Toc454873541">Лекция 28. Связанные списки	123</a></p><p><a href="#_Toc454873542">Лекция 29. Общие сведения о подпрограммах. Рекурсия	128</a></p><p><a href="#_Toc454873543">Лекция 30. Организация функций. Использование функций	131</a></p><p><a href="#_Toc454873544">Литература	135</a></p><h1><a id="_Toc454873506"></a><a id="_Toc454109350"></a>Раздел 1. Основные конструкции языка</h1><h1><a id="_Toc454873507"></a><a id="_Toc454109351"></a>Тема 1.1 Операторы языка программирования</h1><h1><a id="_Toc454873508"></a><a id="_Toc454109352"></a>Лекция 1. Операции и выражения. Структура программы.</h1><p>План:</p><ol><li>О Python</li><li>Описание языка</li><li>История языка Python</li><li>Программа на Python</li></ol><p>Одним из важных преимуществ языка Python является наличие большой библиотеки модулей и пакетов, входящих в стандартную поставку. Как говорят, к Python &quot;приложены батарейки&quot;. </p><p><strong>Что такое Python? </strong></p><p>О <strong>Python</strong> (лучше произносить &quot;питон&quot;, хотя некоторые говорят &quot;пайтон&quot;) - предмете данного изучения, лучше всего говорит создатель этого языка программирования, голландец Гвидо ван Россум: </p><p>&quot;Python - интерпретируемый, объектно-ориентированный высокоуровневый язык программирования с динамической семантикой. Встроенные высокоуровневые структуры данных в сочетании с динамической типизацией и связыванием делают язык привлекательным для быстрой разработки приложений (RAD, Rapid Application Development). Кроме того, его можно использовать в качестве сценарного языка для связи программных компонентов. Синтаксис Python прост в изучении, в нем придается особое значение читаемости кода, а это сокращает затраты на сопровождение программных продуктов. Python поддерживает модули и пакеты, поощряя модульность и повторное использование кода. Интерпретатор Python и большая стандартная библиотека доступны бесплатно в виде исходных и исполняемых кодов для всех основных платформ и могут свободно распространяться.&quot; </p><p>Можно считать, что Python - это целая технология для создания программных продуктов (и их прототипов). Она доступна почти на всех современных платформах (как 32-битных, так и на 64-битных) с компилятором C и на платформе Java. </p><p>Может показаться, что, в программной индустрии нет места для чего-то другого кроме C/C++, Java, Visual Basic, C#. Однако это не так. Возможно, благодаря данному курсу лекций и практических занятий у Python появятся новые приверженцы, для которых он станет незаменимым инструментом. </p><p><strong>Как описать язык? </strong></p><p>В этой лекции не ставится цели систематически описать Python: для этого существует <a href="http://ru.wikibooks.org/wiki/Справочник_по_языку_Python_3.1">оригинальное справочное руководство.</a> Здесь предлагается рассмотреть язык одновременно в нескольких аспектах, что достигается набором примеров, которые позволят быстрее приобщиться к реальному программированию, чем в случае строгого академического подхода. </p><p>Однако стоит обратить внимание на правильный подход к описанию языка. Создание программы - это всегда коммуникация, в которой программист передает компьютеру информацию, необходимую для выполнения последним действий. То, как эти действия понимает программист (то есть &quot;смысл&quot;), можно назвать <strong>семантикой</strong>. Средством передачи этого смысла является <strong>синтаксис</strong> языка программирования. Ну а то, что делает интерпретатор на основании переданного, обычно называют <strong>прагматикой</strong>. При написании программы очень важно, чтобы в этой цепочке не возникало сбоев. </p><p>Синтаксис - полностью формализованная часть: его можно описать на формальном языке синтаксических диаграмм (что и делается в справочных руководствах). Выражением прагматики является сам интерпретатор языка. Именно он читает записанное в соответствии с синтаксисом &quot;послание&quot; и превращает его в действия по заложенному в нем алгоритму. Неформальным компонентом остается только семантика. Именно в переводе смысла в формальное описание и кроется самая большая сложность программирования. Синтаксис языка Python обладает мощными средствами, которые помогают приблизить понимание проблемы программистом к ее &quot;пониманию&quot; интерпретатором. О внутреннем устройстве Python будет говориться в одной из завершающих лекций. </p><p><strong>История языка Python </strong></p><p>Создание Python было начато Гвидо ван Россумом (Guido van Rossum) в 1991 году, когда он работал над распределенной ОС Амеба. Ему требовался расширяемый язык, который бы обеспечил поддержку системных вызовов. За основу были взяты <a href="http://http/ru.wikipedia.org/wiki/ABC_(язык_программирования)">ABC </a>и <a href="http://ru.wikipedia.org/wiki/Модула-3">Модула-3.</a> В качестве названия он выбрал Python в честь комедийных серий BBC <a href="http://ru.wikipedia.org/wiki/Летающий_цирк_Монти_Пайтона">&quot;Летающий цирк Монти-Пайтона&quot;</a>, а вовсе не по названию змеи. С тех пор Python развивался при поддержке тех организаций, в которых Гвидо работал. Особенно активно язык совершенствуется в настоящее время, когда над ним работает не только команда создателей, но и целое сообщество программистов со всего мира. И все-таки последнее слово о направлении развития языка остается за Гвидо ван Россумом. </p><p><strong>Программа на Python </strong></p><p><strong>Программа</strong> на языке Python может состоять из одного или нескольких <strong>модулей</strong>. Каждый модуль представляет собой текстовый файл в кодировке, совместимой с 7-битной кодировкой ASCII. Для кодировок, использующих старший бит, необходимо явно указывать название кодировки. Например, модуль, комментарии или строковые литералы которого записаны в кодировке KOI8-R, должен иметь в первой или второй строке следующую спецификацию: </p><p># -*- coding: koi8-r -*-  </p><p>Благодаря этой спецификации интерпретатор Python будет знать, как корректно переводить символы литералов Unicode-строк в Unicode. Без этой строки новые версии Python будут выдавать предупреждение на каждый модуль, в котором встречаются коды с установленным восьмым битом. </p><p>О том, как делать программу модульной, станет известно в следующих лекциях. В примерах ниже используются как фрагменты модулей, записанных в файл, так и фрагменты диалога с интерпретатором Python. Последние отличаются характерным приглашением &gt;&gt;&gt;. Символ решетка ( # ) отмечает комментарий до конца строки. </p><p>Программа на Python, с точки зрения интерпретатора, состоит из <strong>логических строк</strong>. Одна логическая строка, как правило, располагается в одной физической, но длинные логические строки можно явно (с помощью обратной косой черты) или неявно (внутри скобок) разбить на несколько физических: print a, &quot; - очень длинная строка, которая не помещается в&quot;, \    80, &quot;знакоместах&quot; </p><p> Вопросы:</p><ol><li>О Python</li><li>Описание языка</li><li>История языка Python</li><li>Программа на Python</li></ol><h1><a id="_Toc454873509"></a><a id="_Toc454109353"></a>Лекция 2. Операторы: присваивания, условный, выбора</h1><p>План:</p><ol><li>Основные алгоритмические конструкции </li><li>Последовательность операторов</li><li>Оператор условия</li><li>Оператор  выбора</li></ol><p><strong>Основные алгоритмические конструкции </strong></p><p>Предполагается, что слушатели уже умеют программировать хотя бы на уровне школьной программы, и потому вполне достаточно провести параллели между алгоритмическими конструкциями и синтаксисом Python. Кроме того, Python как правило не подводит интуицию программиста (по крайней мере, науке хорошо известны типичные ловушки начинающих программистов на Python), поэтому изучать синтаксис Python предпочтительнее на примерах, а не с помощью синтаксических диаграмм или форм Бэкуса-Наура. </p><p><strong>Последовательность операторов </strong></p><p><strong>Последовательные действия</strong> описываются последовательными строками программы. Стоит, правда, добавить, что в программах важны отступы, поэтому все операторы, входящие в последовательность действий, должны иметь один и тот же отступ: </p><p>a = 1 b = 2 a = a + b b = a - b a = a - b print a, b </p><p> Что делает этот пример? Проверить свою догадку можно с помощью интерактивного режима интерпретатора Python. </p><p>При работе с Python в <strong>интерактивном режиме</strong> как бы вводится одна большая программа, состоящая из последовательных действий. В примере выше использованы операторы присваивания и оператор print. </p><p><strong>Оператор условия и выбора </strong></p><p>Разумеется, одними только последовательными действиями в программировании не обойтись, поэтому при написании алгоритмов используется еще и <strong>ветвление</strong>: </p><p>if a &gt; b:   c = a else:   c = b </p><p> </p><p>Этот кусок кода на Python интуитивно понятен каждому, кто помнит, что if поанглийски значит &quot;если&quot;, а else - &quot;иначе&quot;. Оператор ветвления имеет в данном случае две части, операторы каждой из которых записываются с отступом вправо относительно оператора ветвления. Более общий случай - <strong>оператор выбора</strong> - можно записать с помощью следующего синтаксиса (пример вычисления знака числа): </p><p>if a &lt; 0:   s = -1 elif a == 0: </p><p>  s = 0 else:   s = 1 </p><p> Стоит заметить, что elif - это сокращенный else if. Без сокращения пришлось бы применять <strong>вложенный</strong> оператор ветвления: </p><p>if a &lt; 0:   s = -1 else:   if a == 0:     s = 0   else:     s = 1 </p><p> В отличие от оператора print, оператор if-else - составной оператор.</p><p>Вопросы:</p><ol><li>Основные алгоритмические конструкции </li><li>Последовательность операторов</li><li>Оператор условия</li><li>Оператор  выбора</li></ol><h1><a id="_Toc454873510"></a><a id="_Toc454109354"></a>Лекция 3.  Циклы</h1><p>План:</p><ol><li>цикл ПОКА </li><li>бесконечный цикл</li><li>Цикл ДЛЯ</li><li>Функции</li><li>Исключения</li></ol><p><strong>Циклы </strong></p><p>Третьей необходимой алгоритмической конструкцией является <strong>цикл</strong>. С помощью цикла можно описать повторяющиеся действия. В Python имеются два вида циклов: <strong>цикл ПОКА</strong> (выполняется некоторое условие) и <strong>цикл ДЛЯ</strong> (всех значений последовательности). Следующий пример иллюстрирует <strong>цикл ПОКА</strong> на Python: </p><p>s = &quot;abcdefghijklmnop&quot; while s != &quot;&quot;:   print s </p><p>  s = s[1:-1] </p><p> </p><p>Оператор while говорит интерпретатору Python: &quot;пока верно <strong>условие цикла</strong>, выполнять <strong>тело цикла</strong> &quot;. В языке Python тело цикла выделяется отступом. Каждое исполнение <strong>тела цикла</strong> будет называться <strong>итерацией</strong>. В приведенном примере убирается первый и последний символ строки до тех пор, пока не останется пустая строка. </p><p>Для большей гибкости при организации циклов применяются операторы break (прервать) и continue (продолжить). Первый позволяет прервать цикл, а второй - продолжить цикл, перейдя к следующей итерации (если, конечно, выполняется условие цикла). </p><p>Следующий пример читает строки из файла и выводит те, у которых длина больше 5: </p><p>f = open(&quot;file.txt&quot;, &quot;r&quot;) while 1: </p><p>  l = f.readline()   if not l:     break   if len(l) &gt; 5:     print l, </p><p>f.close() </p><p> В этом примере организован <strong>бесконечный цикл</strong>, который прерывается только при получении из файла пустой строки ( l ), что обозначает конец файла. </p><p>В языке Python <strong>логическое значение</strong> несет каждый объект: нули, пустые строки и последовательности, специальный объект None и <strong>логический литерал</strong> False имеют значение &quot;ложь&quot;, а прочие объекты значение &quot;истина&quot;. Для обозначения истины обычно используется 1 или True. </p><p>Цикл ДЛЯ выполняет тело цикла для каждого элемента последовательности. В следующем примере выводится таблица умножения: </p><p>for i in range(1, 10):   for j in range(1, 10):     print &quot;%2i&quot; % (i*j),   print </p><p> Здесь циклы for являются <strong>вложенными</strong>. Функция range() порождает список целых чисел из полуоткрытого интервала [1, 10). Перед каждой итерацией <strong>счетчик цикла</strong> получает очередное значение из этого списка. Полуоткрытые диапазоны общеприняты в Python. Считается, что их использование более удобно и вызывает меньше программистских ошибок. Например, range(len(s)) порождает список индексов для списка s (в Python-последовательности первый элемент имеет индекс 0 ). Для красивого вывода таблицы умножения применена <strong>операция форматирования</strong> % </p><p>(для целых чисел тот же символ используется для обозначения операции взятия остатка от деления). Строка форматирования (задается слева) строится почти как <strong>строка форматирования</strong> для printf из C. </p><p><strong>Функции </strong></p><p>Программист может определять собственные функции двумя способами: с помощью оператора def или прямо в выражении, посредством lambda. Второй способ (да и вообще работа с функциями) будет рассмотрен подробнее в лекции по функциональному программированию на Python, а здесь следует привести пример определения и вызова функции: </p><p>def cena(rub, kop=0): </p><p>  return &quot;%i руб. %i коп.&quot; % (rub, kop) </p><p> print cena(8, 50) print cena(7) </p><p>print cena(rub=23, kop=70) </p><p> </p><p>В этом примере определена функция двух аргументов (из которых второй имеет <strong>значение по умолчанию</strong> - 0 ). Вариантов вызова этой функции с конкретными параметрами также несколько. Стоит только заметить, что при вызове функции сначала должны идти позиционные параметры, а затем, именованные. Аргументы со значениями по умолчанию должны следовать после обычных аргументов. Оператор return возвращает значение функции. Из функции можно возвратить только один объект , но он может быть кортежем из нескольких объектов. </p><p>После оператора def имя cena оказывается связанным с функциональным объектом. </p><p><strong>Исключения </strong></p><p>В современных программах передача управления происходит не всегда так гладко, как в описанных выше конструкциях. Для обработки особых ситуаций (таких как деление на ноль или попытка чтения из несуществующего файла) применяется механизм <strong>исключений</strong>. Лучше всего пояснить синтаксис оператора try-except следующим примером: </p><p>try: </p><p>  res = int(open('a.txt').read()) / int(open('c.txt').read())   print res except IOError: </p><p>  print &quot;Ошибка ввода-вывода&quot; except ZeroDivisionError:   print &quot;Деление на 0&quot; except KeyboardInterrupt: </p><p>  print &quot;Прерывание с клавиатуры&quot; except: </p><p>  print &quot;Ошибка&quot; </p><p> В этом примере берутся числа из двух файлов и делятся одно на другое. В результате этих нехитрых действий может возникнуть несколько исключительных ситуаций, некоторые из них отмечены в частях except (здесь использованы стандартные встроенные исключения Python). Последняя часть except в этом примере улавливает все другие исключения, которые не были пойманы выше. Например, если хотя бы в одном из файлов находится нечисловое значение, функция int() возбудит исключение ValueError. Его-то и сможет отловить последняя часть except. Разумеется, выполнение части try в случае возникновения ошибки уже не продолжается после выполнения одной из частей except. </p><p>В отличие от других языков программирования, в Python исключения нередко служат для упрощения алгоритмов. Записывая оператор try-except, программист может думать так: &quot;попробую, а если сорвется - выполнится код в except &quot;. Особенно часто это используется для выражений, в которых значение получается по ключу из отображения: </p><p>try: </p><p>  value = dict[key] except:   value = default_value Вместо </p><p>if dict.has_key(key):   value = dict[key] else: </p><p>  value = default_value </p><p> </p><p>этого подхода: в современном Python лучше записать так value = dict.get(key, default_value). </p><p> Исключения можно возбуждать и из программы. Для этого служит оператор raise. Заодно следующий пример показывает канонический способ определения собственного исключения: </p><p>class MyError(Exception): </p><p>  pass  try:   ... </p><p>  raise MyError, &quot;my error 1&quot; </p><p>  ... except MyError, x:   print &quot;Ошибка:&quot;, x </p><p> Кстати, все исключения выстроены в иерархию классов, поэтому ZeroDivisionError может быть поймана как ArithmeticError, если соответствующая часть except будет идти раньше. </p><p>Для <strong>утверждений</strong> применяется специальный оператор assert. Он возбуждает AssertionError, если заданное в нем условие неверно. Этот оператор используют для самопроверки программы. В оптимизированном коде он не выполняется, поэтому строить на нем логику алгоритма нельзя. Пример: </p><p>c = a + b </p><p>assert c == a + b </p><p> Кроме описанной формы оператора, есть еще форма try-finally для гарантированного выполнения некоторых действий при передаче управления изнутри оператора try-finally вовне. Он может применяться для освобождения занятых ресурсов, что требует обязательного выполнения, независимо от произошедших внутри катаклизмов: </p><p>try:   ... finally:   print &quot;Обработка гарантированно завершена&quot; </p><p>Вопросы:</p><ol><li>цикл ПОКА </li><li>бесконечный цикл</li><li>Цикл ДЛЯ</li><li>Функции</li><li>Исключения</li></ol><h1><a id="_Toc454873511"></a><a id="_Toc454109355"></a>Лекция 4. Программы с ветвлением</h1><p>План:</p><ol><li>Изменчивые и неизменчивые объекты </li><li>Тип int и long</li><li>Тип float</li><li>Тип complex</li><li>Последовательности</li></ol><p>Как уже говорилось, все данные в Python представлены объектами. Имена являются лишь ссылками на эти объекты и не несут нагрузки по декларации типа. Значения встроенных типов имеют специальную поддержку в синтаксисе языка: можно записать <strong>литерал</strong> строки, числа, списка, кортежа, словаря (и их разновидностей). Синтаксическую же поддержку операций над встроенными типами можно легко сделать доступной и для объектов определяемых пользователями классов. </p><p>Следует также отметить, что объекты могут быть <strong>неизменчивыми</strong> и <strong>изменчивыми</strong>. Например, строки в Python являются неизменчивыми, поэтому операции над строками создают новые строки. </p><p>Карта встроенных типов (с именами функций для приведения к нужному типу и именами классов для наследования от этих типов): </p><ul><li>специальные типы: None, NotImplemented и Ellipsis ;  </li><li>числа;  o целые  <ul><li><ul><li>обычное целое int  </li><li>целое произвольной точности long  </li><li>логический bool o число с плавающей точкой float  o комплексное число complex </li></ul></li></ul></li><li>последовательности;  o неизменчивые:  <ul><li><ul><li>строка str ;  </li><li>Unicode-строка unicode ;  </li><li>кортеж tuple ; o изменчивые:  </li><li>список list ;  	отображения:  </li></ul></li><li>словарь dict </li></ul></li><li>объекты, которые можно вызвать:  <ul><li>функции (пользовательские и встроенные);  o функции-генераторы;  o методы (пользовательские и встроенные);  o классы (новые и &quot;классические&quot;);  </li><li>экземпляры классов (если имеют метод __call__ ); </li></ul></li><li>модули;  </li><li>классы (см. выше);  </li><li>экземпляры классов (см. выше);  </li><li>файлы file ;  </li><li>вспомогательные типы buffer, slice. </li></ul><p>Узнать тип любого объекта можно с помощью встроенной функции type(). </p><p><strong>Тип int и long </strong></p><p>Два типа: int (целые числа) и long (целые произвольной точности) служат моделью для представления целых чисел. Первый соответствует типу long в компиляторе C для используемой архитектуры. Числовые литералы можно записать в системах счисления с основанием 8, 10 или 16: </p><p># В этих литералах записано число 10 </p><p>print 10, 012, 0xA, 10L </p><p>Набор операций над числами - достаточно стандартный как по семантике, так и по обозначениям: </p><p>&gt;&gt;&gt; print 1 + 1, 3 - 2, 2*2, 7/4, 5%3 </p><p>2 1 4 1 2 </p><p>&gt;&gt;&gt; print 2L ** 1000 </p><p>107150860718626732094842504906000181056140481170553360744375038 </p><p>837035105112493612249319837881569585812759467291755314682518714 </p><p>528569231404359845775746985748039345677748242309854210746050623 </p><p>711418779541821530464749835819412673987675591655439460770629145 </p><p>71196477686542167660429831652624386837205668069376 </p><p>&gt;&gt;&gt; print 3 &lt; 4 &lt; 6,      3 &gt;= 5,    4 == 4,    4 != 4  # сравнения </p><p>True False True False </p><p>&gt;&gt;&gt; print 1 &lt;&lt; 8,   4 &gt;&gt; 2,    ~4    # побитовые сдвиги и инверсия 256 1 -5 </p><p>&gt;&gt;&gt; for i, j in (0, 0), (0, 1), (1, 0), (1, 1): </p><p>...   print i, j, &quot;:&quot;, i &amp; j, i | j, i ^ j  # побитовые операции </p><p>... </p><p>0 0 : 0 0 0 </p><ol><li>1 : 0 1 1 </li><li>0 : 0 1 1 </li></ol><p>1 1 : 1 1 0 </p><p> </p><p>Значения типа int должны покрывать диапазон от -2147483648 до 2147483647, а точность целых произвольной точности зависит от объема доступной памяти. </p><p>Стоит заметить, что если в результате операции получается значение, выходящее за рамки допустимого, тип int может быть неявно преобразован в long: </p><p>&gt;&gt;&gt; type(-2147483648) &lt;type 'int'&gt; </p><p>&gt;&gt;&gt; type(-2147483649) </p><p>&lt;type 'long'&gt; </p><p> </p><p>Также нужно быть осторожным при записи констант. Нули в начале числа - признак восьмеричной системы счисления, в которой нет цифры 8: </p><p>&gt;&gt;&gt; 008 </p><p>  File &quot;&lt;stdin&gt;&quot;, line 1 </p><p>    008 </p><p>      ^ </p><p>SyntaxError: invalid token </p><p><strong>Тип float </strong></p><p>Соответствует C-типу double для используемой архитектуры. Записывается вполне традиционным способом либо через точку, либо в нотации с экспонентой: </p><p>&gt;&gt;&gt; pi = 3.1415926535897931 </p><p>&gt;&gt;&gt; pi ** 40 </p><p>7.6912142205156999e+19 </p><p>Кроме арифметических операций, можно использовать операции из модуля math. </p><p>Из полезных встроенных функций можно вспомнить round(), abs(). </p><p><strong>Тип complex </strong></p><p>Литерал мнимой части задается добавлением j в качестве суффикса (перемножаются мнимые единицы): </p><p>&gt;&gt;&gt; -1j * -1j </p><p>(-1-0j) </p><p> Тип реализован на базе вещественного. Кроме арифметических операций, можно использовать операции из модуля cmath. </p><p><strong>Тип bool </strong></p><p>Подтип целочисленного типа для &quot;канонического&quot; обозначения логических величин. Два значения: True (истина) и False (ложь) - вот и все, что принадлежит этому типу. Как уже говорилось, любой объект Python имеет истинностное значение, логические операции можно проиллюстрировать с помощью логического типа: </p><p>&gt;&gt;&gt; for i in (False, True): ...   for j in (False, True): </p><p>...     print i, j, &quot;:&quot;, i and j, i or j, not i </p><p>... </p><p>... </p><p>False False : False False True </p><p>False True : False True True </p><p>True False : False True False True True : True True False </p><p> Следует отметить, что Python даже не вычисляет второй операнд операции and или or, если ее исход ясен по первому операнду. Таким образом, если первый операнд истинен, он и возвращается как результат or, в противном случае возвращается второй операнд. Для операции and все аналогично. </p><p><strong>Последовательности </strong></p><p>Ниже обобщены основные методы последовательностей. Следует напомнить, что последовательности бывают неизменчивыми и изменчивыми. У последних методов чуть больше. </p><table><tr><td><p><strong>Синтаксис </strong></p></td><td><p><strong>Семантика </strong></p></td></tr><tr><td><p>len(s) </p></td><td><p>Длина последовательности s </p></td></tr><tr><td><p>x in s </p></td><td><p>Проверка принадлежности элемента последовательности. В новых версиях Python можно проверять принадлежность подстроки строке. Возвращает </p><p>True или False </p></td></tr><tr><td><p>x not in s </p></td><td><p>= not x in s </p></td></tr><tr><td><p>s + s1  </p></td><td><p>Конкатенация последовательностей </p></td></tr><tr><td><p>s*n 	или </p><p>n*s  </p></td><td><p>Последовательность из n раз повторенной s. Если n &lt; 0, возвращается пустая последовательность. </p></td></tr><tr><td><p>s[i]  </p></td><td><p>Возвращает i -й элемент s или len(s)-i -й, если i &lt; 0 </p></td></tr><tr><td><p>s[i:j:d]  </p></td><td><p>Срез из последовательности s от i до j с шагом d будет рассматриваться ниже </p></td></tr><tr><td><p>min(s)  </p></td><td><p>Наименьший элемент s </p></td></tr><tr><td><p>max(s)  </p></td><td><p>Наибольший элемент s </p></td></tr></table><p>Дополнительные конструкции для изменчивых последовательностей: </p><table><tr><td><p>s[i] = x </p></td><td><p>i -й элемент списка s заменяется на x </p></td></tr><tr><td><p>s[i:j:d] = t </p></td><td><p>Срез от i до j (с шагом d ) заменяется на (список) t </p></td></tr><tr><td><p>del s[i:j:d] </p></td><td><p>Удаление элементов среза из последовательности </p></td></tr></table><p> </p><p>Вопросы:</p><ol><li>Изменчивые и неизменчивые объекты </li><li>Тип int и long</li><li>Тип float</li><li>Тип complex</li><li>Последовательности</li></ol><h1><a id="_Toc454873512"></a><a id="_Toc454109356"></a>Лекция 5. Сложные логические условия</h1><p>План:</p><ol><li>Стиль программирования </li><li>рекомендации написания комментариев</li><li>документация модулей, классов, функций и методов</li><li>именование объектов</li></ol><p><strong>Стиль программирования</strong> - дополнительные ограничения, накладываемые на структуру и вид программного кода группой совместно работающих программистов с целью получения удобных для применения, легко читаемых и эффективных программ. Основные ограничения на вид программы дает синтаксис языка программирования, и его нарушения вызывают синтаксические ошибки. Нарушение стиля не приводит к синтаксическим ошибкам, однако как отдельные программисты, так и целые коллективы сознательно ограничивают себя в средствах выражения ради упрощения совместной разработки, отладки и сопровождения программного продукта. </p><p>Стиль программирования затрагивает практически все аспекты написания кода: </p><ul><li>именование объектов в зависимости от типа, назначения, области видимости;  </li><li>оформление функций, методов, классов, модулей и их документирование в коде программы;  </li><li>декомпозиция программы на модули с определенными характеристиками;  </li><li>способ включения отладочной информации;  </li><li>применение тех или иных функций (методов) в зависимости от предполагаемого уровня совместимости разрабатываемой программы с различными компьютерными платформами;  </li><li>ограничение используемых функций из соображений безопасности.  </li></ul><p>Наиболее существенные положения этого стиля перечислены ниже. В случае сомнений хорошим образцом стиля являются модули стандартной библиотеки. </p><ul><li>Рекомендуется использовать отступы в 4 пробела.  </li><li>Длина физической строки не должна превышать 79 символов.  </li><li>Длинные логические строки лучше разбивать неявно (внутри скобок), но и явные методы вполне уместны. Отступы строк продолжения рекомендуется выравнивать по скобкам или по первому операнду в предыдущей строке. Текстовый редактор Emacs в режиме python-mode и некоторые интегрированные оболочки (IDE) автоматически делают необходимые отступы в Pythonпрограммах:  </li><li>def draw(figure, color=&quot;White&quot;, border_color=&quot;Black&quot;,           size=5): </li><li>if color == border_color or \         size == 0:          raise &quot;Bad figure&quot;      else: </li><li>_draw(size, size, (color,                            border_color)) </li><li>Не рекомендуется ставить пробелы сразу после открывающей скобки или перед закрывающей, перед запятой, точкой с запятой, перед открывающей скобкой при записи вызова функции или индексного выражения. Также не рекомендуется ставить более одного пробела вокруг знака равенства в присваиваниях. Пробелы вокруг знака равенства не ставятся в случае, когда он применяется для указания значения по умолчанию в определении параметров функции или при задании именованных аргументов.  </li><li>Также рекомендуется применение одиночных пробелов вокруг низкоприоритетных операций сравнения и оператора присваивания. Пробелы вокруг более приоритетных операций ставятся в равном количестве слева и справа от знака операции. </li></ul><p>Несколько рекомендаций касаются написания комментариев. </p><ul><li>Комментарии должны точно отражать актуальное состояние кода. (Поддержание актуальных комментариев должно быть приоритетной задачей!) После коротких комментариев можно не ставить точку, тогда как длинные лучше писать по правилам написания текста. Автор Python обращается к неанглоязычным программистам с просьбой писать комментарии на английском, если есть хотя бы небольшая вероятность того, что код будут читать специалисты, говорящие на других языках.  </li><li>Комментарии к фрагменту кода следует писать с тем же отступом, что и комментируемый код. После &quot; # &quot; должен идти одиночный пробел. Абзацы можно отделять строкой с &quot; # &quot; на том же уровне. Блочный комментарий можно отделить пустыми строками от окружающего кода.  </li><li>Комментарии, относящиеся к конкретной строке, не следует использовать часто. Символ &quot; # &quot; должен отстоять от комментируемого оператора как минимум на два пробела.  </li><li>Хороший комментарий не перефразирует программу, а содержит дополнительную информацию о действии программы в терминах предметной области. </li></ul><p>Все модули, классы, функции и методы, предназначенные для использования за пределами модуля, должны иметь строки документации, описывающие способ их применения, входные и выходные параметры. </p><ul><li>Строка документации для отдельной программы должна объяснять используемые ею ключи, назначение аргументов и переменных среды и другую подобную информацию.  </li><li>Для строк документации рекомендуется везде использовать утроенные кавычки ( </li></ul><p>&quot;&quot;&quot; ).  </p><ul><li>Однострочная документация пишется в императиве, как команда: &quot;делай это&quot;, &quot;возвращай то&quot;.  </li><li>Многострочная документация содержит расширенное описание модуля, функции, класса. Она будет смотреться лучше, если текст будет написан с тем же отступом, что и начало строки документации.  </li><li>Документация для модуля должна перечислять экспортируемые функции, классы, исключения и другие объекты, по одной строке на объект.  </li><li>Строка документации для функции или метода должна кратко описывать действия функции, ее входные параметры и возвращаемое значение, побочные эффекты и возможные исключения (если таковые есть). Должны быть обозначены необязательные аргументы и аргументы, не являющиеся частью интерфейса.  </li><li>Документация для класса должна перечислять общедоступные методы и атрибуты, содержать рекомендации по применению класса в качестве базового для других классов. Если класс является подклассом, необходимо указать, какие методы полностью заменяют, перегружают, а какие используют, но расширяют соответствующие методы надкласса. Необходимо указать и другие изменения по сравнению с надклассом.  </li><li>Контроль версий повышает качество процесса создания программного обеспечения. Для этих целей часто используются RCS или CVS. &quot;Python Style Guide&quot; рекомендует записывать $Revision: 1.31 $ в переменную с именем __version__, а другие данные заключать в комментарии &quot; # &quot;. </li></ul><p>Сегодня сосуществуют несколько более или менее широко распространенных правил именования объектов. Программисты вольны выбрать тот, который принят в их организации или конкретном проекте. Автор Python рекомендует придерживаться нижеследующих правил для именования различных объектов, с тем чтобы это было понятно любому программисту, использующему Python. </p><ul><li>Имена модулей лучше давать строчными буквами, например, shelve, string, либо делать первые буквы слов прописными, StringIO, UserDict. Имена написанных на C модулей расширения обычно начинаются с подчеркивания &quot; _ &quot;, а соответствующие им высокоуровневые обертки - с прописных букв: </li></ul><p>_tkinter и Tkinter.  </p><ul><li>Ключевые слова нельзя использовать в качестве имен, однако, если все-таки необходимо воспользоваться этим именем, стоит добавить одиночное подчеркивание в конце имени. Например: class_.  </li><li>Классы обычно называют, выделяя первые буквы слов прописными, как в Tag или HTTPServer.  </li><li>Имена исключений обычно содержат в своем составе слово &quot;error&quot; (или &quot;warning&quot;). Встроенные модули пишут это слово со строчной буквы (как os.error ) (но могут писать и с прописной): distutils.DistutilsModuleError.  </li><li>Функции, экспортируемые модулем, могут именоваться по-разному. Можно давать с прописных букв имена наиболее важных функций, а вспомогательные писать строчными.  </li><li>Имена глобальных переменных (если таковые используются) лучше начинать с подчеркивания, чтобы они не импортировались из модуля оператором fromimport со звездочкой.  </li><li>Имена методов записываются по тем же правилам, что и имена функций.  </li><li>Имена констант (имен, которые не должны переопределяться) лучше записывать прописными буквами, например: RED, GREEN, BLUE.  </li><li>При работе с языком Python необходимо учитывать, что интерпретатор считает некоторые классы имен специальными (обычно такие имена начинаются с подчеркивания). </li></ul><p>Вопросы:</p><ol><li>Стиль программирования </li><li>рекомендации написания комментариев</li><li>документация модулей, классов, функций и методов</li><li>именование объектов</li></ol><h1><a id="_Toc454873513"></a><a id="_Toc454109357"></a>Лекция 6. Вложенные операторы</h1><p>План:</p><ol><li>Понятие модуля </li><li>Модули в Python</li><li>Встроенные функции</li><li>Функции преобразования типов и классы</li><li>Числовые и строковые функции</li></ol><p>Одним из важных преимуществ языка Python является наличие большой библиотеки модулей и пакетов, входящих в стандартную поставку. Как говорят, к Python &quot;приложены батарейки&quot;. </p><p><strong>Понятие модуля </strong></p><p>Перед тем как приступить к изучению модулей стандартной библиотеки, необходимо определить то, что в Python называется <strong>модулем</strong>. </p><p>В соответствии с модульным подходом к программированию большая задача разбивается на несколько более мелких, каждую из которых (в идеале) решает отдельный модуль. В разных методологиях даются различные ограничения на размер модулей, однако при построении модульной структуры программы важнее составить такую композицию модулей, которая позволила бы свести к минимуму связи между ними. Набор классов и функций, имеющий множество связей между своими элементами, было бы логично расположить в одном модуле. Есть и еще одно полезное замечание: модули должно быть легче использовать, чем написать заново. Это значит, что модуль должен иметь удобный <strong>интерфейс</strong>: набор функций, классов и констант, который он предлагает своим пользователям. </p><p>В языке Python набор модулей, посвященных одной проблеме, можно поместить в <strong>пакет</strong>. Хорошим примером такого пакета является пакет xml, в котором собраны модули для различных аспектов обработки XML. </p><p>В программе на Python модуль представлен объектом-модулем, атрибутами которого являются имена, определенные в модуле: </p><p>&gt;&gt;&gt; import datetime </p><p>&gt;&gt;&gt; d1 = datetime.date(2004, 11, 20) </p><p> В данном примере импортируется модуль datetime. В результате работы оператора import в текущем пространстве имен появляется объект с именем datetime. </p><p>Модули для использования в программах на языке Python по своему происхождению делятся на обычные (написанные на Python) и модули расширения, написанные на другом языке программирования (как правило, на C). С точки зрения пользователя они могут отличаться разве что быстродействием. Бывает, что в стандартной библиотеке есть два варианта модуля: на Python и на C. Таковы, например, модули pickle и cPickle. Обычно модули на Python в чем-то гибче, чем модули расширения. </p><p><strong>Модули в Python </strong></p><p>Модуль оформляется в виде отдельного файла с исходным кодом. Стандартные модули находятся в каталоге, где их может найти соответствующий интерпретатор языка. Пути к каталогам, в которых Python ищет модули, можно увидеть в значении переменной sys.path: </p><p>&gt;&gt;&gt; sys.path </p><p>['', </p><p>'/usr/local/lib/python23.zip', </p><p>'/usr/local/lib/python2.3',  </p><p>'/usr/local/lib/python2.3/plat-linux2', </p><p>'/usr/local/lib/python2.3/lib-tk',  </p><p>'/usr/local/lib/python2.3/lib-dynload',  '/usr/local/lib/python2.3/site-packages']  </p><p>В последних версиях Python модули можно помещать и в zip-архивы для более компактного хранения (по аналогии с jar-архивами в Java). </p><p>При запуске программы поиск модулей также идет в текущем каталоге. (Нужно внимательно называть собственные модули, чтобы не было конфликта имен со стандартными или дополнительно установленными модулями.) </p><p>Подключение модуля к программе на Python осуществляется с помощью оператора import. У него есть две формы: import и from-import: </p><p>import os import pre as re from sys import argv, environ from string import * </p><p> С помощью первой формы с текущей областью видимости связывается только имя, ссылающееся на объект модуля, а при использовании второй - указанные имена (или все имена, если применена * ) объектов модуля связываются с текущей областью видимости. При импорте можно изменить имя, с которым объект будет связан, с помощью as. В первом случае пространство имен модуля остается в отдельном имени и для доступа к конкретному имени из модуля нужно применять точку. Во втором случае имена используются так, как если бы они были определены в текущем модуле: </p><p>os.system(&quot;dir&quot;) digits = re.compile(&quot;\d+&quot;) </p><p>print argv[0], environ </p><p> Повторный импорт модуля происходит гораздо быстрее, так как модули кэшируются интерпретатором. Загруженный модуль можно загрузить еще раз (например, если модуль изменился на диске) с помощью функции reload(): </p><p>import mymodule </p><p>. . . </p><p>reload(mymodule) </p><p> Однако в этом случае все объекты, являющиеся экземплярами классов из старого варианта модуля, не изменят своего поведения. </p><p>При работе с модулями есть и другие тонкости. Например, сам процесс импорта модуля можно переопределить. Подробнее об этом можно узнать в оригинальной документации. </p><p><strong>Встроенные функции </strong></p><p>В среде Python без дополнительных операций импорта доступно более сотни встроенных объектов, в основном, функций и исключений. Для удобства функции условно разделены по категориям: </p><ol><li>Функции преобразования типов и классы: coerce, str, repr, int, list, tuple, long, float, complex, dict, super, file, bool, object  </li><li>Числовые и строковые функции: abs, divmod, ord, pow, len, chr, unichr, hex, oct, cmp, round, unicode  </li><li>Функции обработки данных: apply, map, filter, reduce, zip, range, xrange, max, min, iter, enumerate, sum  </li><li>Функции определения свойств: hash, id, callable, issubclass, isinstance, type  </li><li>Функции для доступа к внутренним структурам: locals, globals, vars, intern, dir  </li><li>Функции компиляции и исполнения: eval, execfile, reload, __import__, compile  </li><li>Функции ввода-вывода: input, raw_input, open  </li><li>Функции для работы с атрибутами: getattr, setattr, delattr, hasattr  </li><li>Функции-&quot;украшатели&quot; методов классов: staticmethod, classmethod, property  10. Прочие функции: buffer, slice </li></ol><p><strong>Функции преобразования типов и классы </strong></p><p>Функции и классы из этой категории служат для преобразования типов данных. В старых версиях Python для преобразования к нужному типу использовалась одноименная функция. В новых версиях Python роль таких функций играют имена встроенных классов (однако семантика не изменилась). Для понимания сути достаточно небольшого примера: </p><p>&gt;&gt;&gt; int(23.5) </p><p>23 </p><p>&gt;&gt;&gt; float('12.345') </p><p>12.345000000000001 </p><p>&gt;&gt;&gt; dict([('a', 2), ('b', 3)]) </p><p>{'a': 2, 'b': 3} </p><p>&gt;&gt;&gt; object </p><p>&lt;type 'object'&gt; </p><p>&gt;&gt;&gt; class MyObject(object): ...   pass ... </p><p><strong> </strong></p><p><strong>Числовые и строковые функции </strong></p><p>Функции работают с числовыми или строковыми аргументами. В следующей таблице даны описания этих функций. </p><table><tr><td><p>abs(x) </p></td><td><p>Модуль числа x. Результат: |x|. </p></td></tr><tr><td><p>divmod(x, y) </p></td><td><p>Частное и остаток от деления. Результат: (частное, остаток). </p></td></tr><tr><td><p>pow(x, y[, m]) </p></td><td><p>Возведение x в степень y по модулю m. Результат: x**y % m. </p></td></tr><tr><td><p>round(n[, z]) </p></td><td><p>Округление чисел до заданного знака после (или до) точки. </p></td></tr><tr><td><p>ord(s) </p></td><td><p>Функция возвращает код (или Unicode) заданного ей символа в односимвольной строке. </p></td></tr><tr><td><p>chr(n) </p></td><td><p>Возвращает строку с символом с заданным кодом. </p></td></tr><tr><td><p>len(s) </p></td><td><p>Возвращает число элементов последовательности или отображения. </p></td></tr><tr><td><p>oct(n), hex(n) </p></td><td><p>Функции возвращают строку с восьмеричным или шестнадцатеричным представлением целого числа n. </p></td></tr><tr><td><p>cmp(x, y) </p></td><td><p>Сравнение двух значений. Результат: отрицательный, ноль или положительный, в зависимости от результата сравнения. </p></td></tr><tr><td><p>unichr(n) </p></td><td><p>Возвращает односимвольную Unicode-строку с символом с кодом n. </p></td></tr><tr><td><p>unicode(s [, encoding[, errors]]) </p></td><td><p> Создает Unicode-объект, соответствующий строке s в заданной кодировке encoding. Ошибки кодирования обрабатываются в соответствии с errors, который может принимать значения: 'strict' (строгое преобразование), 'replace' (с заменой несуществующих символов) или 'ignore' (игнорировать несуществующие символы). По умолчанию: encoding='utf-8', errors='strict'. </p></td></tr></table><p> </p><p> Вопросы:</p><ol><li>Понятие модуля </li><li>Модули в Python</li><li>Встроенные функции</li><li>Функции преобразования типов и классы</li><li>Числовые и строковые функции</li></ol><h1><a id="_Toc454873514"></a><a id="_Toc454109358"></a>Лекция 7. Циклы с параметром</h1><p>План:</p><ol><li>Сервисы периода выполнения </li><li>Поддержка цикла разработки</li><li>Взаимодействие с ОС</li><li>Обработка текстов</li></ol><p>Обзор стандартной библиотеки </p><p>Модули стандартной библиотеки можно условно разбить на группы по тематике. </p><p>1.	Сервисы периода выполнения. Модули: sys, atexit, copy, traceback, math, cmath, random, time, calendar, datetime, sets, array, struct, itertools, locale, gettext.  </p><p>2.	Поддержка цикла разработки. Модули: pdb, hotshot, profile, unittest, pydoc. Пакеты docutils, distutils.  </p><p>3.	Взаимодействие с ОС (файлы, процессы). Модули: os, os.path, getopt, glob, popen2, shutil, select, signal, stat, tempfile.  </p><p>4.	Обработка текстов. Модули: string, re, StringIO, codecs, difflib, mmap, sgmllib, htmllib, htmlentitydefs. Пакет xml.  </p><p>5.	Многопоточные вычисления. Модули: threading, thread, Queue.  </p><p>6.	Хранение данных. Архивация. Модули: pickle, shelve, anydbm, gdbm, gzip, zlib, zipfile, bz2, csv, tarfile.  </p><p>7.	Платформо-зависимые модули. Для UNIX: commands, pwd, grp, fcntl, resource, termios, readline, rlcompleter. Для Windows: msvcrt, _winreg, winsound.  </p><p>8.	Поддержка сети. Протоколы Интернет. Модули: cgi, Cookie, urllib, urlparse, httplib, smtplib, poplib, telnetlib, socket, asyncore. Примеры серверов: SocketServer, BaseHTTPServer, xmlrpclib, asynchat.  </p><p>9.	Поддержка Internet. Форматы данных. Модули: quopri, uu, base64, binhex, binascii, rfc822, mimetools, MimeWriter, multifile, mailbox. Пакет email.  </p><p>10.	Python о себе. Модули: parser, symbol, token, keyword, inspect, tokenize, pyclbr, py_compile, compileall, dis, compiler.  </p><p>11.	Графический интерфейс. Модуль Tkinter. </p><p>Сервисы периода выполнения </p><p>Модуль sys </p><p>Модуль sys содержит информацию о среде выполнения программы, об интерпретаторе Python. Далее будут представлены наиболее популярные объекты из этого модуля: остальное можно изучить по документации. </p><p>exit([c]) 	Выход из программы. Можно передать числовой код завершения: 0 в случае успешного завершения, другие числа при аварийном завершении программы. </p><p>argv 	Список аргументов командной строки. Обычно sys.argv[0] содержит имя запущенной программы, а остальные параметры передаются из командной строки. </p><p>Модуль itertools </p><p>Этот модуль содержит набор функций для работы с итераторами. Итераторы позволяют работать с данными последовательно, как если бы они получались в цикле. Альтернативный подход - использование списков для хранения промежуточных результатов - требует подчас большого количества памяти, тогда как использование итераторов позволяет получать значения на момент, когда они действительно требуются для дальнейших вычислений. Итераторы будут рассмотрены более подробно в лекции по функциональному программированию. </p><p>Модуль locale </p><p>Модуль locale применяется для работы с культурной средой. В конкретной культурной среде могут использоваться свои правила для написания чисел, валют, времени и даты и т.п. Следующий пример выводит дату сначала в культурной среде &quot;C&quot;, а затем на русском языке: </p><p>import time, locale </p><p>locale.setlocale(locale.LC_ALL, None) </p><p>print time.strftime(&quot;%d %B %Y&quot;, time.localtime (time.time())) locale.setlocale(locale.LC_ALL, &quot;ru_RU.KOI8-R&quot;) </p><p>print time.strftime(&quot;%d %B %Y&quot;, time.localtime (time.time())) </p><p> </p><p>В результате: </p><p>18 November 2004 </p><p>18 Ноября 2004 </p><p> </p><p>Модуль gettext </p><p>При интернационализации программы важно не только предусмотреть возможность использования нескольких культурных сред, но и перевод сообщений и меню программы на соответствующий язык. Модуль gettext позволяет упростить этот процесс достаточно стандартным способом. Основные сообщения программы пишутся на английском языке. А переводы строк, отмеченных в программе специальным образом, даются в виде отдельных файлов, по одному на каждый язык (или культурную среду). Уточнить нюансы использования gettext можно по документации к Python. </p><p>Поддержка цикла разработки </p><p>Модули этого раздела помогают поддерживать документацию, производить регрессионное тестирование, отлаживать и профилировать программы на Python, а также обслуживают распространение готовых программ, создавая среду для конфигурирования и установки пакетов. </p><p>В качестве иллюстрации можно предположить, что создается модуль для вычисления простых чисел по алгоритму &quot;решето Эратосфена&quot;. Модуль будет находиться в файле Sieve.py и состоять из одной функции primes(N), которая в результате своей работы дает все простые (не имеющие натуральных делителей кроме себя и единицы) числа от 2 до N: </p><p>import sets import math </p><p>&quot;&quot;&quot;Модуль для вычисления простых чисел от 2 до N &quot;&quot;&quot; def primes(N): </p><p>  &quot;&quot;&quot;Возвращает все простые от 2 до N&quot;&quot;&quot;   sieve = sets.Set(range(2, N))   for i in range(2, math.sqrt(N)):     if i in sieve: </p><p>      sieve -= sets.Set(range(2*i, N, i))   return sieve </p><p>Модуль pdb </p><p>Модуль pdb предоставляет функции отладчика с интерфейсом - командной строкой. Сессия отладки вышеприведенного модуля могла бы быть такой: </p><p>Здесь ncalls - количество вызовов функции или метода, tottime - полное время выполнения кода функции (без времени нахождения в вызываемых функциях), percall - тоже, в пересчете на один вызов, cumtime - аккумулированное время нахождения в функции, вместе со всеми вызываемыми функциями. В последнем столбце приведено имя файла, номер строки с функцией или методом и его имя. </p><p>Примечание: </p><p>&quot;Странные&quot; имена, например, __iter__, __contains__ и __isub__ - имена методов, реализующих итерацию по элементам, проверку принадлежности элемента ( in ) и операцию -=. Метод __init__ - конструктор объекта (в данном случае - множества). </p><p>Модуль unittest </p><p>При разработке программного обеспечения рекомендуется применять так называемые регрессионные испытания. Для каждого модуля составляется набор тестов, по возможности таким образом, чтобы проверялись не только типичные вычисления, но и &quot;крайние&quot;, вырожденные случаи, чтобы испытания затронули каждую ветку алгоритма хотя бы один раз. Тест для данного модуля (написанный сразу после того, как определен интерфейс модуля) находится в файле test_Sieve.py: </p><p># file: test_Sieve.py import Sieve, sets import unittest </p><p> class TestSieve(unittest.TestCase): </p><p>     def setUp(self): </p><p>        pass </p><p>     def testone(self): </p><p>        primes = Sieve.primes(1) </p><p>        self.assertEqual(primes, sets.Set()) </p><p>     def test100(self): </p><p>        primes = Sieve.primes(100) </p><p>        self.assert_(primes == sets.Set([2, 3, 5, 7, 11, 13, 17, 19, 23, </p><p>29, 31, 37, 41, 43, 47,  </p><p>                53, 59, 61, 67, 71, 73, 79, 83, 89, 97])) </p><p> if __name__ == '__main__': </p><p>    unittest.main() </p><p>Тестовый модуль состоит из определения класса, унаследованного от класса unittest.TestCase, в котором описывается подготовка к испытаниям (метод setUp ) и сами испытания -- методы, начинающиеся на test. В данном случае таких испытаний всего два: в первом испытывается случай N=1, а во втором -- N=100. </p><p>Запуск тестов производится выполнением функции unittest.main(). Вот как выглядят успешные испытания: </p><p>$ python test_Sieve.py </p><p>.. </p><p>---------------------------------------------------------------------- Ran 2 tests in 0.002s </p><p> </p><p>Почти все современные приложения имеют графический интерфейс пользователя. Такие приложения можно создавать и на языке Python. В стандартной поставке имеется модуль Tkinter, который есть не что иное, как интерфейс к языку Tcl/Tk, на котором можно описывать графический интерфейс. </p><p>Следует отметить, что существуют и другие пакеты для программирования графического интерфейса: wxPython (основан на wxWindows), PyGTK и т.д. Среди этих пакетов в основном такие, которые работают на одной платформе (реже - на двух). </p><p>Помимо возможностей программного описания графического интерфейса, для Python есть несколько коммерческих и некоммерческих построителей графического интерфейса (GUI builders), однако в данном курсе они не рассматриваются.</p><p>Вопросы:</p><ol><li>Сервисы периода выполнения </li><li>Поддержка цикла разработки</li><li>Взаимодействие с ОС</li><li>Обработка текстов</li></ol><h1><a id="_Toc454873515"></a><a id="_Toc454109359"></a>Раздел 2 Структуры данных</h1><h1><a id="_Toc454873516"></a><a id="_Toc454109360"></a>Тема 2.1 Массивы  </h1><h1><a id="_Toc454873517"></a><a id="_Toc454109361"></a>Лекция 8. Объявление массива. Инициализация. Действия над массивами.</h1><p>План:</p><ol><li>Абстракции </li><li>Функциональное программирование</li><li>Функция: определение и вызов</li><li>Рекурсия</li><li>Функция apply()</li></ol><p>Функции являются <strong>абстракциями</strong>, в которых детали реализации некоторого действия скрываются за отдельным именем. Хорошо написанный набор функций позволяет использовать их много раз. Стандартная библиотека Python содержит множество готовых и отлаженных функций, многие из которых достаточно универсальны, чтобы работать с широким спектром входных данных. Даже если некоторый участок кода не используется несколько раз, но по входным и выходным данным он достаточно автономен, его смело можно выделить в отдельную функцию. </p><p>Эта лекция более ориентирована на практические соображения, а не на теорию функционального программирования. Однако там, где нужно, будут употребляться и поясняться соответствующие термины. </p><p>Далее будут подробно рассмотрены описание и использование функций в Python, рекурсия, передача и возврат функций в качестве параметров, обработка последовательностей и итераторы, а также такое понятие как генератор. Будет продемонстрировано, что в Python функции являются объектами (и, значит, могут быть переданы в качестве параметров и возвращены в результате выполнения функций). Кроме того, речь пойдет о том, как можно реализовать некоторые механизмы функционального программирования, не имеющие в Python прямой синтаксической поддержки, но широко распространенные в языках функционального программирования. </p><p><strong>Функциональное программирование</strong> - это стиль программирования, использующий только композиции функций. Другими словами, это программирование в выражениях, а не в императивных командах. </p><p>Как отмечает Дэвид Мертц (David Mertz) в своей статье о функциональном программировании на Python, &quot;функциональное программирование - программирование на функциональных языках (LISP, ML, OCAML, Haskell, ...)&quot;, основными атрибутами которых являются: </p><ul><li>&quot;Наличие функций первого класса (функции наравне с другими объектами можно передавать внутрь функций).  </li><li>Рекурсия является основной управляющей структурой в программе.  </li><li>Обработка списков (последовательностей).  </li><li>Запрещение побочных эффектов у функций, что в первую очередь означает отсутствие присваивания (в &quot;чистых&quot; функциональных языках)  </li><li>Запрещение операторов, основной упор делается на выражения. Вместо операторов вся программа в идеале - одно выражение с сопутствующими определениями.  </li><li>Ключевой вопрос: <strong>что</strong> нужно вычислить, а не <strong>как</strong>.  </li><li>Использование функций более высоких порядков (функции над функциями над </li></ul><p>функциями)&quot;. </p><p><strong>Функциональная программа </strong></p><p><strong>В математике функция</strong> отображает объекты из одного множества ( <strong>множества определения функции</strong> ) в другое ( <strong>множество значений функции</strong> ). Математические функции (их называют <strong>чистыми</strong> ) &quot;механически&quot;, однозначно вычисляют результат по заданным аргументам. Чистые функции не должны хранить в себе какие-либо данные между двумя вызовами. Их можно представлять себе черными ящиками, о которых известно только то, что они делают, но совсем не важно, как. </p><p>Программы в функциональном стиле конструируются как <strong>композиция</strong> функций. При этом функции понимаются почти так же, как и в математике: они отображают одни объекты в другие. В программировании &quot;чистые&quot; функции - идеал, не всегда достижимый на практике. Практически полезные функции обычно имеют <strong>побочный эффект</strong>: сохраняют состояние между вызовами или меняют состояние других объектов. Например, без побочных эффектов невозможно представить себе функции ввода-вывода. Собственно, такие функции ради этих &quot;эффектов&quot; и используются. Кроме того, математические функции легко работают с объектами, требующими бесконечного объема информации (например, вещественные числа). В общем случае компьютерная программа может выполнить лишь приближенные вычисления. </p><p>Кстати, бинарные операции &quot; + &quot;, &quot; - &quot;, &quot; * &quot;, &quot; / &quot;, которые записываются в выражениях, являются &quot;математическими&quot; функциями над двумя аргументами -- <strong>операндами</strong>. Их используют настолько часто, что синтаксис языка программирования имеет для них более короткую запись. Модуль operator позволяет представлять эти операции в функциональном стиле: </p><p>&gt;&gt;&gt; from operator import add, mul </p><p>&gt;&gt;&gt; print add(2, mul(3, 4)) </p><p>14 </p><p><strong>Функция: определение и вызов </strong></p><p>Как уже говорилось, определить функцию в Python можно двумя способами: с помощью оператора def и lambda -выражения. Первый способ позволяет использовать операторы. При втором - определение функции может быть только выражением. </p><p>Забегая вперед, можно заметить, что методы классов определяются так же, как и функции. Отличие состоит в специальном смысле первого аргумента self (в нем передается экземпляр класса). </p><p>Лучше всего рассмотреть синтаксис определения функции на нескольких примерах. После определения соответствующей функции показан один или несколько вариантов ее вызова (некоторые примеры взяты из стандартной библиотеки). </p><p>Определение функции должно содержать список <strong>формальных параметров</strong> и <strong>тело определения функции</strong>. В случае с оператором def функции также задается некоторое имя. Формальные параметры являются локальными именами внутри тела определения функции, а при вызове функции они оказываются связанными с объектами, переданными как фактические параметры. Значения по умолчанию вычисляются в момент выполнения оператора def, и потому в них можно использовать видимые на момент определения имена. </p><p>Вызов функции синтаксически выглядит как объект-функция(фактические параметры). Обычно объект-функция - это просто имя функции, хотя это может быть и любое выражение, которое в результате вычисления дает исполняемый объект. </p><p>Функция одного аргумента: </p><p>def swapcase(s): </p><p>    return s.swapcase() </p><p> </p><p>print swapcase(&quot;ABC&quot;) </p><p>Функция двух аргументов, один из которых необязателен и имеет значение по умолчанию: </p><p>def inc(n, delta=1):     return n+delta </p><p> print inc(12) print inc(12, 2) </p><p>Функция с одним обязательным аргументом, с одним, имеющим значение по умолчанию и неопределенным числом именованных аргументов: </p><p>def wrap(text, width=70, **kwargs):    from textwrap import TextWrapper </p><p>   # kwargs  - словарь с именами и значениями аргументов    w = TextWrapper(width=width, **kwargs)    return w.wrap(text) </p><p> print wrap(&quot;my long text ...&quot;, width=4) Функция произвольного числа аргументов: </p><p>def max_min(*args): </p><p>  # args - список аргументов в порядке их указания при вызове   return max(args), min(args) </p><p> print max_min(1, 2, -1, 5, 3) </p><p>Функция с обычными (позиционными) и именованными аргументами: </p><p>def swiss_knife(arg1, *args, **kwargs): </p><p>  print arg1   print args   print kwargs   return None </p><p> </p><p>print swiss_knife(1) print swiss_knife(1, 2, 3, 4, 5) </p><p>print swiss_knife(1, 2, 3, a='abc', b='sdf') </p><p># print swiss_knife(1, a='abc', 3, 4)  # !!! ошибка </p><p> </p><p>lst = [2, 3, 4, 5] dct = {'a': 'abc', 'b': 'sdf'} print swiss_knife(1, *lst, **dct) </p><p>Пример определения функции с помощью lambda -выражения дан ниже: </p><p>func = lambda x, y: x + y </p><p>В результате lambda -выражения получается безымянный объект-функция, которая затем используется, например, для того, чтобы связать с ней некоторое имя. Однако, как правило, определяемые lambda -выражением функции, применяются в качестве параметров функций. </p><p>В языке Python функция может возвратить только одно значение, которое может быть кортежем. В следующем примере видно, как стандартная функция divmod() возвращает частное и остаток от деления двух чисел: </p><p>def bin(n): </p><p>    &quot;&quot;&quot;Цифры двоичного представления натурального числа &quot;&quot;&quot;     digits = []     while n &gt; 0: </p><p>        n, d = divmod(n, 2)         digits = [d] + digits     return digits </p><p> print bin(69) </p><p><strong>Рекурсия </strong></p><p>В некоторых случаях описание функции элегантнее всего выглядит с применением вызова этой же функции. Такой прием, когда функция вызывает саму себя, называется <strong>рекурсией</strong>. В функциональных языках рекурсия обычно используется много чаще, чем итерация (циклы). </p><p>В следующем примере переписывается функция bin() в рекурсивном варианте: </p><p>def bin(n): </p><p>    &quot;&quot;&quot;Цифры двоичного представления натурального числа &quot;&quot;&quot;     if n == 0:       return []     n, d = divmod(n, 2)     return bin(n) + [d] </p><p> </p><p>print bin(69) </p><p>Здесь видно, что цикл while больше не используется, а вместо него появилось условие окончания рекурсии: условие, при выполнении которого функция не вызывает себя. </p><p>Конечно, в погоне за красивым рекурсивным решением не следует упускать из виду эффективность реализации. В частности, пример реализации функции для вычисления n -го числа Фибоначчи это демонстрирует: </p><p>def Fib(n):    if n &lt; 2:         return n     else: </p><p>       return Fib(n-1) + Fib(n-2) </p><p> </p><p><strong>Функция apply() </strong></p><p>Функция apply() применяет функцию, переданную в качестве первого аргумента, к параметрам, которые переданы вторым и третьим аргументом. Эта функция в Python устарела, так как вызвать функцию можно с помощью обычного синтаксиса вызова функции. Позиционные и именованные параметры можно передать с использованием звездочек: </p><p>&gt;&gt;&gt; lst = [1, 2, 3] </p><p>&gt;&gt;&gt; dct = {'a': 4, 'b': 5} </p><p>&gt;&gt;&gt; apply(max, lst) </p><p>3 </p><p>&gt;&gt;&gt; max(*lst) </p><p>3 </p><p>&gt;&gt;&gt; apply(dict, [], dct) </p><p>{'a': 4, 'b': 5} </p><p>&gt;&gt;&gt; dict(**dct) </p><p>{'a': 4, 'b': 5} </p><p>Вопросы:</p><ol><li>Абстракции </li><li>Функциональное программирование</li><li>Функция: определение и вызов</li><li>Рекурсия</li><li>Функция apply()</li></ol><h1><a id="_Toc454873518"></a><a id="_Toc454109362"></a>Лекция 9. Обработка массива.</h1><p>План:</p><ol><li>Обработка последовательностей </li><li>Функции range() и xrange()</li><li>Функция map()</li><li>Функция filter()</li><li>Списковые включения</li><li>Функция sum()</li><li>Функция reduce()</li></ol><p><strong>Обработка последовательностей </strong></p><p>Многие алгоритмы сводятся к обработке массивов данных и получению новых массивов данных в результате. Среди встроенных функций Python есть несколько для работы с последовательностями. </p><p>Под <strong>последовательностью</strong> в Python понимается любой тип данных, который поддерживает интерфейс последовательности (это несколько специальных методов, реализующих операции над последовательностями, которые в данном курсе обсуждаться не будут). </p><p>Следует заметить, что тип, основной задачей которого является хранение, манипулирование и обеспечение доступа к самостоятельным данным называется <strong>контейнерным типом</strong> или просто <strong>контейнером</strong>. Примеры контейнеров в Python - списки, кортежи, словари. </p><p><strong>Функции range() и xrange() </strong></p><p>Функция range() уже упоминалась при рассмотрении цикла for. Эта функция принимает от одного до трех аргументов. Если аргумент всего один, она генерирует список чисел от 0 (включительно) до заданного числа (исключительно). Если аргументов два, то список начинается с числа, указанного первым аргументом. Если аргументов три - третий аргумент задает шаг </p><p>&gt;&gt;&gt; print range(10) </p><p>[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] </p><p>&gt;&gt;&gt; print range(1, 10) </p><p>[1, 2, 3, 4, 5, 6, 7, 8, 9] &gt;&gt;&gt; print range(1, 10, 3) </p><p>[1, 4, 7] </p><p>Функция xrange() - аналог range(), более предпочтительный для использования при последовательном доступе, например, в цикле for или с итераторами. Она возвращает специальный xrange -объект, который ведет себя почти как список, порождаемый range(), но не хранит в памяти все выдаваемые элементы. </p><p><strong>Функция map() </strong></p><p>Для применения некоторой функции ко всем элементам последовательности применяется функция map(f, *args). Первый параметр этой функции - функция, которая будет применяться ко всем элементам последовательности. Каждый следующий n+1 -й параметр должен быть последовательностью, так как каждый его элемент будет использован в качестве n -го параметра при вызове функции f(). Результатом будет список, составленный из результатов выполнения этой функции. </p><p>В следующем примере складываются значения из двух списков: </p><p>&gt;&gt;&gt; l1 = [2, 7, 5, 3] </p><p>&gt;&gt;&gt; l2 = [-2, 1, 0, 4] </p><p>&gt;&gt;&gt; print map(lambda x, y: x+y, l1, l2) </p><p>[0, 8, 5, 7] </p><p>В этом примере применена безымянная функция для получения суммы двух операндов ко всем элементам l1 и l2. В случае если одна из последовательностей короче другой, вместо соответствующего операнда будет None, что, конечно, собьет операцию сложения. В зависимости от решаемой задачи, можно либо видоизменить функцию, либо считать разные по длине последовательности ошибкой, которую нужно обрабатывать как отдельную ветвь алгоритма. </p><p>Частный случай применения map() - использование None в качестве первого аргумента. В этом случае просто формируется список кортежей из элементов исходных последовательностей: </p><p>&gt;&gt;&gt; l1 = [2, 7, 5, 3] </p><p>&gt;&gt;&gt; l2 = [-2, 1, 0, 4] </p><p>&gt;&gt;&gt; print map(None, l1, l2) </p><p>[(2, -2), (7, 1), (5, 0), (3, 4)] </p><p><strong>Функция filter() </strong></p><p>Другой часто встречающейся операцией является фильтрование исходной последовательности в соответствии с некоторым предикатом (условием). Функция filter(f, seq) принимает два аргумента: функцию с условием и последовательность, из которой берутся значения. В результирующую последовательность попадут только те значения из исходной, для которой f() возвратит истину. Если в качестве f задано значение None, результирующая последовательность будет состоять из тех значений исходной, которые имеют истинностное значение True. </p><p>Например, в следующем фрагменте кода можно избавится от символов, которые не являются буквами: </p><p>&gt;&gt;&gt; filter(lambda x: x.isalpha(), 'Hi, there! I am eating an apple.') 'HithereIameatinganapple' </p><p><strong>Списковые включения </strong></p><p>Для более естественной записи обработки списков в Python 2 была внесена новинка: списковые включения. Фактически это специальный сокращенный синтаксис для вложенных циклов for и условий if, на самом низком уровне которых определенное выражение добавляется к списку, например: </p><p>all_pairs = [] for i in range(5):   for j in range(5): </p><p>    if i &lt;= j: </p><p>      all_pairs.append((i, j)) </p><p>Все это можно записать в виде спискового включения так: </p><p>all_pairs = [(i, j) for i in range(5) for j in range(5) if i &lt;= j] </p><p>Как легко заметить, списковые включения позволяют заменить map() и filter() на более удобные для прочтения конструкции. </p><p>В следующей таблице приведены эквивалентные выражения в разных формах: </p><table><tr><td><p><strong>В форме функции </strong></p></td><td><p><strong>В форме спискового включения</strong></p></td></tr><tr><td><p>filter(f, lst) </p></td><td><p>[x for x in lst if f(x)] </p></td></tr><tr><td><p>filter(None, lst) </p></td><td><p>[x for x in lst if x] </p></td></tr><tr><td><p>map(f, lst) </p></td><td><p>[f(x) for x in lst] </p></td></tr></table><p><strong> </strong></p><p><strong>Функция sum() </strong></p><p>Получить сумму элементов можно с помощью функции sum(): </p><p>&gt;&gt;&gt; sum(range(10)) </p><p>45 </p><p>Эта функция работает только для числовых типов, она не может конкатенировать строки. Для конкатенации списка строк следует использовать метод join(). </p><p><strong>Функция reduce() </strong></p><p>Для организации цепочечных вычислений (вычислений с накоплением результата) можно применять функцию reduce(), которая принимает три аргумента: функцию двух аргументов, последовательность и начальное значение. С помощью этой функции можно, в частности, реализовать функцию sum(): </p><p>def sum(lst, start):   return reduce(lambda x, y: x + y, lst, start) </p><p>В следующем примере накапливаются промежуточные результаты суммирования: </p><p>lst = range(10) </p><p>f = lambda x, y: (x[0] + y, x[1]+[x[0] + y]) </p><p>print reduce(f, lst, (0, [])) В итоге получается: </p><p>(45, [0, 1, 3, 6, 10, 15, 21, 28, 36, 45]) </p><p> Вопросы:</p><ol><li>Обработка последовательностей </li><li>Функции range() и xrange()</li><li>Функция map()</li><li>Функция filter()</li><li>Списковые включения</li><li>Функция sum()</li><li>Функция reduce()</li></ol><h1><a id="_Toc454873519"></a><a id="_Toc454109363"></a>Лекция 10. Расчет суммы или количества элементов одномерного массива.</h1><p>План:</p><ol><li>объект </li><li>класс</li><li>Абстракция и декомпозиция</li></ol><p>Python проектировался как объектно-ориентированный язык программирования. Это означает, что он построен с учетом следующих принципов: </p><ol><li>Все данные в нем представляются объектами.  </li><li>Программу можно составить как набор взаимодействующих объектов, посылающих друг другу сообщения.  </li><li>Каждый объект имеет собственную часть памяти и может состоять из других объектов.  </li><li>Каждый объект имеет тип.  </li><li>Все объекты одного типа могут принимать одни и те же сообщения (и выполнять одни и те же действия). </li></ol><p><strong>Основные понятия </strong></p><p>При процедурном программировании программа разбивается на части в соответствии с алгоритмом: каждая часть ( <strong>подпрограмма</strong>, <strong>функция</strong>, <strong>процедура</strong> ) является составной частью алгоритма. </p><p>При объектно-ориентированном программировании программа строится как совокупность взаимодействующих объектов. </p><p>С точки зрения объектно-ориентированного подхода, <strong>объект</strong> - это нечто, обладающее <strong>значением (состоянием)</strong>, <strong>типом (поведением)</strong> и <strong>индивидуальностью</strong>. Когда программист выделяет объекты в предметной области, он обычно абстрагируется (отвлекается) от большинства их свойств, концентрируясь на существенных для задачи свойствах. Над объектами можно производить <strong>операции</strong> (посылая им сообщения). В языке Python все данные представлены в виде объектов. </p><p>Взаимодействие объектов заключается в вызове <strong>методов</strong> одних объектов другими. Иногда говорят, что объекты посылают друг другу <strong>сообщения</strong>. Сообщения - это запросы к объекту выполнить некоторые действия. (<strong>Сообщения</strong>, <strong>методы</strong>, <strong>операции</strong>, <strong>функции-члены</strong> являются синонимами). </p><p>Каждый объект хранит свое <strong>состояние</strong> (для этого у него есть <strong>атрибуты</strong> ) и имеет определенный набор <strong>методов</strong>. (Синонимы: атрибут, <strong>поле</strong>, <strong>слот</strong>, <strong>объект-член</strong>, <strong>переменная экземпляра</strong>). Методы определяют <strong>поведение</strong> объекта. Объекты класса имеют общее поведение. </p><p>Объекты описываются не индивидуально, а с помощью <strong>классов</strong>. <strong>Класс</strong> - объект, являющийся шаблоном объекта. Объект, созданный на основе некоторого класса, называется <strong>экземпляром класса</strong>. Все объекты определенных пользователем классов являются экземплярами класса. Тем не менее, объекты даже с одним и тем же состоянием могут быть разными объектами. Говорят, что они имеют разную <strong>индивидуальность</strong>. </p><p>В языке Python для определения класса используется оператор class: </p><p>class имя_класса(класс1, класс2, ...): </p><p>  # определения методов </p><p> Класс определяет <strong>тип</strong> объекта, то есть его возможные состояния и набор операций. </p><p><strong>Абстракция и декомпозиция </strong></p><p><strong>Абстракция</strong> в ООП позволяет составить из данных и алгоритмов обработки этих данных объекты, отвлекаясь от несущественных (на некотором уровне) с точки зрения составленной информационной модели деталей. Таким образом, программа подвергается <strong>декомпозиции</strong> на части &quot;дозированной&quot; сложности. Отдельный объект, даже вместе с совокупностью его связей с другими объектами, человеком воспринимается легче (именно так он привык оперировать в реальном мире), чем чтото неструктурированное и монотонное. </p><p>Перед тем как начать написание даже самой простенькой объектноориентированной программы, необходимо провести анализ предметной области, для того чтобы выявить в ней классы объектов. </p><p>При выделении объектов необходимо абстрагироваться (отвлечься) от большинства присущих им свойств и сконцентрироваться на свойствах, значимых для задачи. </p><p>Выделяемые объекты необязательно должны походить на физические объекты - ведь это абстракции, за которыми скрываются процессы, взаимодействия, отношения. </p><p>Удачная декомпозиция стоит многого. От нее зависят не только количественные характеристики кода (быстродействие, занимаемая память), но и трудоемкость дальнейшего развития и сопровождения. При отсутствии соответствующего опыта лучше не загадывать будущих путей развития программы, а делать ее как можно проще, под конкретную задачу. </p><p>Даже если просто перечислить все существительные, встретившиеся в описании задачи (явно или неявно), получится неплохой список кандидатов в классы. </p><p>При процедурном подходе тоже используется декомпозиция, но при объектноориентированном подходе производится декомпозиция не самого алгоритма на более мелкие части, а предметной области на классы объектов. </p><p> Вопросы:</p><ol><li>объект </li><li>класс</li><li>Абстракция и декомпозиция</li></ol><h1><a id="_Toc454873520"></a><a id="_Toc454109364"></a>Лекция 11. Нахождение максимума и минимума среди элементов двумерного массива</h1><p>План:</p><ol><li>Наследование </li><li>Множественное наследование </li><li>Порядок разрешения методов</li><li>Контейнеры</li><li>Итераторы</li></ol><p><strong>Наследование </strong></p><p>На практике часто возникает ситуация, когда в предметной области выделены очень близкие, но вместе с тем неодинаковые классы. Одним из способов сокращения описания классов за счет использования их сходства является выстраивание классов в <strong>иерархию</strong>. В корне этой иерархии стоит базовый класс, от которого нижележащие классы иерархии <strong>наследуют</strong> свои атрибуты, уточняя и расширяя поведение вышележащего класса. Обычно принципом построения классификации является отношение &quot;IS-A&quot; (&quot;ЕСТЬ&quot;). Например, класс Окружность в программе - графическом редакторе может быть унаследован от класса Геометрическая Фигура. При этом </p><p>Окружность будет являться <strong>подклассом</strong> (или субклассом) для класса Геометрическая Фигура, а Геометрическая Фигура - <strong>надклассом</strong> (или суперклассом) для класса Окружность. </p><p>В языке Python во главе иерархии (&quot;новых&quot;) классов стоит класс object. Для ориентации в иерархии существуют некоторые встроенные функции, которые будут рассмотрены ниже. Функция issubclass(x, y) может сказать, является ли класс x подклассом класса y: </p><p>&gt;&gt;&gt; class A(object): pass </p><p>... </p><p>&gt;&gt;&gt; class B(A): pass </p><p>... </p><p>&gt;&gt;&gt; issubclass(A, object) </p><p>True </p><p>&gt;&gt;&gt; issubclass(B, A) </p><p>True </p><p>&gt;&gt;&gt; issubclass(B, object) </p><p>True </p><p>&gt;&gt;&gt; issubclass(A, str) </p><p>False </p><p>&gt;&gt;&gt; issubclass(A, A)  # класс является подклассом самого себя True </p><p>В основе построения классификации всегда стоит принцип, играющий наиболее важную роль в анализируемой и моделируемой системе. Следует заметить, что одним из &quot;перегибов&quot; при использовании ОО методологии является искусственное выстраивание иерархии классов. Например, не стоит наследовать класс Машина от класса Колесо (внимательные заметят, что здесь отношение другое: колесо является частью машины). </p><p>Класс 	называется 	<strong>абстрактным</strong>, 	если 	он 	предназначен 	только 	для наследования. Экземпляры абстрактного класса обычно не имеют большого смысла. Классы с рабочими экземплярами называются <strong>конкретными</strong>. </p><p>В Python примером абстрактного класса является встроенный тип basestring, у которого есть конкретные подклассы str и unicode. </p><p><strong>Множественное наследование </strong></p><p>В отличие, например, от Java, в языке Python можно наследовать класс от нескольких классов. Такая ситуация называется <strong>множественным наследованием</strong> </p><p>(multiple inheritance). </p><p>Класс, получаемый при множественном наследовании, объединяет поведение своих надклассов, комбинируя стоящие за ними абстракции. </p><p>Использовать множественное наследование следует очень осторожно, а необходимость в нем возникает реже одиночного. </p><ul><li>Множественное наследование можно применить для получения класса с заданными общедоступными методами, причем методы задает один родительский класс, а реализуются они на основе методов второго класса. </li></ul><p>Первый класс может быть полностью абстрактным.  </p><ul><li>Множественное наследование применяется для добавления <strong>примесей</strong> (mixins). Примесь - специально сконструированный класс, добавляющий в некоторый класс какую-либо черту поведения (привнесением атрибутов). Примеси обычно являются абстрактными классами.  </li><li>Изредка множественное наследование применяется в своем основном смысле, когда объекты класса, получающегося в результате множественного наследования, предназначаются для использования в качестве объектов всех родительских классов. </li></ul><p>В случае с Python наследование можно считать одним из способов собрать нужные комбинации методов в серии классов: </p><p>class A:  </p><p>  def a(self): return 'a' class B:  </p><p>  def b(self): return 'b'   class C:  </p><p>  def c(self): return 'c'   </p><p> class AB(A, B):  </p><p>  pass class BC(B, C):  </p><p>  pass class ABC(A, B, C):  </p><p>  pass </p><p>Впрочем, собрать нужные методы можно и по-другому, без использования наследования: </p><p>def ma(self): return 'a' def mb(self): return 'b'   def mc(self): return 'c'   </p><p> class AB:    a = ma   b = mb  class BC:    b = mb   c = mc  class ABC:    a = ma   b = mb   c = mc  	<strong> </strong></p><p><strong>Порядок разрешения методов </strong></p><p>В случае, когда надклассы имеют одинаковые методы, использование того или иного метода определяется <strong>порядком разрешения методов</strong> (method resolution order). Для &quot;новых&quot; классов узнать этот порядок очень просто с помощью атрибута __mro__: </p><p>&gt;&gt;&gt; str.__mro__ </p><p>(&lt;type 'str'&gt;, &lt;type 'basestring'&gt;, &lt;type 'object'&gt;) </p><p>Это означает, что сначала методы ищутся в классе str, затем в basestring, а уже потом - в object. </p><p>Для &quot;классических&quot; классов порядок несколько отличается от порядка разрешения методов в &quot;новых&quot; классах. Нужно стараться избегать множественного наследования или применять его очень аккуратно. </p><p><strong>Контейнеры </strong></p><p>Под <strong>контейнером</strong> обычно понимают объект, основным назначением которого является хранение и обеспечение доступа к другим объектам. Контейнеры реализуют отношение &quot;HAS-A&quot; (&quot;ИМЕЕТ&quot;) между объектами. Встроенные типы, список и словарь -- яркие примеры контейнеров. Можно построить собственные типы контейнеров, которые будут иметь свою логику доступа к хранимым объектам. В контейнере хранятся не сами объекты, а ссылки на них. </p><p>Для практических нужд в Python обычно хватает встроенных контейнеров (словаря и списка), но если это необходимо, можно создать и другие. Ниже приведен класс Стек, реализованный на базе списка: </p><p>class Stack:   def __init__(self):     &quot;&quot;&quot;Инициализация стека&quot;&quot;&quot;     self._stack = []   def top(self): </p><p>    &quot;&quot;&quot;Возвратить вершину стека (не снимая)&quot;&quot;&quot;     return self._stack[-1]   def pop(self): </p><p>    &quot;&quot;&quot;Снять со стека элемент&quot;&quot;&quot;     return self._stack.pop()   def push(self, x): </p><p>    &quot;&quot;&quot;Поместить элемент на стек&quot;&quot;&quot;     self._stack.append(x)   def __len__(self): </p><p>    &quot;&quot;&quot;Количество элементов в стеке&quot;&quot;&quot;     return len(self._stack)   def __str__(self): </p><p>    &quot;&quot;&quot;Представление в виде строки&quot;&quot;&quot; </p><p>    return &quot; : &quot;.join([&quot;%s&quot; % e for e in self._stack]) Использование: </p><p>&gt;&gt;&gt; s = Stack() </p><p>&gt;&gt;&gt; s.push(1) </p><p>&gt;&gt;&gt; s.push(2) </p><p>&gt;&gt;&gt; s.push(&quot;abc&quot;) &gt;&gt;&gt; print s.pop() abc </p><p>&gt;&gt;&gt; print len(s) </p><p>2 </p><p>&gt;&gt;&gt; print s </p><p>1 : 2 </p><p>Таким образом, контейнеры позволяют управлять набором (любых) других объектов в соответствии со структурой их хранения, не вмешиваясь во внутренние дела объектов. Узнав интерфейс класса Stack, можно и не догадаться, что он реализован на основе списка, и каким именно образом он реализован с помощью него. Но для использования стека это не важно. </p><p><strong>Итераторы </strong></p><p><strong>Итераторы</strong> - это объекты, которые предоставляют последовательный доступ к элементам контейнера (или генерируемым &quot;на лету&quot; объектам). Итератор позволяет перебирать элементы, абстрагируясь от реализации того контейнера, откуда он их берет (если этот контейнер вообще есть). </p><p>В следующем примере приведен итератор, выдающий значения из списка по принципу &quot;считалочки&quot; по N: </p><p>class Zahlreim:   def __init__(self, lst, n): </p><p>    self.n = n     self.lst = lst     self.current = 0   def __iter__(self):  </p><p>    return self   def next(self):     if self.lst: </p><p>      self.current = (self.current + self.n - 1) % len(self.lst)        return self.lst.pop(self.current)     else:  </p><p>      raise StopIteration </p><p> print range(1, 11) for i in Zahlreim(range(1, 11), 5): </p><p>  print i, Программа выдаст </p><p>[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] </p><p>5 10 6 2 9 8 1 4 7 3 </p><p>В этой программе делегировано управление доступом к элементам списка (или любого другого контейнера, имеющего метод pop(n) для взятия и удаления n -го элемента) классу-итератору. Итератор должен иметь метод next() и возбуждать исключение StopIteration по завершении итераций. Кроме того, метод __iter__() должен выдавать итератор по экземпляру класса (в данном случае итератор - он сам ( self )). </p><p>В настоящее время итераторы приобретают все большее значение, и о них много говорилось в лекции по функциональному программированию. </p><p> Вопросы:</p><ol><li>Наследование </li><li>Множественное наследование </li><li>Порядок разрешения методов</li><li>Контейнеры</li><li>Итераторы</li></ol><p>	<strong> </strong></p><p> </p><h1><a id="_Toc454873521"></a><a id="_Toc454109365"></a>Тема 2.2  Строки  </h1><h1><a id="_Toc454873522"></a><a id="_Toc454109366"></a>Лекция 12. Символьный и строковый типы.</h1><p>План:</p><ol><li>Numeric Python </li><li>Создание массива </li><li>Методы массивов</li><li>Срезы</li></ol><p><strong>Numeric Python</strong> - это несколько модулей для вычислений с многомерными массивами, необходимых для многих численных приложений. Модуль Numeric вносит в Python возможности таких пакетов и систем как MatLab, Octave (аналог MatLab), APL, J, S+, IDL. Пользователи найдут Numeric достаточно простым и удобным. Стоит заметить, что некоторые синтаксические возможности Python (связанные с использованием срезов) были специально разработаны для Numeric. </p><p>Numeric Python имеет средства для: </p><ul><li>матричных вычислений LinearAlgebra ;  </li><li>быстрого преобразования Фурье FFT ;  </li><li>работы с недостающими экспериментальными данными MA ;  </li><li>статистического моделирования RNG ;  </li><li>эмуляции базовых функций программы MatLab. </li></ul><p><strong>Модуль Numeric </strong></p><p>Модуль Numeric определяет полноценный тип-массив и содержит большое число функций для операций с массивами. <strong>Массив</strong> - это набор однородных элементов, доступных по индексам. Массивы модуля Numeric могут быть многомерными, то есть иметь более одной <strong>размерности</strong>. </p><p><strong>Создание массива </strong></p><p>Для создания массива можно использовать функцию array() с указанием содержимого массива (в виде вложенных списков) и типа. Функция array() делает копию, если ее аргумент - массив. Функция asarray() работает аналогично, но не создает нового массива, когда ее аргумент уже является массивом: </p><p>&gt;&gt;&gt; from Numeric import * </p><p>&gt;&gt;&gt; print array([[1, 2], [3, 4], [5, 6]]) </p><p>[[1 2] </p><p> [3 4] </p><p> [5 6]] </p><p>&gt;&gt;&gt; print array([[1, 2, 3], [4, 5, 6]], float) </p><p>[[ 1.  2.  3.] </p><p> [ 4.  5.  6.]] </p><p>&gt;&gt;&gt; print array([78, 85, 77, 69, 82, 73, 67], 'c') </p><p>[N U M E R I C] </p><p>В качестве элементов массива можно использовать следующие типы: Int8-</p><p>Int32, UnsignedInt8-UnsignedInt32, Float8-Float64, Complex8-Complex64 и PyObject. </p><p>Числа 8, 16, 32 и 64 показывают количество битов для хранения величины. Типы Int, UnsignedInteger, Float и Complex соответствуют наибольшим принятым на данной платформе значениям. В массиве можно также хранить ссылки на произвольные объекты. </p><p>Количество размерностей и длина массива по каждой оси называются формой массива (shape). Доступ к форме массива реализуется через атрибут shape: </p><p>&gt;&gt;&gt; from Numeric import * </p><p>&gt;&gt;&gt; a = array(range(15), int) </p><p>&gt;&gt;&gt; print a.shape </p><p>(15,) </p><p>&gt;&gt;&gt; print a </p><p>[ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14] </p><p>&gt;&gt;&gt; a.shape = (3, 5) </p><p>&gt;&gt;&gt; print a.shape </p><p>(3, 5) </p><p>&gt;&gt;&gt; print a </p><p>[[ 0  1  2  3  4] </p><p> [ 5  6  7  8  9] </p><p> [10 11 12 13 14]] </p><p><strong>Методы массивов </strong></p><p>Придать нужную форму массиву можно функцией Numeric.reshape(). Эта функция сразу создает объект-массив нужной формы из последовательности. </p><p>&gt;&gt;&gt; import Numeric </p><p>&gt;&gt;&gt; print Numeric.reshape(&quot;абракадабр&quot;, (5, -1)) </p><p>[[а б] </p><p> [р а] </p><p> [к а] </p><p> [д а] </p><p> [б р]] </p><p>В этом примере -1 в указании формы говорит о том, что соответствующее значение можно вычислить. Общее количество элементов массива известно (10), поэтому длину вдоль одной из размерностей задавать не обязательно. </p><p>Через атрибут flat можно получить одномерное представление массива: </p><p>&gt;&gt;&gt; a = array([[1, 2], [3, 4]]) </p><p>&gt;&gt;&gt; b = a.flat &gt;&gt;&gt; b </p><p>array([1, 2, 3, 4]) </p><p>&gt;&gt;&gt; b[0] = 9 &gt;&gt;&gt; b </p><p>array([9, 2, 3, 4]) </p><p>&gt;&gt;&gt; a array([[9, 2],        [3, 4]]) </p><p>Следует заметить, что это новый вид того же массива, поэтому присваивание значений его элементам приводит к изменениям в исходном массиве. </p><p>Функция Numeric.resize() похожа на Numeric.reshape, но может подстраивать число элементов: </p><p>&gt;&gt;&gt; print Numeric.resize(&quot;NUMERIC&quot;, (3, 2)) </p><p>[[N U] </p><p> [M E] </p><p> [R I]] </p><p>&gt;&gt;&gt; print Numeric.resize(&quot;NUMERIC&quot;, (3, 4)) </p><p>[[N U M E] </p><p> [R I C N] </p><p> [U M E R]] </p><p>Функция Numeric.zeros() порождает массив из одних нулей, а Numeric.ones() - из одних единиц. Единичную матрицу можно получить с помощью функции Numeric.identity(n): </p><p>&gt;&gt;&gt; print Numeric.zeros((2,3)) </p><p>[[0 0 0] </p><ol><li>0 0]] </li></ol><p>&gt;&gt;&gt; print Numeric.ones((2,3)) </p><p>[[1 1 1] </p><ol><li>1 1]] </li></ol><p>&gt;&gt;&gt; print Numeric.identity(4) </p><p>[[1 0 0 0] </p><p> [0 1 0 0] </p><p> [0 0 1 0] </p><p> [0 0 0 1]] </p><p>Для копирования массивов можно использовать метод copy(): </p><p>&gt;&gt;&gt; import Numeric </p><p>&gt;&gt;&gt; a = Numeric.arrayrange(9) </p><p>&gt;&gt;&gt; a.shape = (3, 3) </p><p>&gt;&gt;&gt; print a </p><p>[[0 1 2] </p><p> [3 4 5] </p><p> [6 7 8]] </p><p>&gt;&gt;&gt; a1 = a.copy() </p><p>&gt;&gt;&gt; a1[0, 1] = -1   # операция над копией </p><p>&gt;&gt;&gt; print a1 </p><p>[[0 1 2] </p><p> [3 4 5] </p><p> [6 7 8]] </p><p>Массив можно превратить обратно в список с помощью метода tolist(): </p><p>&gt;&gt;&gt; a.tolist() </p><p>[[0, 1, 2], [3, 4, 5], [6, 7, 8]] </p><p><strong>Срезы </strong></p><p>Объекты-массивы Numeric используют расширенный синтаксис выделения среза. Следующие примеры иллюстрируют различные варианты записи срезов. Функция Numeric.arrayrange() является аналогом range() для массивов. </p><p>&gt;&gt;&gt; import Numeric </p><p>&gt;&gt;&gt; a = Numeric.arrayrange(24) + 1 </p><p>&gt;&gt;&gt; a.shape = (4, 6) </p><p>&gt;&gt;&gt; print a             # исходный массив </p><p>[[ 1  2  3  4  5  6] </p><p> [ 7  8  9 10 11 12] </p><p> [13 14 15 16 17 18] </p><p> [19 20 21 22 23 24]] </p><p>&gt;&gt;&gt; print a[1,2]        # элемент 1,2 </p><p>9 </p><p>&gt;&gt;&gt; print a[1,:]        # строка 1 </p><p>[ 7  8  9 10 11 12] </p><p>&gt;&gt;&gt; print a[1]          # тоже строка 1 </p><p>[ 7  8  9 10 11 12] </p><p>&gt;&gt;&gt; print a[:,1]        # столбец 1 </p><p>[ 2  8 14 20] </p><p>&gt;&gt;&gt; print a[-2,:]       # предпоследняя строка </p><p>[13 14 15 16 17 18] </p><p>&gt;&gt;&gt; print a[0:2,1:3]    # окно 2x2 </p><p>[[2 3] </p><p> [8 9]] </p><p>&gt;&gt;&gt; print a[1,::3]      # каждый третий элемент строки 1 [ 7 10] </p><p>&gt;&gt;&gt; print a[:,::-1]     # элементы строк в обратном порядке </p><p>[[ 6  5  4  3  2  1] </p><p> [12 11 10  9  8  7] </p><p> [18 17 16 15 14 13] </p><p> [24 23 22 21 20 19]] </p><p>Срез не копирует массив (как это имеет место со списками), а дает доступ к некоторой части массива. Далее в примере меняется на 0 каждый третий элемент строки 1: </p><p>&gt;&gt;&gt; a[1,::3] = Numeric.array([0,0]) </p><p>&gt;&gt;&gt; print a </p><p>[[ 1  2  3  4  5  6] </p><p> [ 0  8  9  0 11 12] </p><p> [13 14 15 16 17 18] </p><p> [19 20 21 22 23 24]] </p><p>В следующих примерах находит применение достаточно редкая синтаксическая конструкция: срез с многоточием ( Ellipsis ). Многоточие ставится для указания произвольного числа пропущенных размерностей ( :,:,...,:): </p><p>&gt;&gt;&gt; import Numeric </p><p>&gt;&gt;&gt; a = Numeric.arrayrange(24) + 1 </p><p>&gt;&gt;&gt; a.shape = (2,2,2,3) </p><p>&gt;&gt;&gt; print a </p><p>[[[[ 1  2  3] </p><p>   [ 4  5  6]] </p><p>  [[ 7  8  9] </p><p>   [10 11 12]]] </p><p> [[[13 14 15] </p><p>   [16 17 18]] </p><p>  [[19 20 21] </p><p>   [22 23 24]]]] </p><p>&gt;&gt;&gt; print a[0,...]          # 0-й блок </p><p>[[[ 1  2  3] </p><p>  [ 4  5  6]] </p><p> [[ 7  8  9] </p><p>  [10 11 12]]] </p><p>&gt;&gt;&gt; print a[0,:,:,0]        # срез по первой и последней размерностям </p><p>[[ 1  4] </p><p> [ 7 10]] </p><p>&gt;&gt;&gt; print a[0,...,0]        # то же, но с использованием многоточия [[ 1  4] </p><p> [ 7 10]] </p><p>Вопросы:</p><ol><li>Numeric Python </li><li>Создание массива </li><li>Методы массивов</li><li>Срезы</li></ol><h1><a id="_Toc454873523"></a><a id="_Toc454109367"></a>Лекция 13. Стандартные функции и процедуры для работы со строками</h1><p>План:</p><ol><li>Функция Numeric.take() </li><li>Функции Numeric.diagonal() и Numeric.trace()  </li><li>Функция Numeric.choose()</li><li>Свод функций модуля Numeric</li></ol><p><strong>Функция Numeric.take() </strong></p><p>Функция Numeric.take() позволяет взять часть массива по заданным на определенном измерении индексам. По умолчанию номер измерения (третий аргумент) равен нулю. </p><p>&gt;&gt;&gt; import Numeric </p><p>&gt;&gt;&gt; a = Numeric.reshape(Numeric.arrayrange(25), (5, 5)) </p><p>&gt;&gt;&gt; print a </p><p>[[ 0  1  2  3  4] </p><p> [ 5  6  7  8  9] </p><p> [10 11 12 13 14] </p><p> [15 16 17 18 19] </p><p> [20 21 22 23 24]] </p><p>&gt;&gt;&gt; print Numeric.take(a, [1], 0) </p><p>[ [5 6 7 8 9]] </p><p>&gt;&gt;&gt; print Numeric.take(a, [1], 1) </p><p>[[ 1] </p><p> [ 6] </p><p> [11] </p><p> [16] </p><p> [21]] </p><p>&gt;&gt;&gt; print Numeric.take(a, [[1,2],[3,4]]) </p><p>[[[ 5  6  7  8  9] </p><p>  [10 11 12 13 14]] </p><p> [[15 16 17 18 19] </p><p>  [20 21 22 23 24]]] </p><p>В отличие от среза, функция Numeric.take() сохраняет размерность массива, если конечно, структура заданных индексов одномерна. Результат Numeric.take(a, [[1,2],[3,4]]) показывает, что взятые по индексам части помещаются в массив со структурой самих индексов, как если бы вместо 1 было написано [5 6 7 8 9], а вместо 2 - [10 11 12 13 14] и т.д. </p><p><strong>Функции Numeric.diagonal() и Numeric.trace() </strong></p><p>Функция Numeric.diagonal() возвращает диагональ матрицы. Она имеет следующие аргументы: </p><table><tr><td><p>a </p></td><td><p>Исходный массив. </p></td></tr><tr><td><p>offset </p></td><td><p>Смещение вправо от &quot;главной&quot; диагонали (по умолчанию 0). </p></td></tr><tr><td><p>axis1 </p></td><td><p>Первое из измерений, на которых берется диагональ (по умолчанию 0). </p></td></tr><tr><td><p>axis2  </p></td><td><p>Второе измерение, образующее вместе с первым плоскость, на которой и берется диагональ. По умолчанию axis2=1. </p></td></tr></table><p>Функция Numeric.trace() (для вычисления следа матрицы ) имеет те же аргументы, но суммирует элементы на диагонали. В примере ниже рассмотрены обе эти функции: </p><p>&gt;&gt;&gt; import Numeric </p><p>&gt;&gt;&gt; a = Numeric.reshape(Numeric.arrayrange(16), (4, 4)) &gt;&gt;&gt; print a </p><p>[[ 0  1  2  3] </p><p> [ 4  5  6  7] </p><p> [ 8  9 10 11] </p><p> [12 13 14 15]] </p><p>&gt;&gt;&gt; for i in range(-3, 4): </p><p>...   print &quot;Sum&quot;, Numeric.diagonal(a, i), &quot;=&quot;, Numeric.trace(a, i) </p><p>... </p><p>Sum [12] = 12 </p><p>Sum [ 8 13] = 21 </p><p>Sum [ 4  9 14] = 27 </p><p>Sum [ 0  5 10 15] = 30 </p><p>Sum [ 1  6 11] = 18 </p><p>Sum [2 7] = 9 </p><p>Sum [3] = 3 </p><p><strong>Функция Numeric.choose() </strong></p><p>Эта функция использует один массив с целыми числами от 0 до n для выбора значения из одного из заданных массивов: </p><p>&gt;&gt;&gt; a = Numeric.identity(4) </p><p>&gt;&gt;&gt; b0 = Numeric.reshape(Numeric.arrayrange(16), (4, 4)) &gt;&gt;&gt; b1 = -Numeric.reshape(Numeric.arrayrange(16), (4, 4)) </p><p>&gt;&gt;&gt; print Numeric.choose(a, (b0, b1)) </p><p>[[  0   1   2   3] </p><p> [  4  -5   6   7] </p><p> [  8   9 -10  11] </p><p> [ 12  13  14 -15]] </p><p><strong>Свод функций модуля Numeric </strong></p><p>Следующая таблица приводит описания функций модуля Numeric. </p><table><tr><td><p><strong>Функция и ее аргументы </strong></p></td><td><p><strong>Назначение функции </strong></p></td></tr><tr><td><p>allclose(a, b[, eps[,</p><p>A]]) </p></td><td><p> Сравнение a и b с заданными относительными eps и абсолютными A погрешностями. По умолчанию eps равен 1.0e1, а A = 1.0e-8. </p></td></tr><tr><td><p>alltrue(a[, axis]) </p></td><td><p>Логическое И по всей оси axis массива a </p></td></tr><tr><td><p>argmax(a[, axis]) </p></td><td><p>Индекс максимального значения в массиве по заданному измерению axis </p></td></tr><tr><td><p>argmin(a[, axis]) </p></td><td><p>Индекс минимального значения в массиве по заданному измерению axis </p></td></tr><tr><td><p>argsort(a[, axis]) </p></td><td><p>Индексы отсортированного массива, такие, что take(a,argsort(a, axis),axis) дает отсортированный массив a, как если бы было выполнено sort(a, axis) </p></td></tr><tr><td><p>array(a[, type]) </p></td><td><p>Создание массива на основе последовательности a данного типа type </p></td></tr><tr><td><p>arrayrange(start[, stop[, step[, type]]]) </p></td><td><p>Аналог range() для массивов </p></td></tr><tr><td><p>asarray(a[, type[, savespace]]) </p></td><td><p>То же, что и array(), но не создает новый массив, если a уже является массивом. </p></td></tr><tr><td><p>choose(a, </p><p>(b0,...,bn)) </p></td><td><p>Создает массив на основе элементов, взятых по индексам из a (индексы от 0 до n включительно). Формы массивов a, b1, ..., bn должны совпадать </p></td></tr><tr><td><p>clip(a, a_min, a_max) </p></td><td><p>Обрубает значения массива a так, чтобы они находились </p></td></tr><tr><td></td><td><p>между значениями из a_min и a_max поэлементно </p></td></tr><tr><td><p>compress(cond, a[, axis]) </p></td><td><p>Возвращает массив только из тех элементов массива a, для которых условие cond истинно (не нуль) </p></td></tr><tr><td><p>concatenate(a[, axis]) </p></td><td><p>Соединение двух массивов (конкатенация) по заданному измерению axis (по умолчанию - по нулевой) </p></td></tr><tr><td><p>convolve(a, b[, mode]) </p></td><td><p>Свертка двух массивов. Аргумент mode может принимать значения 0, 1 или 2 </p></td></tr><tr><td><p>cross_correlate(a, b[, mode]) </p></td><td><p>Взаимная корреляция двух массивов. Параметр mode может принимать значения 0, 1 или 2 </p></td></tr><tr><td><p>cumproduct(a[, axis]) </p></td><td><p>Произведение по измерению axis массива a с промежуточными результатами </p></td></tr><tr><td><p>cumsum(a[, axis]) </p></td><td><p>Суммирование с промежуточными результатами </p></td></tr><tr><td><p>diagonal(a[, k[, axis1[, axis2]]]) </p></td><td><p>Взятие k -й диагонали массива a в плоскости измерений axis1 и axis2 </p></td></tr><tr><td><p>dot(a, b) </p></td><td><p>Внутреннее (матричное) произведение массивов. По определению: innerproduct(a, swapaxes(b, -1, -2)), т.е. с переставленными последними измерениями, как и должно быть при перемножении матриц </p></td></tr><tr><td><p>dump(obj, file) </p></td><td><p>Запись массива a (в двоичном виде) в открытый файловый объект file. Файл должен быть открыт в бинарном режиме. В файл можно записать несколько объектов подряд </p></td></tr><tr><td><p>dumps(obj) </p></td><td><p>Строка с двоичным представлением объекта obj </p></td></tr><tr><td><p>fromfunction(f, dims) </p></td><td><p>Строит массив, получая информацию от функции f(), в качестве аргументов которой выступают значения кортежа индексов. Фактически является сокращением для f(*tuple(indices(dims))) </p></td></tr><tr><td><p>fromstring(s[, count[, type]]) </p></td><td><p>Создание массива на основе бинарных данных, хранящихся в строке </p></td></tr><tr><td><p>identity(n) </p></td><td><p>Возвращает двумерный массив формы (n, n) </p></td></tr><tr><td><p>indices(dims[, type]) </p></td><td><p>Возвращает массив индексов заданной длины по каждому измерению с изменением поочередно по каждому изменению. Например, indices([2, 2])[1] дает двумерный массив [[0, 1], [0, 1]]. </p></td></tr><tr><td><p>innerproduct(a, b) </p></td><td><p>Внутреннее произведение двух массивов (по общему измерению). Для успешной операции a.shape[-1] должен </p></td></tr></table><p>Вопросы:</p><ol><li>Функция Numeric.take() </li><li>Функции Numeric.diagonal() и Numeric.trace()  </li><li>Функция Numeric.choose()</li><li>Свод функций модуля Numeric</li></ol><h1><a id="_Toc454873524"></a><a id="_Toc454109368"></a>Лекция 14. Работа со строковыми переменными</h1><p>План:</p><ol><li>обработка текстов</li><li>Строки  </li><li>Строковые литералы</li><li>Операции над строками</li><li>Операция форматирования</li></ol><p>Под <strong>обработкой текстов</strong> понимается анализ, преобразование, поиск, порождение текстовой информации. По большей части работа с естественными текстами не будет глубже, чем это возможно без систем искусственного интеллекта. Кроме того, здесь предполагается опустить рассмотрение обработки текстов посредством текстовых процессоров и редакторов, хотя некоторые из них (например, Cooledit) предоставляют возможность писать макрокоманды на Python. </p><p>Следует отметить, что для Python созданы также модули для работы с естественными языками, а также для лингвистических исследований. Хорошим учебным примером может служить nltk (the Natural Language Toolkit). </p><p>Стоит отметить проект PyParsing (<a href="http://pyparsing.sourceforge.net/">http://pyparsing.sourceforge.net)</a>, с помощью которого можно организовать обработку текста по заданной грамматике. </p><p><strong>Строки </strong></p><p><strong>Строки</strong> в языке Python являются типом данных, специально предназначенным для обработки текстовой информации. Строка может содержать произвольно длинный текст (ограниченный имеющейся памятью). </p><p>В новых версиях Python имеются два типа строк: обычные строки (последовательность байтов) и Unicode-строки (последовательность символов). В Unicode-строке каждый символ может занимать в памяти 2 или 4 байта, в зависимости от настроек периода компиляции. Четырехбайтовые знаки используются в основном для восточных языков. </p><p>При использовании Unicode-строк, следует мысленно принять точку зрения, относительно которой именно Unicode-представление является главным, а все остальные кодировки - лишь частные случаи представления текста, которые не могут передать всех символов. Без такой установки будет непонятно, почему преобразование из восьмибитной кодировки называется decode (декодирование). Для внешнего представления можно с успехом использовать кодировку UTF-8, хотя, конечно, это зависит от решаемых задач. </p><p><strong> Кодировка Python-программы </strong></p><p>Для того чтобы Unicode-литералы в Python-программе воспринимались интерпретатором правильно, необходимо указать кодировку в начале программы, записав в первой или второй строке примерно следующее (для Unix/Linux): </p><p># -*- coding: koi8-r -*- или (под Windows): </p><p># -*- coding: cp1251 -*- Могут быть и другие варианты: </p><p># -*- coding: latin-1 -*- </p><p># -*- coding: utf-8 -*- </p><p># -*- coding: mac-cyrillic -*- </p><p># -*- coding: iso8859-5 -*- </p><p>Полный перечень кодировок (и их псевдонимов): </p><p>&gt;&gt;&gt; import encodings.aliases </p><p>&gt;&gt;&gt; print encodings.aliases.aliases </p><p>{'iso_ir_6': 'ascii', 'maccyrillic': 'mac_cyrillic',  </p><p>'iso_celtic': 'iso8859_14', 'ebcdic_cp_wt': 'cp037',  'ibm500': 'cp500', ... </p><p>Если кодировка не указана, то считается, что используется us-ascii. При этом интерпретатор Python будет выдавать предупреждения при запуске модуля: </p><p>sys:1: DeprecationWarning: Non-ASCII character '\xf0' in file example.py  on line 2, but no encoding declared;  see http://www.python.org/peps/pep-0263.html for details </p><p><strong>Строковые литералы </strong></p><p>Строки можно задать в программе с помощью <strong>строковых литералов</strong>. Литералы записываются с использованием апострофов ', кавычек &quot; или этих же символов, взятых трижды. Внутри литералов обратная косая черта имеет специальное значение. Она служит для ввода специальных символов и для указания символов через коды. Если перед строковым литералом поставлено r, обратная косая черта не имеет специального значения ( r от английского слова raw, строка задается &quot;как есть&quot;). Unicode-литералы задаются с префиксом u. Вот несколько примеров: </p><p>s1 = &quot;строка 1&quot; s2 = r'\1\2' </p><p>s3 = &quot;&quot;&quot;apple\ntree&quot;&quot;&quot;  # \n - символ перевода строки s4 = &quot;&quot;&quot;apple </p><p>tree&quot;&quot;&quot;  # строка в утроенных кавычках может иметь внутри переводы строк s5 = '\x73\65' u1 = u&quot;Unicode literal&quot; u2 = u'\u0410\u0434\u0440\u0435\u0441' </p><p>Указание кодировки позволяет применять в Unicode-литералах указанную в начале программы кодировку. Если кодировка не указана, можно пользоваться только кодами символов, заданными через обратную косую черту. </p><p><strong>Операции над строками </strong></p><p>К операциям над строками, которые имеют специальную синтаксическую поддержку в языке, относятся, в частности конкатенация (склеивание) строк, повторение строки, форматирование: </p><p>&gt;&gt;&gt; print &quot;A&quot; + &quot;B&quot;,  &quot;A&quot;*5,  &quot;%s&quot; % &quot;A&quot; </p><p>AB AAAAA A </p><p>В операции форматирования левый операнд является <strong>строкой формата</strong>, а правый может быть либо кортежем, либо словарем, либо некоторым значением другого типа: </p><p>&gt;&gt;&gt; print &quot;%i&quot; % 234 </p><p>234 </p><p>&gt;&gt;&gt; print &quot;%i %s %3.2f&quot; % (5, &quot;ABC&quot;, 23.45678) </p><p>5 ABC 23.46 </p><p>&gt;&gt;&gt; a = 123 </p><p>&gt;&gt;&gt; b = [1, 2, 3] </p><p>&gt;&gt;&gt; print &quot;%(a)i: %(b)s&quot; % vars() </p><p>123: [1, 2, 3] </p><p><strong>Операция форматирования </strong></p><p>В строке формата кроме текста могут употребляться спецификации, регламентирующие формат выводимого значения. Спецификация имеет синтаксис </p><p>&quot;%&quot; [ключ][флаг*][шир][.точность][длина_типа]спецификатор ключ: &quot;(&quot; символ за исключением круглых скобок* &quot;)&quot; флаг: &quot;+&quot; | &quot;-&quot; | пробел | &quot;#&quot; | &quot;0&quot; шир: (&quot;1&quot; ... &quot;9&quot;)(&quot;0&quot; ... &quot;9&quot;)* | &quot;*&quot; точность: (&quot;1&quot; ... &quot;9&quot;)* | &quot;*&quot; длина_типа: &quot;a&quot; ... &quot;z&quot; | &quot;A&quot; ... &quot;Z&quot; спецификатор: &quot;a&quot; ... &quot;z&quot; | &quot;A&quot; ... &quot;Z&quot; | &quot;%&quot; Где символы обозначают следующее: </p><p>ключ </p><p>Ключ из словаря. </p><p>флаги </p><p>Дополнительные свойства преобразования. </p><p>шир </p><p>Минимальная ширина поля. </p><p>точность </p><p>Точность (для чисел с плавающей запятой). </p><p>длина_типа Модификатор типа. </p><p>спецификатор </p><p>Тип представления выводимого объекта. </p><p>В следующей таблице приведены некоторые наиболее употребительные значения для спецификации форматирования. </p><table><tr><td><p><strong>Символ </strong></p></td><td><p><strong>Где применяется </strong></p></td><td><p><strong>Что указывает </strong></p></td></tr><tr><td><p>0 </p></td><td><p>флаг </p></td><td><p>Заполнение нулями слева </p></td></tr><tr><td><p>- </p></td><td><p>флаг </p></td><td><p>Выравнивание по левому краю </p></td></tr><tr><td><p>+ </p></td><td><p>флаг </p></td><td><p>Обязательный вывод знака числа </p></td></tr><tr><td><p>пробел </p></td><td><p>флаг </p></td><td><p>Использовать пробел на месте знака числа </p></td></tr><tr><td><p>d, i </p></td><td><p>спецификатор </p></td><td><p>Знаковое целое </p></td></tr><tr><td><p>u </p></td><td><p>спецификатор </p></td><td><p>Беззнаковое целое </p></td></tr><tr><td><p>o </p></td><td><p>спецификатор </p></td><td><p>Восьмеричное беззнаковое целое </p></td></tr><tr><td><p>x, X </p></td><td><p>спецификатор </p></td><td><p>Шестнадцатеричное беззнаковое целое (со строчными или прописными латинскими буквами) </p></td></tr><tr><td><p>e, E </p></td><td><p>спецификатор </p></td><td><p>Число с плавающей запятой в формате с экспонентой </p></td></tr><tr><td><p>f, F </p></td><td><p>спецификатор </p></td><td><p>Число с плавающей запятой </p></td></tr><tr><td><p>g, G </p></td><td><p>спецификатор </p></td><td><p>Число с плавающей точкой в более коротком написании (автоматически выбирается e или f) </p></td></tr><tr><td><p>с </p></td><td><p>спецификатор </p></td><td><p>Одиночный символ (целое число или односимвольная строка) </p></td></tr><tr><td><p>r </p></td><td><p>спецификатор </p></td><td><p>Любой объект, приведенный к строке функцией repr() </p></td></tr><tr><td><p>s </p></td><td><p>спецификатор </p></td><td><p>Любой объект, приведенный к строке функцией str() </p></td></tr><tr><td><p>% </p></td><td><p>спецификатор </p></td><td><p>Знак 	процента. 	Для 	задания 	одиночного 	процента необходимо записать %% </p></td></tr></table><p>Вопросы:</p><ol><li>обработка текстов</li><li>Строки  </li><li>Строковые литералы</li><li>Операции над строками</li><li>Операция форматирования</li></ol><h1><a id="_Toc454873525"></a><a id="_Toc454109369"></a>Тема 2.3 Множества</h1><h1><a id="_Toc454873526"></a><a id="_Toc454109370"></a>Лекция 15. Понятие множества. Объявление множества. Операции над множествами</h1><p>План:</p><ol><li>Регулярные выражения</li><li>Синтаксис регулярного выражения  </li></ol><p><strong>Регулярные выражения </strong></p><p>Рассмотренных стандартных возможностей для работы с текстом достаточно далеко не всегда. Например, в методах find() и replace() задается всего одна строка. В реальных задачах такая однозначность встречается довольно редко, чаще требуется найти или заменить строки, отвечающие некоторому шаблону. </p><p><strong>Регулярные выражения</strong> (regular expressions) описывают множество строк, используя специальный язык, который сейчас и будет рассмотрен. (Строка, в которой задано регулярное выражение, будет называться шаблоном.) </p><p>Для работы с регулярными выражениями в Python используется модуль re. В следующем примере регулярное выражение помогает выделить из текста все числа: </p><p>&gt;&gt;&gt; import re </p><p>&gt;&gt;&gt; pattern = r&quot;[0-9]+&quot; </p><p>&gt;&gt;&gt; number_re = re.compile(pattern) </p><p>&gt;&gt;&gt; number_re.findall(&quot;122 234 65435&quot;) </p><p>['122', '234', '65435'] </p><p>В этом примере шаблон pattern описывает множество строк, которые состоят из одного или более символов из набора &quot;0&quot;, &quot;1&quot; , ..., &quot;9&quot; . Функция re.compile() компилирует шаблон в специальный Regex-объект, который имеет несколько методов, в том числе метод findall() для получения списка всех непересекающихся вхождений строк, удовлетворяющих шаблону, в заданную строку. </p><p>То же самое можно было сделать и так: </p><p>&gt;&gt;&gt; import re </p><p>&gt;&gt;&gt; re.findall(r&quot;[0-9]+&quot;, &quot;122 234 65435&quot;) </p><p>['122', '234', '65435'] </p><p>Предварительная компиляция шаблона предпочтительнее при его частом использовании, особенно внутри цикла. </p><table><tr><td><p>Примечание: </p><p>Следует заметить, что для задания шаблона использована необработанная строка. В данном примере она не требовалась, но в общем случае лучше записывать строковые литералы именно так, чтобы исключить влияние специальных последовательностей, записываемых через обратную косую черту. </p></td></tr></table><p><strong>Синтаксис регулярного выражения </strong></p><p>Синтаксис регулярных выражений в Python почти такой же, как в Perl, grep и некоторых других инструментах. Часть символов (в основном буквы и цифры) обозначают сами себя. Строка <strong>удовлетворяет (соответствует)</strong> шаблону, если она входит во множество строк, которые этот шаблон описывает. </p><p>Здесь стоит также отметить, что различные операции используют шаблон поразному. Так, search() ищет первое вхождение строки, удовлетворяющей шаблону, в заданной строке, а match() требует, чтобы строка удовлетворяла шаблону с самого начала.Символы, имеющие специальное значение в записи регулярных выражений: </p><table><tr><td><p><strong>Символ </strong></p></td><td><p><strong>Что обозначает в регулярном выражении </strong></p></td></tr><tr><td><p>&quot;.&quot; </p></td><td><p>Любой символ </p></td></tr><tr><td><p>&quot;^&quot; </p></td><td><p>Начало строки </p></td></tr><tr><td><p>&quot;$&quot; </p></td><td><p>Конец строки </p></td></tr><tr><td><p>&quot;*&quot; </p></td><td><p>Повторение фрагмента нуль или более раз (жадное) </p></td></tr><tr><td><p>&quot;+&quot; </p></td><td><p>Повторение фрагмента один или более раз (жадное) </p></td></tr><tr><td><p>&quot;?&quot; </p></td><td><p>Предыдущий фрагмент либо присутствует, либо отсутствует </p></td></tr><tr><td><p>&quot;{m,n}&quot; </p></td><td><p>Повторение предыдущего фрагмента от m до n раз включительно (жадное) </p></td></tr><tr><td><p>&quot;[...]&quot; </p></td><td><p>Любой символ из набора в скобках. Можно задавать диапазоны символов с идущими подряд кодами, например: a-z </p></td></tr><tr><td><p>&quot;[^...]&quot; </p></td><td><p>Любой символ не из набора в скобках </p></td></tr><tr><td><p>&quot;\&quot; </p></td><td><p>Обратная косая черта отменяет специальное значение следующего за ней символа </p></td></tr><tr><td><p>&quot;|&quot; </p></td><td><p>Фрагмент справа или фрагмент слева </p></td></tr><tr><td><p>&quot;*?&quot; </p></td><td><p>Повторение фрагмента нуль или более раз (не жадное) </p></td></tr><tr><td><p>&quot;+?&quot; </p></td><td><p>Повторение фрагмента один или более раз (не жадное) </p></td></tr><tr><td><p>&quot;{m,n}?&quot; </p></td><td><p>Повторение предыдущего фрагмента от m до n раз включительно (не жадное) </p></td></tr></table><p>В таблице ниже вместо регвыр может быть записано регулярное выражение, вместо имя - идентификатор, а флаги будут рассмотрены ниже. </p><table><tr><td><p><strong>Обозначение </strong></p></td><td><p><strong>Описание </strong></p></td></tr><tr><td><p>&quot;(регвыр)&quot; </p></td><td><p>Обособляет регулярное выражение в скобках и выделяет группу </p></td></tr><tr><td><p>&quot;(?:регвыр)&quot; </p></td><td><p>Обособляет регулярное выражение в скобках без выделения группы </p></td></tr><tr><td><p>&quot;(?=регвыр)&quot; </p></td><td><p>Взгляд вперед: строка должна соответствовать заданному регулярному выражению, но дальнейшее сопоставление с шаблоном начнется с того же места </p></td></tr><tr><td><p>&quot;(?!регвыр)&quot; </p></td><td><p>То же, но с отрицанием соответствия </p></td></tr><tr><td><p>&quot;(?&lt;=регвыр)&quot; </p></td><td><p>Взгляд назад: строка должна соответствовать, если до этого момента соответствует регулярному выражению. Не занимает места в строке, к которой применяется шаблон. Параметр регвыр должен быть фиксированной длины (то есть, без &quot;+&quot; и &quot;*&quot; ) </p></td></tr><tr><td><p>&quot;(?&lt;!регвыр)&quot; </p></td><td><p>То же, но с отрицанием соответствия </p></td></tr><tr><td><p>&quot;(?P&lt;имя&gt;регвыр)&quot; </p></td><td><p>Выделяет именованную группу с именем имя </p></td></tr><tr><td><p>&quot;(?P=имя)&quot; </p></td><td><p>Точно соответствует выделенной ранее именованной группе с именем имя </p></td></tr><tr><td><p>&quot;(?#регвыр)&quot; </p></td><td><p>Комментарий (игнорируется) </p></td></tr><tr><td><p>&quot;(?(имя)рв1|рв2)&quot; </p></td><td><p>Если группа с номером или именем имя оказалась определена, результатом будет сопоставление с рв1, иначе - c рв2. Часть |рв2 может отсутствовать </p></td></tr><tr><td><p>&quot;(?флаг)&quot; </p></td><td><p>Задает флаг для всего данного регулярного выражения. Флаги необходимо задавать в начале шаблона </p></td></tr></table><p>В таблице ниже описаны специальные последовательности, использующие обратную косую черту: </p><table><tr><td><p><strong>Последовательность </strong></p></td><td><p><strong>Чему соответствует </strong></p></td></tr><tr><td><p>&quot;\1&quot; - &quot;\9&quot; </p></td><td><p>Группа с указанным номером. Группы нумеруются, начиная с 1 </p></td></tr><tr><td><p>&quot;\A&quot; </p></td><td><p>Промежуток перед началом всей строки (почти аналогично &quot;^&quot;</p><p>) </p></td></tr><tr><td><p>&quot;\Z&quot; </p></td><td><p>Промежуток перед концом всей строки (почти аналогично &quot;$&quot; ) </p></td></tr><tr><td><p>&quot;\b&quot; </p></td><td><p>Промежуток между символами перед словом или после него </p></td></tr><tr><td><p>&quot;\B&quot; </p></td><td><p>Наоборот, не соответствует промежутку между символами на границе слова </p></td></tr><tr><td><p>&quot;\d&quot; </p></td><td><p>Цифра. Аналогично &quot;[0-9]&quot; </p></td></tr><tr><td><p>&quot;\s&quot; </p></td><td><p>Любой пробельный символ. Аналогично &quot;[\t\n\r\f\v]&quot; </p></td></tr><tr><td><p>&quot;\S&quot; </p></td><td><p>Любой непробельный символ. Аналогично &quot;[^\t\n\r\f\v]&quot; </p></td></tr><tr><td><p>&quot;\w&quot; </p></td><td><p>Любая цифра или буква (зависит от флага LOCALE ) </p></td></tr><tr><td><p>&quot;\W&quot; </p></td><td><p>Любой символ, не являющийся цифрой или буквой (зависит от флага LOCALE ) </p></td></tr></table><p>Флаги, используемые с регулярными выражениями: </p><p>&quot;(?i)&quot;, re.I, re.IGNORECASE </p><p>Сопоставление проводится без учета регистра букв. </p><p>&quot;(?L)&quot;, re.L, re.LOCALE </p><p>Влияет на определение буквы в &quot;\w&quot;, &quot;\W&quot;, &quot;\b&quot;, &quot;\B&quot; в зависимости от текущей культурной среды (locale). </p><p>&quot;(?m)&quot;, re.M, re.MULTILINE </p><p>Если этот флаг задан, &quot;^&quot; и &quot;$&quot; соответствуют началу и концу любой строки. </p><p>&quot;(?s)&quot;, re.S, re.DOTALL </p><p>Если задан, &quot;.&quot; соответствует также и символу конца строки &quot;\n&quot;. </p><p>&quot;(?x)&quot;, re.X, re.VERBOSE </p><p>Если задан, пробельные символы, не экранированные в шаблоне обратной косой чертой, являются незначащими, а все, что расположено после символа </p><p>Вопросы:</p><ol><li>Регулярные выражения</li><li>Синтаксис регулярного выражения  </li></ol><h1><a id="_Toc454873527"></a><a id="_Toc454109371"></a>Лекция 16. Работа с данными типа множество</h1><p>План:</p><ol><li>Формат CSV</li><li>Пакет email</li><li>Разбор сообщения. Класс Message</li><li>Разбор поля заголовка</li></ol><p><strong>Формат CSV </strong></p><p>Файл в формате CSV (comma-separated values - значения, разделенные запятыми) - универсальное средство для переноса табличной информации между приложениями (электронными таблицами, СУБД, адресными книгами и т.п.). К сожалению, формат файла не имеет строго определенного стандарта, поэтому между файлами, порождаемыми различными приложениями, существуют некоторые тонкие различия. Внутри файл выглядит примерно так (файл pr.csv ): </p><p>name,number,text a,1,something here b,2,&quot;one, two, three&quot; c,3,&quot;no commas here&quot; </p><p> Для работы с CSV-файлами имеются две основные функции: </p><p>reader(csvfile[, dialect='excel'[, fmtparam]])  </p><p>Возвращает читающий объект, который является итератором по всем строкам заданного файла. В качестве csvfile может выступать любой объект, который поддерживает протокол итератора и возвращает строку при обращении к его методу next(). Необязательный аргумент dialect, по умолчанию равный 'excel', указывает на необходимость использования того или иного набора свойств. Узнать доступные варианты можно с помощью csv.list_dialects(). Аргумент может быть одной из строк, возвращаемых указанной функцией, либо экземпляром подкласса класса csv.Dialect. Необязательный аргумент fmtparam служит для переназначения отдельных свойств по сравнению с заданным параметром dialect набором. Все получаемые данные являются строками. </p><p>writer(csvfile[, dialect='excel'[, fmtparam]])  </p><p>Возвращает 	пишущий 	объект 	для 	записи 	пользовательских 	данных 	с использованием разделителя в заданный файлоподобный объект. Параметры dialect и fmtparam имеют тот же смысл, что и выше. Все данные, кроме строк, обрабатывают функцией str() перед помещением в файл. </p><p>В следующем примере читается CSV-файл и записывается другой, где числа второго столбца увеличены на единицу: </p><p>import csv </p><p>input_file = open(&quot;pr.csv&quot;, &quot;rb&quot;) rdr = csv.reader(input_file) output_file = open(&quot;pr1.csv&quot;, &quot;wb&quot;) wrtr = csv.writer(output_file) for rec in rdr: </p><p>  try: </p><p>    rec[1] = int(rec[1]) + 1   except:     pass   wrtr.writerow(rec) input_file.close() output_file.close() </p><p> </p><p>В результате получится файл pr1.csv следующего содержания: </p><p>name,number,text a,2,something here b,3,&quot;one, two, three&quot; c,4,no commas here </p><p> </p><p>Модуль также определяет два класса для более удобного чтения и записи значений с использованием словаря. Вызовы конструкторов следующие: </p><p>class DictReader(csvfile, fieldnames[, restkey=None[, restval=None[, </p><p>dialect='excel']]]]) </p><p> <strong>Пакет email </strong></p><p>Модули пакета email помогут разобрать, изменить и сгенерировать сообщение в формате RFC 2822. Наиболее часто RFC 2822 применяется в сообщениях электронной почты в Интернете. </p><p>В пакете есть несколько модулей, назначение которых (кратко) указано ниже: </p><p>Message </p><p>Модуль определяет класс Message - основной класс для представления сообщения в пакете email. </p><p>Parser </p><p>Модуль для разбора представленного в виде текста сообщения с получением объектной структуры сообщения. </p><p>Header </p><p>Модуль для работы с полями, в которых используется кодировка, отличная от ASCII. </p><p>Generator </p><p>Порождает текст сообщения RFC 2822 на основании объектной модели. </p><p>Utils </p><p>Различные утилиты, которые решают разнообразные небольшие задачи, связанные с сообщениями. </p><p>В пакете есть и другие модули, которые здесь рассматриваться не будут. </p><p><strong>Разбор сообщения. Класс Message </strong></p><p>Класс Message - центральный во всем пакете email. Он определяет методы для работы с сообщением, которое состоит из заголовка (header) и тела (payload). Поле заголовка имеет название и значение, разделенное двоеточием (двоеточие не входит ни в название, ни в значение). Названия полей нечувствительны к регистру букв при поиске значения, хотя хранятся с учетом регистра. В классе также определены методы для доступа к некоторым часто используемым сведениям (кодировке сообщения, типу содержимого и т.п.). </p><p>Следует заметить, что сообщение может иметь одну или несколько частей, в том числе вложенных друг в друга. Например, сообщение об ошибке доставки письма может содержать исходное письмо в качестве вложения. </p><p>Пример наиболее употребительных методов экземпляров класса Message с пояснениями: </p><p>&gt;&gt;&gt; import email </p><p>&gt;&gt;&gt; input_file = open(&quot;pr1.eml&quot;) </p><p>&gt;&gt;&gt; msg = email.message_from_file(input_file) </p><p>Здесь используется функция email.message_from_file() для чтения сообщения из файла pr1.eml. Сообщение можно получить и из строки с помощью функции email.message_from_string(). А теперь следует произвести некоторые операции над этим сообщением (не стоит обращать внимания на странные имена - сообщение было взято из папки СПАМ). Доступ к полям по имени осуществляется так: </p><p>&gt;&gt;&gt; print msg['from'] </p><p>&quot;felton olive&quot; &lt;zinakinch@thecanadianteacher.com&gt; </p><p>&gt;&gt;&gt; msg.get_all('received') </p><p>['from mail.onego.ru\n\tby localhost with POP3 (fetchmail-6.2.5  polling mail.onego.ru account spam)\n\tfor spam@localhost  </p><p>(single-drop); Wed, 01 Sep 2004 15:46:33 +0400 (MSD)',  </p><p>'from thecanadianteacher.com ([222.65.104.100])\n\tby mail.onego.ru  </p><p>(8.12.11/8.12.11) with SMTP id i817UtUN026093;\n\tWed, 1 Sep 2004  11:30:58 +0400'] </p><p>Стоит заметить, что в электронном письме может быть несколько полей с именем received (в этом примере их два). </p><p>Некоторые важные данные можно получить в готовом виде, например, тип содержимого, кодировку: </p><p>&gt;&gt;&gt; msg.get_content_type() </p><p>'text/plain' </p><p>&gt;&gt;&gt; print msg.get_main_type(), msg.get_subtype() text plain </p><p>&gt;&gt;&gt; print msg.get_charset() </p><p>None </p><p>&gt;&gt;&gt; print msg.get_params() </p><p>[('text/plain', ''), ('charset', 'us-ascii')] </p><p>&gt;&gt;&gt; msg.is_multipart() </p><p>False  или список полей: </p><p>&gt;&gt;&gt; print msg.keys() </p><p>['Received', 'Received', 'Message-ID', 'Date', 'From', 'User-Agent',  </p><p>'MIME-Version', 'To', 'Subject', 'Content-Type',  </p><p>'Content-Transfer-Encoding', 'Spam', 'X-Spam'] </p><p>Так как сообщение состоит из одной части, можно получить его тело в виде строки: </p><p>&gt;&gt;&gt; print msg.get_payload() </p><p>sorgeloosheid  hullw ifesh nozama decompresssequenceframes </p><p> <strong>Разбор поля заголовка </strong></p><p>В примере выше поле Subject формировалось с помощью email.Header.make_header(). Разбор поля поможет провести другая функция: email.Header.decode_header(). Эта функция возвращает список кортежей, в каждом из них указан кусочек текста поля и кодировка, в которой этот текст был задан. Следующий пример поможет понять суть дела: </p><p>	subj 	= 	&quot;&quot;&quot;=?koi8-</p><p>r?Q?=FC=D4=CF_=D0=D2=C9=CD=C5=D2_=CF=DE=C5=CE=D8_=C4=CC=C9?= </p><p> =?koi8-r?Q?=CE=CE=CF=C7=CF_=28164_bytes=29_=D0=CF=CC=D1_=D3_=D4?= </p><p> =?koi8-r?Q?=C5=CD=CF=CA_=D3=CF=CF=C2=DD=C5=CE=C9=D1=2E_=EF=CE=CF_?= </p><p> =?koi8-r?Q?=D2=C1=DA=C2=C9=CC=CF=D3=D8_=CE=C1_=CB=D5=D3=CB=C9_=D7?= </p><p> =?koi8-r?Q?_=D3=CF=CF=C2=DD=C5=CE=C9=C9=2C_=CE=CF_=CC=C5=C7=CB=CF?= </p><p> =?koi8-r?Q?_=D3=CF=C2=C9=D2=C1=C5=D4=D3=D1_=D7_=D4=C5=CB=D3=D4_?= </p><p> =?koi8-r?Q?=D3_=D0=CF=CD=CF=DD=D8=C0_email=2EHeader=2Edecode=5Fheader?= </p><p> =?koi8-r?Q?=28=29?=&quot;&quot;&quot; import email.Header for text, enc in email.Header.decode_header(subj): </p><p>  print enc, text </p><p> </p><p>В результате будет выведено: </p><p>koi8-r Это пример очень длинного (164 bytes) поля с темой сообщения.  Оно разбилось на куски в сообщении, но легко собирается в текст  с помощью email.Header.decode_header() </p><p> Вопросы:</p><ol><li>Формат CSV</li><li>Пакет email</li><li>Разбор сообщения. Класс Message</li><li>Разбор поля заголовка</li></ol><h1><a id="_Toc454873528"></a><a id="_Toc454109372"></a>Тема 2.4 Записи  </h1><h1><a id="_Toc454873529"></a><a id="_Toc454109373"></a>Лекция 17. Определение типа запись</h1><p>План:</p><ol><li>XML</li><li>SAX</li><li>Анализ XML-документа</li></ol><p><strong>Язык XML </strong></p><p>В рамках одной лекции довольно сложно объяснить, что такое XML, и то, как с ним работать. В примерах используется входящий в стандартную поставку пакет xml. </p><p><strong>XML</strong> (Extensible Markup Language, расширяемый язык разметки) позволяет налаживать взаимодействие между приложениями различных производителей, хранить и подвергать обработке сложно структурированные данные. </p><p>Язык XML (как и HTML) является подмножеством SGML, но его применения не ограничены системой WWW. В XML можно создавать собственные наборы тегов для конкретной предметной области. В XML можно хранить и подвергать обработке базы данных и знаний, протоколы взаимодействия между объектами, описания ресурсов и многое другое. </p><p>Новичкам не всегда понятно, зачем нужно использовать такой достаточно многословный формат, когда можно создать свой, компактный формат для хранения тех же самых данных. Преимущество XML состоит в том, что вместе с данными он хранит и контекстную информацию: теги и их атрибуты имеют имена. Немаловажно также, что XML сегодня - единый общепринятый стандарт, для которого создано немало инструментальных средств. </p><p>Говоря об XML, надо иметь в виду, что XML-документы бывают <strong>формальноправильными</strong> (well-formed) и <strong>состоятельными</strong> (valid). Состоятельный XML-документ - это формально-правильный XML-документ, имеющий <strong>объявление типа документа</strong> (DTD, Document Type Definition). Объявление типа документа задает грамматику, которой текст документа на XML должен удовлетворять. Для простоты изложения здесь не будет рассматриваться DTD, предпочтительнее ограничиться формальноправильными документами. </p><p>Для представления букв и других символов XML использует Unicode, что сокращает проблемы с представлением символов различных алфавитов. Однако это обстоятельство необходимо помнить и не употреблять в XML восьмибитную кодировку (во всяком случае, без явного указания). </p><p>Следующий пример достаточно простого XML-документа дает представление об этом формате (файл expression.xml): </p><p>&lt;?xml version=&quot;1.0&quot; encoding=&quot;iso-8859-1&quot;?&gt; </p><p>&lt;expression&gt; </p><p>  &lt;operation type=&quot;+&quot;&gt; </p><p>    &lt;operand&gt;2&lt;/operand&gt; </p><p>    &lt;operand&gt; </p><p>      &lt;operation type=&quot;*&quot;&gt; </p><p>        &lt;operand&gt;3&lt;/operand&gt; </p><p>        &lt;operand&gt;4&lt;/operand&gt; </p><p>      &lt;/operation&gt; </p><p>    &lt;/operand&gt; </p><p>  &lt;/operation&gt; </p><p>&lt;/expression&gt; </p><p> </p><p>XML-документ всегда имеет структуру дерева, в корне которого сам документ. Его части, описываемые вложенными парами тегов, образуют узлы. Таким образом, ребра дерева обозначают &quot;непосредственное вложение&quot;. Атрибуты тега можно считать листьями, как и наиболее вложенные части, не имеющие в своем составе других частей. Получается, что документ имеет древесную структуру. </p><p><strong>Формирование XML-документа </strong></p><p>Концептуально существуют два пути обработки XML-документа: последовательная обработка и работа с объектной моделью документа. </p><p>В первом случае обычно используется <strong>SAX</strong> (Simple API for XML, простой программный интерфейс для XML). Работа SAX заключается в чтении источников данных (input source) XML-анализаторами (XML-reader) и генерации последовательности событий (events), которые обрабатываются объектамиобработчиками (handlers). SAX дает последовательный доступ к XML-документу. </p><p>Во втором случае анализатор XML строит <strong>DOM</strong> (Document Object Model, объектная модель документа), предлагая для XML-документа конкретную объектную модель. В рамках этой модели узлы DOM-дерева доступны для произвольного доступа,а для переходов между узлами предусмотрен ряд методов. </p><p>Можно применить оба этих подхода для формирования приведенного выше XMLдокумента. </p><p>С помощью SAX документ сформируется так: </p><p>import sys </p><p>from xml.sax.saxutils import XMLGenerator g = XMLGenerator(sys.stdout) </p><p>g.startDocument() </p><p>g.startElement(&quot;expression&quot;, {}) </p><p>g.startElement(&quot;operation&quot;, {&quot;type&quot;: &quot;+&quot;}) </p><p>g.startElement(&quot;operand&quot;, {}) </p><p>g.characters(&quot;2&quot;) </p><p>g.endElement(&quot;operand&quot;) </p><p>g.startElement(&quot;operand&quot;, {}) </p><p>g.startElement(&quot;operation&quot;, {&quot;type&quot;: &quot;*&quot;}) </p><p>g.startElement(&quot;operand&quot;, {}) </p><p>g.characters(&quot;3&quot;) </p><p>g.endElement(&quot;operand&quot;) </p><p>g.startElement(&quot;operand&quot;, {}) </p><p>g.characters(&quot;4&quot;) </p><p>g.endElement(&quot;operand&quot;) </p><p>g.endElement(&quot;operation&quot;) </p><p>g.endElement(&quot;operand&quot;) </p><p>g.endElement(&quot;operation&quot;) </p><p>g.endElement(&quot;expression&quot;) </p><p>g.endDocument() </p><p>Построение дерева объектной модели документа может выглядеть, например, так: </p><p>from xml.dom import minidom dom = minidom.Document() e1 = dom.createElement(&quot;expression&quot;) dom.appendChild(e1) </p><p>p1 = dom.createElement(&quot;operation&quot;) p1.setAttribute('type', '+') x1 = dom.createElement(&quot;operand&quot;) x1.appendChild(dom.createTextNode(&quot;2&quot;)) p1.appendChild(x1) e1.appendChild(p1) </p><p>p2 = dom.createElement(&quot;operation&quot;) p2.setAttribute('type', '*') x2 = dom.createElement(&quot;operand&quot;) x2.appendChild(dom.createTextNode(&quot;3&quot;)) p2.appendChild(x2) </p><p>x3 = dom.createElement(&quot;operand&quot;) x3.appendChild(dom.createTextNode(&quot;4&quot;)) p2.appendChild(x3) </p><p>x4 = dom.createElement(&quot;operand&quot;) x4.appendChild(p2) p1.appendChild(x4) print dom.toprettyxml() </p><p>Легко заметить, что при использовании SAX команды на генерацию тегов и других частей выдаются последовательно, а вот построение одной и той же DOM можно выполнять различными последовательностями команд формирования узла и его соединения с другими узлами. </p><p>Конечно, указанные примеры носят довольно теоретический характер, так как на практике строить XML-документы таким образом обычно не приходится. </p><p><strong>Анализ XML-документа </strong></p><p>Для работы с готовым XML-документом нужно воспользоваться XML-анализаторами. Анализ XML-документа с порождением объекта класса Document происходит всего в одной строчке, с помощью функции parse(). Здесь стоит заметить, что кроме стандартного пакета xml можно поставить пакет PyXML или альтернативные коммерческие пакеты. Тем не менее, разработчики стараются придерживаться единого API, который продиктован стандартом DOM Level 2: </p><p>import xml.dom.minidom </p><p>dom = xml.dom.minidom.parse(&quot;expression.xml&quot;) </p><p> </p><p>dom.normalize() </p><p> def output_tree(node, level=0): </p><p>  if node.nodeType == node.TEXT_NODE:     if node.nodeValue.strip(): </p><p>      print &quot;. &quot;*level, node.nodeValue.strip()   else:   # ELEMENT_NODE или DOCUMENT_NODE     atts = node.attributes or {}     att_string = &quot;, &quot;.join( </p><p>        [&quot;%s=%s &quot; % (k, v)  for k, v in atts.items()])     print &quot;. &quot;*level, node.nodeName, att_string     for child in node.childNodes:       output_tree(child, level+1) </p><p> </p><p>output_tree(dom) </p><p>В этом примере дерево выводится с помощью определенной функции output_tree(), которая принимает на входе узел и вызывается рекурсивно для всех вложенных узлов. </p><p>В результате получается примерно следующее: </p><p>#document  </p><p>.  expression  </p><p>. .  operation type=+  </p><p>. . .  operand  . . . .  2 </p><p>. . .  operand  </p><p>. . . .  operation type=*  </p><p>. . . . .  operand  . . . . . .  3 </p><p>. . . . .  operand  </p><p>. . . . . .  4 </p><p> </p><p>Здесь же применяется метод normalize() для того, чтобы все текстовые фрагменты были слиты воедино (в противном случае может следовать подряд несколько узлов с текстом). </p><p>Можно заметить, что даже в небольшом примере использовались атрибуты узлов: node.nodeType указывает тип узла, node.nodeValue применяется для доступа к данным, node.nodeName дает имя узла (соответствует названию тега), node.attributes дает доступ к атрибутам узла. node.childNodes применяется для доступа к дочерним узлам. Этих свойств достаточно, чтобы рекурсивно обойти дерево. </p><p>Вопросы:</p><ol><li>XML</li><li>SAX</li><li>Анализ XML-документа</li></ol><h1><a id="_Toc454873530"></a><a id="_Toc454109374"></a>Лекция 18. Правила работы с записями</h1><p>План:</p><ol><li>web-приложение </li><li>CGI-сценарии</li><li>Модуль cgi</li></ol><p>Под <strong>web-приложением</strong> будет пониматься программа, основной интерфейс пользователя которой работает в стандартном WWW-браузере под управлением HTML и XML-документов. Для улучшения качества интерфейса пользователя часто применяют JavaScript, однако это несколько снижает универсальность интерфейса. Следует заметить, что интерфейс можно построить на Java- или Flash-апплетах, однако, такие приложения сложно назвать web-приложениями, так как Java или Flash могут использовать собственные протоколы для общения с сервером, а не стандартный для WWW протокол HTTP. </p><p>При создании web-приложений стараются отделить Форму (внешний вид, стиль), Содержание и Логику обработки данных. Современные технологии построения webсайтов дают возможность подойти достаточно близко к этому идеалу. Тем не менее, даже без применения многоуровневых приложений можно придерживаться стиля, позволяющего изменять любой из этих аспектов, не затрагивая (или почти не затрагивая) двух других. Рассуждения на эту тему будут продолжены в разделе, посвященном средам разработки. </p><p><strong>CGI-сценарии </strong></p><p>Классический путь создания приложений для WWW - написание CGI-сценариев (иногда говорят - скриптов). CGI (Common Gateway Interface, общий шлюзовой интерфейс) - это стандарт, регламентирующий взаимодействие сервера с внешними приложениями. В случае с WWW, web-сервер может направить запрос на генерацию страницы по определенному сценарию. Этот сценарий, получив на вход данные от webсервера (тот, в свою очередь, мог получить их от пользователя), генерирует готовый объект (изображение, аудиоданные, таблицу стилей и т.п.). </p><p>При вызове сценария Web-сервер передает ему информацию через стандартный ввод, переменные окружения и, для ISINDEX, через аргументы командной строки (они доступны через sys.argv ). </p><p>Два основных метода передачи данных из заполненной в браузере формы Webсерверу (и CGI-сценарию) - GET и POST. В зависимости от метода данные передаются по-разному. В первом случае они кодируются и помещаются прямо в URL, например: http://host/cgi-bin/a.cgi?a=1&amp;b=3. Сценарий получает их в переменной окружения с именем QUERY_STRING. В случае метода POST они передаются на стандартный ввод. </p><p>Для корректной работы сценарии помещаются в предназначенный для этого каталог на web-сервере (обычно он называется cgi-bin ) или, если это разрешено конфигурацией сервера, в любом месте среди документов HTML. Сценарий должен иметь признак исполняемости. В системе Unix его можно установить с помощью команды chmod a+x. </p><p>Следующий простейший сценарий выводит значения из словаря os.environ и позволяет увидеть, что же было ему передано: </p><p>#!/usr/bin/python </p><p> import os print &quot;&quot;&quot;Content-Type: text/plain </p><p> </p><p>%s&quot;&quot;&quot; % os.environ </p><p> <strong>Модуль cgi </strong></p><p>В Python имеется поддержка CGI в виде модуля cgi. Следующий пример показывает некоторые из его возможностей: </p><p>#!/usr/bin/python # -*- coding: cp1251 -*- import cgi, os </p><p> # анализ запроса f = cgi.FieldStorage() if f.has_key(&quot;a&quot;):   a = f[&quot;a&quot;].value else: </p><p>  a = &quot;0&quot; </p><p> # обработка запроса b = str(int(a)+1) </p><p>mytext = open(os.environ[&quot;SCRIPT_FILENAME&quot;]).read() mytext_html = cgi.escape(mytext) </p><p> # формирование ответа </p><p>print &quot;&quot;&quot;Content-Type: text/html </p><p> &lt;html&gt;&lt;head&gt;&lt;title&gt;Решение примера: %(b)s = %(a)s + 1&lt;/title&gt;&lt;/head&gt; </p><p>&lt;body&gt; </p><p>%(b)s </p><p>&lt;table width=&quot;80%%&quot;&gt;&lt;tr&gt;&lt;td&gt; </p><p>&lt;form action=&quot;me.cgi&quot; method=&quot;GET&quot;&gt; </p><p>&lt;input type=&quot;text&quot; name=&quot;a&quot; value=&quot;0&quot; size=&quot;6&quot;&gt; </p><p>&lt;input type=&quot;submit&quot; name=&quot;b&quot; value=&quot;Обработать&quot;&gt; </p><p>&lt;/form&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; </p><p>&lt;pre&gt; </p><p>%(mytext_html)s </p><p>&lt;/pre&gt; </p><p>&lt;/body&gt;&lt;/html&gt;&quot;&quot;&quot; % vars() </p><p>В этом примере к заданному в форме числу прибавляется 1. Кроме того, выводится исходный код самого сценария. Следует заметить, что для экранирования символов &gt;, </p><p>&lt;, &amp; использована функция cgi.escape(). Для формирования Web-страницы применена операция форматирования. В качестве словаря для выполнения подстановок использован словарь vars() со всеми локальными переменными. Знаки процента пришлось удвоить, чтобы они не интерпретировались командой форматирования. Стоит обратить внимание на то, как получено значение от пользователя. Объект FieldStorage &quot;почти&quot; словарь, с тем исключением, что для получения обычного значения нужно дополнительно посмотреть атрибут value. Дело в том, что в сценарий могут передаваться не только текстовые значения, но и файлы, а также множественные значения с одним и тем же именем. </p><p>В примере выше проверка на допустимость произведена при вызове функции int(): если было бы задано нечисловое значение, сценарий аварийно завершился, а пользователь увидел Internal Server Error. </p><p>После анализа входных данных можно выделить фазу их обработки. В этой части CGI-сценария вычисляются переменные для дальнейшего вывода. Здесь необходимо учитывать не только значения переданных переменных, но и факт их присутствия или отсутствия, так как это тоже может влиять на логику сценария. </p><p>И, наконец, фаза вывода готового объекта (текста, HTML-документа, изображения, мультимедиа-объекта и т.п.). Проще всего заранее подготовить шаблон страницы (или ее крупных частей), а потом просто заполнить содержимым из переменных. </p><p>В приведенных примерах имена появлялись в строке запроса только один раз. Некоторые формы порождают несколько значений для одного имени. Получить все значения можно с помощью метода getlist(): </p><p>lst = form.getlist(&quot;fld&quot;) </p><p>Список lst будет содержать столько значений, сколько полей с именем fld получено из web-формы (он может быть и пустым, если ни одно поле с заданным именем не было заполнено). </p><p>В некоторых случаях необходимо передать на сервер файлы (сделать upload). Следующий пример и комментарий к нему помогут разобраться с этой задачей: #!/usr/bin/env python import cgi </p><p> form = cgi.FieldStorage() file_contents = &quot;&quot; if form.has_key(&quot;filename&quot;):   fileitem = form[&quot;filename&quot;]   if fileitem.file:       file_contents = &quot;&quot;&quot;&lt;P&gt;Содержимое переданного файла: </p><p>    &lt;PRE&gt;%s&lt;/PRE&gt;&quot;&quot;&quot; % fileitem.file.read() </p><p> </p><p>print &quot;&quot;&quot;Content-Type: text/html </p><p> </p><p>&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Загрузка файла&lt;/TITLE&gt;&lt;/HEAD&gt; </p><p>&lt;BODY&gt;&lt;H1&gt;Загрузка файла&lt;/H1&gt; </p><p>&lt;P&gt;&lt;FORM ENCTYPE=&quot;multipart/form-data&quot;  </p><p>ACTION=&quot;getfile.cgi&quot; METHOD=&quot;POST&quot;&gt; </p><p>&lt;br&gt;Файл: &lt;INPUT TYPE=&quot;file&quot; NAME=&quot;filename&quot;&gt; </p><p>&lt;br&gt;&lt;INPUT TYPE=&quot;submit&quot; NAME=&quot;button&quot; VALUE=&quot;Передать файл&quot;&gt; </p><p>&lt;/FORM&gt; </p><p>%s </p><p>&lt;/BODY&gt;&lt;/HTML&gt;&quot;&quot;&quot; % file_contents </p><p> В начале следует рассмотреть web-форму, которая приведена в конце сценария: именно она будет выводиться пользователю при обращении по CGI-сценарию. Форма имеет поле типа file, которое в web-браузере представляется полоской ввода и кнопкой &quot;Browse&quot;. Нажимая на кнопку &quot;Browse&quot;, пользователь выбирает файл, доступный в ОС на его компьютере. После этого он может нажать кнопку &quot;Передать файл&quot; для передачи файла на сервер. </p><p>Для отладки CGI-сценария можно использовать модуль cgitb. При возникновении ошибки этот модуль выдаст красочную HTML-страницу с указанием места возбуждения исключения. В начале отлаживаемого сценария нужно поставить </p><p>import cgitb cgitb.enable(1) </p><p> </p><p>Или, если не нужно показывать ошибки в браузере: </p><p>import cgitb </p><p>  cgitb.enable(0, logdir=&quot;/tmp&quot;) </p><p> </p><p>Только необходимо помнить, что следует убрать эти строки, когда сценарий будет отлажен, так как он выдает кусочки кода сценария. Это может быть использовано злоумышленниками, с тем чтобы найти уязвимости в CGI-сценарии или подсмотреть пароли (если таковые присутствуют в сценарии). </p><p>Вопросы:</p><ol><li>web-приложение </li><li>CGI-сценарии</li><li>Модуль cgi</li></ol><h1><a id="_Toc454873531"></a><a id="_Toc454109375"></a>Тема 2.5 Файлы</h1><h1><a id="_Toc454873532"></a><a id="_Toc454109376"></a>Лекция 19. Типы файлов. Организация доступа к файлам</h1><p>План:</p><ol><li>Среды разработки </li><li>Zope и его объектная модель</li><li>описание документа Zope</li></ol><p><strong>Среды разработки </strong></p><p>Для создания Web-приложений применяются и более сложные средства, чем webсервер с расположенными на нем статическими документами и CGI-сценариями. В зависимости от назначения такие программные системы называются серверами webприложений, системами управления содержимым (CMS, Content Management System), системы web-публикации и средствами для создания WWW-порталов. Причем CMSсистема может быть выполнена как web-приложение, а средства для создания порталов могут базироваться на системах web-публикации, для которых CMS-система является подсистемой. Поэтому, выбирая систему для конкретных нужд, стоит уточнить, какие функции она должна выполнять. </p><p>Язык Python, хотя и уступает PHP по количеству созданных на нем web-систем, имеет несколько достаточно популярных приложений. Самым ярким примером средства для создания сервера web-приложений является Zope (произносится &quot;зоп&quot;) (см. <a href="http://zope.org/">http://zope.org)</a> (Z Object Publishing Environment, <strong>среда публикации объектов</strong> ). Zope имеет встроенный web-сервер, но может работать и с другими Web-серверами, например, Apache. На основе Zope можно строить web-порталы, например, с помощью Plone/Zope, но можно разрабатывать и собственные web-приложения. При этом Zope позволяет разделить Форму, Содержание и Логику до такой степени, что Содержанием могут заниматься одни люди (менеджеры по содержимому), Формой - другие (webдизайнеры), а Логикой - третьи (программисты). В случае с Zope Логику можно задать с помощью языка Python (или, как вариант, Perl), Форма может быть создана в графических или специализированных web-редакторах, а работа с содержимым организована через Web-формы самого Zope. </p><p><strong>Zope и его объектная модель </strong></p><p>В рамках этой лекции невозможно детально рассмотреть такой инструмент как Zope, поэтому стоит лишь заметить, что он достаточно интересен не только в качестве среды разработки web-приложений, но и с точки зрения подходов. Например, уникальная объектно-ориентированная модель Zope позволяет довольно гибко описывать требуемое приложение. </p><p>Zope включает в себя следующие возможности: </p><ul><li>Web-сервер. Zope может работать с Web-серверами через CGI или использовать свой встроенный Web-сервер (ZServer).  </li><li>Среда разработчика выполнена как Web-приложение. Zope позволяет создавать Web-приложения через Web-интерфейс.  </li><li>Поддержка сценариев. Zope поддерживает несколько языков сценариев: Python, Perl и собственный <strong>DTML</strong> ( <strong>D</strong> ocument <strong>T</strong> emplate <strong>M</strong> arkup <strong>L</strong> anguage, язык разметки шаблона документа).  </li><li>База данных объектов. Zope использует в своей работе устойчивые объекты, хранимые в специальной базе данных (ZODB). Имеется достаточно простой интерфейс для управления этой базой данных.  </li><li>Интеграция с реляционными базами данных. Zope может хранить свои объекты и другие данные в реляционных СУБД: Oracle, PostgreSQL, MySQL, Sybase и т.п. </li></ul><p>В ряду других подобных систем Zope на первый взгляд кажется странным и неприступным, однако тем, кто с ним &quot;на ты&quot;, он открывает большие возможности. </p><p>Разработчики Zope исходили из лежащей в основе WWW объектной модели, в которой загрузку документа по URI можно сравнить с отправкой сообщения объекту. Объекты Zope разложены по папкам (folders), к которым привязаны <strong>политики доступа</strong> для пользователей, имеющих определенные <strong>роли</strong>. В качестве объектов могут выступать документы, изображения, мультимедиа-файлы, адаптеры к базам данных и т.п. </p><p>Документы Zope можно писать на языке DTML - дополнении HTML с синтаксисом для включения значений подобно SSI (Server-Side Include). Например, для вставки переменной с названием документа можно использовать </p><p>&lt;!- #var document_title -&gt; </p><p>Следует заметить, что объекты Zope могут иметь свои атрибуты, а также методы, в частности, написанные на языке Python. Переменные же могут появляться как из заданных пользователем значений, так и из других источников данных (например, из базы данных посредством выполнения выборки функцией SELECT). </p><p>Сейчас для описания документа Zope все чаще применяется <strong>ZPT</strong> ( <strong>Z</strong> ope <strong>P</strong> age <strong>T</strong> emplates, шаблоны страниц Zope), которые в свою очередь используют <strong>TAL</strong> ( <strong>T</strong> emplate <strong>A</strong> ttribute <strong>L</strong> anguage, язык шаблонных атрибутов). Он позволяет заменять, повторять или 	пропускать 	элементы 	документа 	описываемого 	шаблоном 	документа. &quot;Операторами&quot; языка TAL являются XML-атрибуты из пространства имен TAL. Пространство имен сегодня описывается следующим идентификатором: </p><p>xmlns:tal=<a href="http://xml.zope.org/namespaces/tal">http://xml.zope.org/namespaces/tal </a> </p><p>Оператор TAL имеет имя и значение (что выражается именем и значением атрибута). Внутри значения обычно записано TAL-выражение, синтаксис которого описывается другим языком - TALES (Template Attribute Language Expression Syntax, синтаксис выражений TAL). </p><p>Таким образом, ZPT наполняет содержимым шаблоны, интерпретируя атрибуты TAL. Например, чтобы Zope подставил название документа (тег TITLE ), шаблон может иметь следующий код: </p><p>&lt;title tal:content=&quot;here/title&quot;&gt;Doc Title&lt;/title&gt;  </p><p>Стоит заметить, что приведенный код сойдет за код на HTML, то есть, Webдизайнер может на любом этапе работы над проектом редактировать шаблон в HTMLредакторе (при условии, что тот сохраняет незнакомые атрибуты из пространства имен tal). В этом примере here/title является выражением TALES. Текст Doc Title служит ориентиром для web-дизайнера и заменяется значением выражения here/title, то есть, будет взято свойство title документа Zope. </p><p>В качестве более сложного примера можно рассмотреть организацию повтора внутри шаблона (для опробования этого примера в Zope нужно добавить объект Page Template): </p><p>&lt;ul&gt; </p><p>   &lt;li tal:define=&quot;s modules/string&quot;         tal:repeat=&quot;el python:s.digits&quot;&gt;  </p><p>   &lt;a href=&quot;DUMMY&quot; </p><p>      tal:attributes=&quot;href string:/digit/$el&quot;       tal:content=&quot;el&quot;&gt;SELECTION&lt;/a&gt; </p><p>  &lt;/li&gt;  </p><p>&lt;/ul&gt; </p><p> </p><p>Этот шаблон породит следующий результат: </p><p>&lt;ul&gt; </p><p>   &lt;li&gt;&lt;a href=&quot;/digit/0&quot;&gt;0&lt;/a&gt;&lt;/li&gt; </p><p>   &lt;li&gt;&lt;a href=&quot;/digit/1&quot;&gt;1&lt;/a&gt;&lt;/li&gt; </p><p>   &lt;li&gt;&lt;a href=&quot;/digit/2&quot;&gt;2&lt;/a&gt;&lt;/li&gt; </p><p>   &lt;li&gt;&lt;a href=&quot;/digit/3&quot;&gt;3&lt;/a&gt;&lt;/li&gt; </p><p>   &lt;li&gt;&lt;a href=&quot;/digit/4&quot;&gt;4&lt;/a&gt;&lt;/li&gt; </p><p>   &lt;li&gt;&lt;a href=&quot;/digit/5&quot;&gt;5&lt;/a&gt;&lt;/li&gt; </p><p>   &lt;li&gt;&lt;a href=&quot;/digit/6&quot;&gt;6&lt;/a&gt;&lt;/li&gt; </p><p>   &lt;li&gt;&lt;a href=&quot;/digit/7&quot;&gt;7&lt;/a&gt;&lt;/li&gt; </p><p>   &lt;li&gt;&lt;a href=&quot;/digit/8&quot;&gt;8&lt;/a&gt;&lt;/li&gt; </p><p>   &lt;li&gt;&lt;a href=&quot;/digit/9&quot;&gt;9&lt;/a&gt;&lt;/li&gt; </p><p>&lt;/ul&gt; </p><p> </p><p>Здесь нужно обратить внимание на два основных момента: </p><ul><li>в шаблоне можно использовать выражения Python (в данном примере переменная s определена как модуль Python) и переменную-счетчик цикла el, которая проходит итерации по строке string.digits.  </li><li>с помощью TAL можно задавать не только содержимое элемента, но и атрибута тега (в данном примере использовался атрибут href ). </li></ul><p>Детали можно узнать по документации. Стоит лишь заметить, что итерация может происходить по самым разным источникам данных: содержимому текущей папки, выборке из базы данных или, как в приведенном примере, по объекту Python. </p><p>Любой программист знает, что программирование тем эффективнее, чем лучше удалось &quot;расставить скобки&quot;, выведя &quot;общий множитель за скобки&quot;. Другими словами, хорошие программисты должны быть достаточно &quot;ленивы&quot;, чтобы найти оптимальную декомпозицию решаемой задачи. При проектировании динамического web-сайта Zope позволяет разместить &quot;множители&quot; и &quot;скобки&quot; так, чтобы достигнуть максимального повторного использования кода (как разметки, так и сценариев). Помогает этому уникальный подход к построению взаимоотношений между объектами: заимствование ( <strong>acquisition</strong> ). </p><p>Пусть некоторый объект (документ, изображение, сценарий, подключение к базе данных и т.п.) расположен в папке Example. Теперь объекты этой папки доступны по имени из любых нижележащих папок. Даже политики безопасности заимствуются более глубоко вложенными папками от папок, которые ближе к корню. Заимствование является очень важной концепцией Zope, без понимания которой Zope сложно грамотно применять, и наоборот, ее понимание позволяет экономить силы и время, повторно используя объекты в разработке. </p><p>Самое интересное, что заимствовать объекты можно также из параллельных папок. Пусть, например, рядом с папкой Example находится папка Zigzag, в которой лежит нужный объект (его наименование note). При этом в папке Example программиста интересует объект index_html, внутри которого вызывается note. Обычный путь к объекту index_html будет происходить по URI вроде http://zopeserver/Example/. А вот если нужно использовать note из Zigzag (и в папке Example его нет), то URI будет: http://zopeserver/Zigzag/Example/. Таким образом, указание пути в Zope отличается от традиционного пути, скажем, в Unix: в пути могут присутствовать &quot;зигзаги&quot; через параллельные папки, дающие возможность заимствовать объекты из этих папок. Таким образом, можно сделать конкретную страницу, комбинируя один или несколько независимых аспектов.</p><p>Вопросы:</p><ol><li>Среды разработки </li><li>Zope и его объектная модель</li><li>описание документа Zope</li></ol><h1><a id="_Toc454873533"></a><a id="_Toc454109377"></a>Лекция 20. Файлы произвольного доступа. Порядок работы.</h1><p>План:</p><ol><li>Работа с сокетами </li><li>Модуль smtplib</li><li>Модуль poplib</li></ol><p><strong>Работа с сокетами </strong></p><p>Применяемая в IP-сетях архитектура клиент-сервер использует IP-пакеты для коммуникации между клиентом и сервером. Клиент отправляет запрос серверу, на который тот отвечает. В случае с TCP/IP между клиентом и сервером устанавливается соединение (обычно с двусторонней передачей данных), а в случае с UDP/IP - клиент и сервер обмениваются пакетами (дейтаграммамми) с негарантированной доставкой. </p><p>Каждый сетевой интерфейс IP-сети имеет уникальный в этой сети адрес ( <strong>IP-адрес</strong> ). Упрощенно можно считать, что каждый компьютер в сети Интернет имеет собственный IP-адрес. При этом в рамках одного сетевого интерфейса может быть несколько сетевых <strong>портов</strong>. Для установления сетевого соединения приложение клиента должно выбрать свободный порт и установить соединение с серверным приложением, которое слушает (listen) порт с определенным номером на удаленном сетевом интерфейсе. Пара IP-адрес и порт характеризуют <strong>сокет</strong> (гнездо) - начальную (конечную) точку сетевой коммуникации. Для создания соединения TCP/IP необходимо два сокета: один на локальной машине, а другой - на удаленной. Таким образом, каждое сетевое соединение имеет IP-адрес и порт на локальной машине, а также IPадрес и порт на удаленной машине. </p><p>Модуль socket обеспечивает возможность работать с сокетами из Python. Сокеты используют транспортный уровень согласно семиуровневой модели OSI (Open Systems Interconnection, взаимодействие открытых систем), то есть относятся к более низкому уровню, чем большинство описываемых в этом разделе протоколов. </p><p>Каждый сокет относится к одному из коммуникационных доменов. Модуль socket поддерживает домены UNIX и Internet. Каждый домен подразумевает свое семейство протоколов и адресацию. Данное изложение будет затрагивать только домен Internet, а именно протоколы TCP/IP и UDP/IP, поэтому для указания коммуникационного домена при создании сокета будет указываться константа socket.AF_INET. </p><p>В качестве примера следует рассмотреть простейшую клиент-серверную пару. Сервер будет принимать строку и отвечать клиенту. Сетевое устройство иногда называют хостом (host), поэтому будет употребляться этот термин по отношению к компьютеру, на котором работает сетевое приложение. </p><p>Сервер: </p><p>import socket, string </p><p> def do_something(x):   lst = map(None, x);   lst.reverse(); </p><p>  return string.join(lst, &quot;&quot;) </p><p> </p><p>HOST = &quot;&quot;                 # localhost PORT = 33333 </p><p>srv = socket.socket(socket.AF_INET, socket.SOCK_STREAM) srv.bind((HOST, PORT)) while 1: </p><p>  print &quot;Слушаю порт 33333&quot;   srv.listen(1)                sock, addr = srv.accept()   while 1: </p><p>    pal = sock.recv(1024)     if not pal:  </p><p>      break </p><p>    print &quot;Получено от %s:%s:&quot; % addr, pal     lap = do_something(pal) </p><p>    print &quot;Отправлено %s:%s:&quot; % addr, lap     sock.send(lap)   sock.close() Клиент: </p><p>import socket </p><p> </p><p>HOST = &quot;&quot;                 # удаленный компьютер (localhost) PORT = 33333              # порт на удаленном компьютере sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sock.connect((HOST, PORT)) sock.send(&quot;ПАЛИНДРОМ&quot;) result = sock.recv(1024) </p><p>sock.close() </p><p>print &quot;Получено:&quot;, result  </p><p>Примечание: </p><p><strong>Модуль smtplib </strong></p><p>Сообщения электронной почты в Интернете передаются от клиента к серверу и между серверами в основном по протоколу <strong>SMTP</strong> ( <strong>S</strong> imple <strong>M</strong> ail <strong>T</strong> ransfer <strong>P</strong> rotocol, простой протокол передачи почты). Протокол SMTP и ESMTP (расширенный вариант SMTP) описаны в <a href="http://www.faqs.org/rfcs/rfc821.html">RFC 821 </a>и <a href="http://www.faqs.org/rfcs/rfc821.html">RFC 1869.</a> Для работы с SMTP в стандартной библиотеке модулей имеется модуль smtplib. Для того чтобы начать SMTP-соединение с сервером электронной почты, необходимо в начале создать объект для управления SMTP-сессией с помощью конструктора класса SMTP: </p><p>smtplib.SMTP([host[, port]]) </p><p>Параметры host и port задают адрес и порт SMTP-сервера, через который будет отправляться почта. По умолчанию, port=25. Если host задан, конструктор сам установит соединение, иначе придется отдельно вызывать метод connect(). Экземпляры класса SMTP имеют методы для всех распространенных команд SMTPпротокола, но для отправки почты достаточно вызова конструктора и методов sendmail() и quit(): </p><p><strong>Модуль poplib </strong></p><p>Еще один протокол - <strong>POP3</strong> ( <strong>P</strong> ost <strong>O</strong> ffice <strong>P</strong> rotocol, почтовый протокол) - служит для приема почты из почтового ящика на сервере (протокол определен в RFC 1725). </p><p>Для работы с почтовым сервером требуется установить с ним соединение и, подобно рассмотренному выше примеру, с помощью SMTP-команд получить требуемые сообщения. Объект-соединение POP3 можно установить посредством конструктора класса POP3 из модуля poplib: </p><p>poplib.POP3(host[, port]) </p><p>Где host - адрес POP3-сервера, port - порт на сервере (по умолчанию 110), pop_obj - объект для управления сеансом работы с POP3-сервером. </p><p>Следующий пример демонстрирует основные методы для работы с POP3соединением: </p><p>import poplib, email </p><p># Учетные данные пользователя: </p><p>SERVER = &quot;pop.server.com&quot; </p><p>USERNAME = &quot;user&quot; </p><p>USERPASSWORD = &quot;secretword&quot;  </p><p> p = poplib.POP3(SERVER) print p.getwelcome() # этап идентификации print p.user(USERNAME) print p.pass_(USERPASSWORD) </p><p># этап транзакций </p><p>response, lst, octets = p.list() print response for msgnum, msgsize in [i.split() for i in lst]:   print &quot;Сообщение %(msgnum)s имеет длину %(msgsize)s&quot; % vars()   print &quot;UIDL =&quot;, p.uidl(int(msgnum)).split()[2]   if int(msgsize) &gt; 32000: </p><p>    (resp, lines, octets) = p.top(msgnum, 0)   else: </p><p>    (resp, lines, octets) = p.retr(msgnum)   msgtxt = &quot;\n&quot;.join(lines)+&quot;\n\n&quot;   msg = email.message_from_string(msgtxt) </p><p>  print &quot;* От: %(from)s\n* Кому: %(to)s\n* Тема: %(subject)s\n&quot; % msg   # msg содержит заголовки сообщения или все сообщение (если оно небольшое)  </p><p># этап обновления print p.quit() </p><p>При выполнении сценарий выведет на экран примерно следующее. </p><p>+OK POP3 pop.server.com server ready </p><p>+OK User name accepted, password please </p><p>+OK Mailbox open, 68 messages </p><p>+OK Mailbox scan listing follows </p><p>Сообщение 1 имеет длину 4202 </p><p>UIDL = 4152a47e00000004 </p><ul><li>От: online@kaspersky.com </li><li>Кому: user@server.com * Тема: KL Online Activation  ... </li></ul><p> +OK Sayonara </p><p> </p><p>Вопросы:</p><ol><li>Работа с сокетами </li><li>Модуль smtplib</li><li>Модуль poplib</li></ol><h1><a id="_Toc454873534"></a><a id="_Toc454109378"></a>Лекция 21. Стандартные процедуры и функции для файлов разного типа</h1><p>План:</p><ol><li>Модули для клиента WWW </li><li>Функции для загрузки сетевых объектов</li><li>Функции для анализа URL</li><li>Возможности urllib2</li></ol><p><strong>Модули для клиента WWW </strong></p><p>Стандартные средства языка Python позволяют получать из программы доступ к объектам WWW как в простых случаях, так и при сложных обстоятельствах, в частности при необходимости передавать данные формы, идентификации, доступа через прокси и т.п. </p><p>Стоит отметить, что при работе с WWW используется в основном протокол HTTP, однако WWW охватывает не только HTTP, но и многие другие схемы (FTP, gopher, HTTPS и т.п.). Используемая схема обычно указана в самом начале URL. </p><p><strong>Функции для загрузки сетевых объектов </strong></p><p>Простой случай получения WWW-объекта по известному URL показан в следующем примере: </p><p>import urllib </p><p>doc = urllib.urlopen(&quot;http://python.onego.ru&quot;).read() print doc[:40] </p><p>Функция urllib.urlopen() создает файлоподобный объект, который читает методом read(). Другие методы этого объекта: readline(), readlines(), fileno(), close() работают как и у обычного файла, а также есть метод info(), который возвращает соответствующий полученному с сервера Message-объект. Этот объект можно использовать для получения дополнительной информации: </p><p>&gt;&gt;&gt; import urllib </p><p>&gt;&gt;&gt; f = urllib.urlopen(&quot;http://python.onego.ru&quot;) </p><p>&gt;&gt;&gt; print f.info() </p><p>Date: Sat, 25 Dec 2004 19:46:11 GMT </p><p>Server: Apache/1.3.29 (Unix) PHP/4.3.10 </p><p>Content-Type: text/html; charset=windows-1251 </p><p>Content-Length: 4291 </p><p>&gt;&gt;&gt; print f.info()['Content-Type'] text/html; charset=windows-1251 </p><p>С помощью функции urllib.urlopen() можно делать и более сложные вещи, например, передавать web-серверу данные формы. Как известно, данные заполненной web-формы могут быть переданы на web-сервер с использованием метода GET или метода POST. Метод GET связан с кодированием всех передаваемых параметров после знака &quot;?&quot; в URL, а при методе POST данные передаются в теле HTTP-запроса. Оба варианта передачи представлены ниже: </p><p>import urllib </p><p>data = {&quot;search&quot;: &quot;Python&quot;} enc_data = urllib.urlencode(data) </p><p> </p><p># метод GET </p><p>f = urllib.urlopen(&quot;http://searchengine.com/search&quot; + &quot;?&quot; + enc_data) print f.read() </p><p> </p><p># метод POST </p><p>f = urllib.urlopen(&quot;http://searchengine.com/search&quot;, enc_data) print f.read() </p><p>В некоторых случаях данные имеют повторяющиеся имена. В этом случае в качестве параметра 	urllib.urlencode() 	можно 	использовать 	вместо 	словаря последовательность пар имя-значение: </p><p>&gt;&gt;&gt; import urllib </p><p>&gt;&gt;&gt; data = [(&quot;n&quot;, &quot;1&quot;), (&quot;n&quot;, &quot;3&quot;), (&quot;n&quot;, &quot;4&quot;), (&quot;button&quot;, &quot;Привет&quot;),] </p><p>&gt;&gt;&gt; enc_data = urllib.urlencode(data) </p><p>&gt;&gt;&gt; print enc_data </p><p>n=1&amp;n=3&amp;n=4&amp;button=%F0%D2%C9%D7%C5%D4 </p><p>Модуль urllib позволяет загружать web-объекты через прокси-сервер. Если ничего не указывать, будет использоваться прокси-сервер, который был задан принятым в конкретной ОС способом. В Unix прокси-серверы задаются в переменных окружения http_proxy, ftp_proxy и т.п., в Windows прокси-серверы записаны в реестре, а в Mac OS они берутся из конфигурации Internet. Задать прокси-сервер можно и как именованный параметр proxies к urllib.urlopen(): </p><p># Использовать указанный прокси </p><p>proxies = {'http': 'http://www.proxy.com:3128'} f = urllib.urlopen(some_url, proxies=proxies) </p><p># Не использовать прокси </p><p>f = urllib.urlopen(some_url, proxies={}) # Использовать прокси по умолчанию f = urllib.urlopen(some_url, proxies=None) f = urllib.urlopen(some_url) </p><p><strong>Функции для анализа URL </strong></p><p>Согласно документу RFC 2396 URL должен строиться по следующему шаблону: </p><p>scheme://netloc/path;parameters?query#fragment где </p><p>scheme </p><p>Адресная схема. Например: http, ftp, gopher. </p><p>netloc </p><p>Местонахождение в сети. </p><p>path </p><p>Путь к ресурсу. </p><p>params Параметры. </p><p>query </p><p>Строка запроса. </p><p>fragment </p><p>Идентификатор фрагмента. </p><p>Одна из функций уже использовалась для формирования URL - urllib.urlencode(). Кроме нее в модуле urllib имеются и другие функции: </p><p>quote(s, safe='/') </p><p>Функция экранирует символы в URL, чтобы их можно было отправлять на webсервер. Она предназначена для экранирования пути к ресурсу, поэтому оставляет '/' как есть. Например: </p><p>&gt;&gt;&gt; urllib.quote(&quot;rnd@onego.ru&quot;) </p><p>'rnd%40onego.ru' </p><p>&gt;&gt;&gt; urllib.quote(&quot;a = b + c&quot;) </p><p>'a%20%3D%20b%20%2B%20c' </p><p>&gt;&gt;&gt; urllib.quote(&quot;0/1/1&quot;) </p><p>'0/1/1' </p><p>&gt;&gt;&gt; urllib.quote(&quot;0/1/1&quot;, safe=&quot;&quot;) </p><p>'0%2F1%2F1' </p><p>quote_plus(s, safe='') </p><p>Функция экранирует некоторые символы в URL (в строке запроса), чтобы их можно было отправлять на web-сервер. Аналогична quote(), но заменяет пробелы на плюсы. </p><p>unquote(s) </p><p>Преобразование, обратное quote(). Пример: </p><p>&gt;&gt;&gt; urllib.unquote('a%20%3D%20b%20%2B%20c') </p><p>'a = b + c' </p><p>Преобразование, обратное quote_plus(). Пример: </p><p>&gt;&gt;&gt; urllib.unquote_plus('a+=+b+%2B+c') </p><p>'a = b + c' </p><p>Для анализа URL можно использовать функции из модуля urlparse: </p><p>urlparse(url, scheme='', allow_fragments=1) </p><p>Разбирает 	URL 	в 	6 	компонентов 	(сохраняя 	экранирование 	символов): scheme://netloc/path;params?query#frag </p><p>urlsplit(url, scheme='', allow_fragments=1) </p><p>Разбирает 	URL 	в 	5 	компонентов 	(сохраняя 	экранирование 	символов): scheme://netloc/path?query#frag </p><p>urlunparse((scheme, netloc, url, params, query, fragment)) Собирает URL из 6 компонентов. </p><p>urlunsplit((scheme, netloc, url, query, fragment)) Собирает URL из 5 компонентов. </p><p>Пример: </p><p>&gt;&gt;&gt; from urlparse import urlsplit, urlunsplit </p><p>&gt;&gt;&gt; URL = &quot;http://google.com/search?q=Python&quot; </p><p>&gt;&gt;&gt; print urlsplit(URL) </p><p>('http', 'google.com', '/search', 'q=Python', '') </p><p>&gt;&gt;&gt; print urlunsplit( </p><p>...     ('http', 'google.com', '/search', 'q=Python', '')) </p><p>http://google.com/search?q=Python </p><p>Еще одна функция того же модуля urlparse позволяет корректно соединить две части URL - базовую и относительную: </p><p>&gt;&gt;&gt; import urlparse </p><p>&gt;&gt;&gt; urlparse.urljoin('http://python.onego.ru', 'itertools.html') </p><p>'http://python.onego.ru/itertools.html' </p><p><strong>Возможности urllib2 </strong></p><p>Функциональности модулей urllib и urlparse хватает для большинства задач, которые решают сценарии на Python как web-клиенты. Тем не менее, иногда требуется больше. На этот случай можно использовать модуль для работы с протоколом HTTP - httplib - и создать собственный класс для HTTP-запросов (в лекциях модуль httplib не рассматривается). Однако вполне вероятно, что нужная функциональность уже имеется в модуле urllib2. </p><p>Одна из полезных возможностей этих модулей - доступ к web-объектам, требующий авторизации. Ниже будет рассмотрен пример, который не только обеспечит доступ с авторизацией, но и обозначит основную идею модуля urllib2: использование обработчиков (handlers), каждый из которых решает узкую специфическую задачу. </p><p>Вопросы:</p><ol><li>Модули для клиента WWW </li><li>Функции для загрузки сетевых объектов</li><li>Функции для анализа URL</li><li>Возможности urllib2</li></ol><h1><a id="_Toc454873535"></a><a id="_Toc454109379"></a>Лекция 22. Типизированный файл, запись/чтение</h1><p>План:</p><ol><li>DB-API 2 </li><li>Объект-соединение</li><li>Объект-курсор</li><li>Объекты-типы</li></ol><p><strong>Что такое DB-API 2 </strong></p><p>Вынесенная в заголовок аббревиатура объединяет два понятия: DB (Database, база данных) и API (Application Program Interface, интерфейс прикладной программы). </p><p>Таким образом, DB-API определяет интерфейс прикладной программы с базой данных. Этот интерфейс, описываемый ниже, должен реализовывать все модули расширения, которые служат для связи Python-программ с базами данных. Единый API (в настоящий момент его вторая версия) позволяет абстрагироваться от марки используемой базы данных, при необходимости довольно легко менять одну СУБД на другую, изучив всего один набор функций и методов. </p><p>DB-API 2.0 описан в <a href="http://www.python.org/dev/peps/pep-0249/">PEP 249,</a> и данное ниже описание основано именно на нем. </p><p><strong>Описание DB API 2.0 </strong></p><p>DB API 2.0 регламентирует интерфейсы модуля расширения для работы с базой данных, методы объекта-соединения с базой, объекта-курсора текущей обрабатываемой записи, объектов различных для типов данных и их конструкторов, а также содержит рекомендации для разработчиков по реализации модулей. На сегодня Python поддерживает через модули расширения многие известные базы данных (уточнить можно на web-странице по <a href="http://www.python.org/topics/database/">этому </a>адресу). Ниже рассматриваются почти все положения DB-API за исключением рекомендаций для разработчиков новых модулей. </p><p><strong>Объект-соединение </strong></p><p>Объект-соединение, получаемый в результате успешного вызова функции connect(), должен иметь следующие методы: </p><ul><li>close() Закрывает соединение с базой данных.  </li><li>commit() Завершает транзакцию.  </li><li>rollback() Откатывает начатую транзакцию (восстанавливает исходное состояние). Закрытие соединения при незавершенной транзакции автоматически производит откат транзакции.  </li><li>cursor() Возвращает объект-курсор, использующий данное соединение. Если база данных не поддерживает курсоры, модуль сопряжения должен их имитировать. </li></ul><p>Под <strong>транзакцией</strong> понимается группа из одной или нескольких операций, которые изменяют базу данных. Транзакция соответствует логически неделимой операции над базой данных, а частичное выполнение транзакции приводит к нарушению целостности БД. Например, при переводе денег с одного счета на другой операции по уменьшению первого счета и увеличению второго являются транзакцией. Методы commit() и rollback() обозначают начало и конец транзакции в явном виде. Кстати, не все базы данных поддерживают механизм транзакций. </p><p>Следует отметить, что в зависимости от реализации DB-API 2.0 модуля, необходимо сохранять ссылку на объект-соединение в продолжение работы курсоров этого соединения. В частности, это означает, что нельзя сразу же получать объект-курсор, не привязывая объект-соединение к некоторому имени. Также нельзя оставлять объектсоединение в локальной переменной, возвращая из функции или метода объекткурсор. </p><p><strong>Объект-курсор </strong></p><p>Курсор (от англ. cursor - CURrrent Set Of Records, текущий набор записей) служит для работы с результатом запроса. Результатом запроса обычно является одна или несколько прямоугольных таблиц со столбцами-полями и строками-записями. Приложение может читать и обрабатывать полученные таблицы и записи в таблице по одной, поэтому в курсоре хранится информация о текущей таблице и записи. Конкретный курсор в любой момент времени связан с выполнением одной SQLинструкции. </p><p>Атрибуты объекта-курсора тоже определены DB-API: </p><ul><li>arraysize Атрибут, равный количеству записей, возвращаемых методом fetchmany(). По умолчанию равен 1.  </li><li>callproc(procname[, params]) Вызывает хранимую процедуру procname с параметрами из изменчивой последовательности params. Хранимая процедура может изменить значения некоторых параметров последовательности. Метод может возвратить результат, доступ к которому осуществляется через fetch методы.  </li><li>close() Закрывает объект-курсор.  </li><li>description Этот доступный только для чтения атрибут является последовательностью из семиэлементных последовательностей. Каждая из этих последовательностей содержит информацию, описывающую один столбец результата:  </li></ul><p>(name, type_code, display_size, internal_size, precision, scale, null_ok) </p><p>Первые два элемента (имя и тип) обязательны, а вместо остальных (размер для вывода, внутренний размер, точность, масштаб, возможность задания пустого значения) может быть значение None. Этот атрибут может быть равным None для операций, не возвращающих значения.  </p><ul><li>execute(operation[, parameters]) Исполняет запрос к базе данных или команду СУБД. Параметры ( parameters ) могут быть представлены в принятой в базе данных нотации в соответствии с атрибутом paramstyle, описанным выше.  </li><li>executemany(operation, seq_of_parameters) Выполняет серию запросов или команд, подставляя параметры в заданный шаблон. Параметр seq_of_parameters задает последовательность наборов параметров.  </li><li>fetchall() Возвращает все (или все оставшиеся) записи результата запроса.  </li><li>fetchmany([size]) Возвращает следующие несколько записей из результатов запроса в виде последовательности последовательностей. Пустая последовательность означает отсутствие данных. Необязательный параметр size указывает количество возвращаемых записей (реально возвращаемых записей может быть меньше). По умолчанию size равен атрибуту arraysize объектакурсора.  </li><li>fetchone() Возвращает следующую запись (в виде последовательности) из результата запроса или None при отсутствии данных.  </li><li>nextset() Переводит курсор к началу следующего набора данных, полученного в результате запроса (при этом часть записей в предыдущем наборе может остаться непрочитанной). Если наборов больше нет, возвращает None. Не все базы данных поддерживают возврат нескольких наборов результатов за одну операцию.  </li><li>rowcount Количество записей, полученных или затронутых в результате выполнения последнего запроса. В случае отсутствия execute-запросов или невозможности указать количество записей равен -1.  </li><li>setinputsizes(sizes) Предопределяет области памяти для параметров, используемых в операциях. Аргумент sizes задает последовательность, где каждый элемент соответствует одному входному параметру. Элемент может быть объектом-типом соответствующего параметра или целым числом, задающим длину строки. Он также может иметь значение None, если о размере входного параметра ничего нельзя сказать заранее или он предполагается очень большим. Метод должен быть вызван до execute-методов.  </li><li>setoutputsize(size[, column]) Устанавливает размер буфера для выходного параметра из столбца с номером column. Если column не задан, метод устанавливает размер для всех больших выходных параметров. Может использоваться, например, для получения <strong>больших бинарных объектов</strong> ( <strong>B</strong> inary <strong>L</strong> arge <strong>O</strong> bject, <strong>BLOB</strong> ). </li></ul><p><strong>Объекты-типы </strong></p><p>DB-API 2.0 предусматривает названия для объектов-типов, используемых для описания полей базы данных: </p><table><tr><td><p><strong>Объект </strong></p></td><td><p><strong>Тип </strong></p></td></tr><tr><td><p>STRING </p></td><td><p>Строка и символ </p></td></tr><tr><td><p>BINARY </p></td><td><p>Бинарный объект </p></td></tr><tr><td><p>NUMBER </p></td><td><p>Число </p></td></tr><tr><td><p>DATETIME </p></td><td><p>Дата и время </p></td></tr><tr><td><p>ROWID </p></td><td><p>Идентификатор записи </p></td></tr><tr><td><p>None </p></td><td><p>NULL-значение (отсутствующее значение)</p></td></tr></table><p>С каждым типом данных (в реальности это - классы) связан конструктор. Совместимый с DB-API модуль должен определять следующие конструкторы: </p><ul><li>Date(год, месяц, день) Дата.  </li><li>Time(час, минута, секунда) Время.  </li><li>Timestamp(год, месяц, день, час, минута, секунда) Дата-время.  </li><li>DateFromTicks(secs) Дата в виде числа секунд secs от начала эпохи (1 января 1970 года).  </li><li>TimeFromTicks(secs) Время, то же.  </li><li>TimestampFromTicks(secs) Дата-время, то же.  </li><li>Binary(string) Большой бинарный объект на основании строки string. </li></ul><p>Вопросы:</p><ol><li>DB-API 2 </li><li>Объект-соединение</li><li>Объект-курсор</li><li>Объекты-типы</li></ol><h1><a id="_Toc454873536"></a><a id="_Toc454109380"></a>Лекция 23. Простейшая обработка элементов файла последовательного доступа</h1><p>План:</p><ol><li>Работа с базой данных из Python-приложения </li><li>Знакомство с СУБД</li><li>Создание базы данных</li><li>Наполнение базы данных</li></ol><p><strong>Работа с базой данных из Python-приложения </strong></p><p>Далее в лекции на конкретных примерах будет показано, как работать с базой данных из программы на языке Python. Нужно отметить, что здесь не ставится цели постичь премудрости языка запросов (это тема отдельного курса). Простые примеры позволят понять, что при программировании на Python доступ к базе данных не сложнее доступа к другим источникам данных (файлам, сетевым объектам). </p><p>Именно поэтому для демонстрации выбрана СУБД SQLite, работающая как под Unix, так и под Windows. Кроме установки собственно <a href="http://sqlite.org/">SQLite </a>и модуля сопряжения с <a href="http://pysqlite.org/">Python,</a> каких-либо дополнительных настроек проводить не требуется, так как SQLite хранит данные базы в отдельном файле: сразу приступать к созданию таблиц, занесению в них данных и произведению запросов нельзя. Выбранная СУБД (в силу своей &quot;легкости&quot;) имеет одну существенную особенность: за одним небольшим исключением, СУБД SQLite не обращает внимания на типы данных (она хранит все данные в виде строк), поэтому модуль расширения sqlite для Python проделывает дополнительную работу по преобразованию типов. Кроме того, СУБД SQLite поддерживает достаточно большое подмножество свойств стандарта SQL92, оставаясь при этом небольшой и быстрой, что немаловажно, например, для web-приложений. Достаточно сказать, что SQLite поддерживает даже транзакции. </p><p>Еще раз стоит повторить, что выбор учебной базы данных не влияет на синтаксис использованных средств, так как модуль sqlite, который будет использоваться, поддерживает DB-API 2.0, а значит, переход на любую другую СУБД потребует минимальных изменений в вызове функции connect() и, возможно, использования более удачных типов данных, свойственных целевой СУБД. </p><p>Схематично работа с базой данных может выглядеть примерно так: </p><ul><li>Подключение к базе данных (вызов connect() с получением объектасоединения).  </li><li>Создание одного или нескольких курсоров (вызов метода объектасоединения cursor() с получением объекта-курсора).  </li><li>Исполнение команды или запроса (вызов метода execute() или его вариантов).  </li><li>Получение результатов запроса (вызов метода fetchone() или его вариантов).  </li><li>Завершение транзакции или ее откат (вызов метода объекта-соединения commit() или rollback() ).  </li><li>Когда все необходимые транзакции произведены, подключение закрывается вызовом метода close() объекта-соединения. </li></ul><p><strong>Знакомство с СУБД </strong></p><p>Допустим, программное обеспечение установлено правильно, и можно работать с модулем sqlite. Стоит посмотреть, чему будут равны константы: </p><p>&gt;&gt;&gt; import sqlite </p><p>                &gt;&gt;&gt; sqlite.apilevel </p><p>                '2.0' </p><p>                &gt;&gt;&gt; sqlite.paramstyle </p><p>                'pyformat' </p><p>                &gt;&gt;&gt; sqlite.threadsafety </p><p>                1 </p><p>Отсюда следует, что sqlite поддерживает DB-API 2.0, подстановка параметров выполняется в стиле строки форматирования языка Python, а соединения нельзя совместно использовать из различных потоков управления (без блокировок). </p><p><strong>Создание базы данных </strong></p><p>Для создания базы данных нужно установить, какие таблицы (и другие объекты, например индексы) в ней будут храниться, а также определить структуры таблиц (имена и типы полей). </p><p>Задача - создание базы данных, в которой будет храниться телепрограмма. В этой базе будет таблица со следующими полями: </p><ul><li>tvdate,  </li><li>tvweekday,  </li><li>tvchannel,  </li><li>tvtime1,  </li><li>tvtime2,  </li><li>prname,  </li><li>prgenre. </li></ul><p>Здесь tvdate - дата, tvchannel - канал, tvtime1 и tvtime2 - время начала и конца передачи, prname - название, prgenre - жанр. Конечно, в этой таблице есть функциональная зависимость ( tvweekday вычисляется на основе tvdate и tvtime1 ), но из практических соображений БД к нормальным формам приводиться не будет. </p><p><strong>Наполнение базы данных </strong></p><p>Теперь можно наполнить таблицы значениями. Следует начать с расшифровки числовых значений для дней недели: </p><p>weekdays = [&quot;Воскресенье&quot;, &quot;Понедельник&quot;, &quot;Вторник&quot;, &quot;Среда&quot;, </p><p>                            &quot;Четверг&quot;, 	&quot;Пятница&quot;, 	&quot;Суббота&quot;, &quot;Воскресенье&quot;] </p><p> </p><p>                import sqlite as db </p><p> </p><p>                c = db.connect(database=&quot;tvprogram&quot;)                 cu = c.cursor() </p><p>                cu.execute(&quot;&quot;&quot;DELETE FROM wd;&quot;&quot;&quot;) </p><p>                cu.executemany(&quot;&quot;&quot;INSERT INTO wd VALUES (%s, %s);&quot;&quot;&quot;,                            enumerate(weekdays)) </p><p>                c.commit() </p><p>                c.close() </p><p>Стоит напомнить, что встроенная функция enumerate() создает список пар номерзначение, например: </p><p>&gt;&gt;&gt; print [i for i in enumerate(['a', 'b', 'c'])] </p><p>                [(0, 'a'), (1, 'b'), (2, 'c')] </p><p>Из приведенного примера ясно, что метод executemany() объекта-курсора использует второй параметр - последовательность - для массового ввода данных с помощью SQL-инструкции INSERT. </p><p>Предположим, что телепрограмма задана в файле tv.csv в формате CSV (он уже обсуждался): </p><p>10.02.2003 9.00|ОРТ|Новости|Новости|9.15 </p><p>                10.02.2003 9.15|ОРТ|&quot;НЕЖНЫЙ ЯД&quot;|Сериал|10.15 </p><p>                10.02.2003 	10.15|ОРТ|&quot;Маски-шоу&quot;|Юмористическая программа|10.45 </p><p>                10.02.2003 10.45|ОРТ|&quot;Человек и закон&quot;||11.30 </p><p>	                10.02.2003 	11.30|ОРТ|&quot;НОВЫЕ 	ПРИКЛЮЧЕНИЯ </p><p>СИНДБАДА&quot;|Сериал|12.00 </p><p>Следующая программа разбирает CSV-файл и записывает данные в таблицу tv: </p><p>import calendar, csv </p><p>                import sqlite as db </p><p>                from sqlite.main import Time, Date  ## Только для                 db.Date, db.Time = Date, Time       ## sqlite </p><p> </p><p>                c = db.connect(database=&quot;tvprogram&quot;)                 cu = c.cursor() </p><p>                 input_file = open(&quot;tv.csv&quot;, &quot;rb&quot;)                 rdr = csv.DictReader(input_file, </p><p>	                          fieldnames=['begt', 	'channel', 	'prname', </p><p>'prgenre', 'endt'])                 for rec in rdr: </p><p>                    bd, bt = rec['begt'].split()                     bdd, bdm, bdy = map(int, bd.split('.'))                     bth, btm = map(int, bt.split('.'))                     eth, etm = map(int, rec['endt'].split('.'))                     rec['wd'] = calendar.weekday(bdy, bdm, bdd)                     rec['begd'] = db.Date(bdy, bdm, bdd)                     rec['begt'] = db.Time(bth, btm, 0)                     rec['endt'] = db.Time(eth, etm, 0) </p><p> </p><p>                    cu.execute(&quot;&quot;&quot;INSERT INTO tv </p><p>                    (tvdate, tvweekday, tvchannel, tvtime1, tvtime2, prname, prgenre) </p><p>                    VALUES ( </p><p>                    %(begd)s, %(wd)s, %(channel)s, %(begt)s, %(endt)s, </p><p>                    %(prname)s, %(prgenre)s);&quot;&quot;&quot;, rec)                 input_file.close() </p><p>                c.commit() </p><p>Большая часть преобразований связана с получением дат и времен (приходится разбивать строки на части в соответствии с форматом даты и времени). День недели получен с помощью функции из модуля calendar. </p><p>Вопросы:</p><ol><li>Работа с базой данных из Python-приложения </li><li>Знакомство с СУБД</li><li>Создание базы данных</li><li>Наполнение базы данных</li></ol><h1><a id="_Toc454873537"></a><a id="_Toc454109381"></a>Лекция 24. Работа с несколькими файлами</h1><p>План:</p><ol><li>Потоки управления </li><li>семафоры</li><li>многопоточные программы</li></ol><p><strong>О потоках управления </strong></p><p>В современной операционной системе, даже не выполняющей ничего особенного, могут одновременно работать несколько <strong>процессов</strong> (processes). Например, при запуске программы запускается новый процесс. Функции для управления процессами можно найти в стандартном модуле os языка Python. Здесь же речь пойдет о потоках. </p><p><strong>Потоки управления</strong> (threads) образуются и работают в рамках одного процесса. В однопоточном приложении (программе, которая не использует дополнительных потоков) имеется только один поток управления. Говоря упрощенно, при запуске программы этот поток последовательно исполняет встречаемые в программе операторы, направляясь по одной из альтернативных ветвей оператора выбора, проходит через тело цикла нужное число раз, выбирается к месту обработки исключения при возбуждении исключения. В любой момент времени интерпретатор Python знает, какую команду исполнить следующей. После исполнения команды становится известно, какой команде передать управление. Эта ниточка непрерывна в ходе выполнения программы и обрывается только по ее завершении. </p><p>Теперь можно представить себе, что в некоторой точке программы ниточка раздваивается, и каждый поток идет своим путем. Каждый из образовавшихся потоков может в дальнейшем еще несколько раз раздваиваться. (При этом один из потоков всегда остается главным, и его завершение означает завершение всей программы.) В каждый момент времени интерпретатор знает, какую команду какой поток должен выполнить, и уделяет кванты времени каждому потоку. Такое, казалось бы, незначительное усложнение механизма выполнения программы на самом деле требует качественных изменений в программе - ведь деятельность потоков должна быть согласована. Нельзя допускать, чтобы потоки одновременно изменяли один и тот же объект, результат такого изменения, скорее всего, нарушит целостность объекта. </p><p>Одним из классических средств согласования потоков являются объекты, называемые <strong>семафорами</strong>. Семафоры не допускают выполнения некоторого участка кода несколькими потоками одновременно. Самый простой семафор - <strong>замок</strong> (lock) или <strong>mutex</strong> (от английского mutually exclusive, взаимоисключающий). Для того чтобы поток мог продолжить выполнение кода, он должен сначала захватить замок. После захвата замка поток выполняет определенный участок кода и потом освобождает замок, чтобы другой поток мог его получить и пройти дальше к выполнению охраняемого замком участку программы. Поток, столкнувшись с занятым другим потоком замком, обычно ждет его освобождения. </p><p>Поддержка многопоточности в языке Python доступна через использование ряда модулей. В стандартном модуле threading определены нужные для разработки многопоточной (multithreading) программы классы: несколько видов семафоров (классы замков Lock, RLock и класс Semaphore ) и другие механизмы взаимодействия между потоками (классы Event и Condition ), класс Timer для запуска функции по прошествии некоторого времени. Модуль Queue реализует очередь, которой могут пользоваться сразу несколько потоков. Для создания и (низкоуровневого) управления потоками в стандартном модуле thread определен класс Thread. </p><p><strong> 	 </strong></p><p><strong>Пример многопоточной программы </strong></p><p>В следующем примере создается два дополнительных потока, которые выводят на стандартный вывод каждый свое: </p><p>import threading </p><p>             def proc(n): </p><p>              print &quot;Процесс&quot;, n </p><p> </p><p>            p1 = threading.Thread(target=proc, name=&quot;t1&quot;, args=[&quot;1&quot;])             p2 = threading.Thread(target=proc, name=&quot;t2&quot;, args=[&quot;2&quot;])             p1.start()             p2.start() </p><p> </p><p>Сначала получается два объекта класса Thread, которые затем и запускаются с различными аргументами. В данном случае в потоках работает одна и та же функция proc(), которой передается один аргумент, заданный в именованном параметре args конструктора класса Thread. Нетрудно догадаться, что метод start() служит для запуска нового потока. Таким образом, в приведенном примере работают три потока: основной и два дополнительных (с именами &quot;t1&quot; и &quot;t2&quot; ). </p><p>Вопросы:</p><ol><li>Потоки управления </li><li>семафоры</li><li>многопоточные программы</li></ol><h1><a id="_Toc454873538"></a><a id="_Toc454109382"></a>Лекция 25. Поиск информации в текстовом файле</h1><p>План:</p><ol><li>Функции модуля threading </li><li>Класс Thread</li><li>Таймер</li><li>Замки</li></ol><p><strong>Функции модуля threading </strong></p><p>В модуле threading, который здесь используется, есть функции, позволяющие получить информацию о потоках: </p><ul><li>activeCount() Возвращает количество активных в настоящий момент экземпляров класса Thread. Фактически, это len(threading.enumerate()).  </li><li>currentThread() Возвращает текущий объект-поток, то есть соответствующий потоку управления, который вызвал эту функцию. Если поток не был создан через модуль threading, будет возвращен объект-поток с сокращенной функциональностью (dummy thread object).  </li><li>enumerate() Возвращает список активных потоков. Завершившиеся и еще не начатые потоки не входят в список. </li></ul><p><strong>Класс Thread </strong></p><p>Экземпляры класса threading.Thread представляют потоки Python-программы. Задать действия, которые будут выполняться в потоке, можно двумя способами: передать конструктору класса исполняемый объект и аргументы к нему или путем наследования получить новый класс с переопределенным методом run(). Первый способ был рассмотрен в примере выше. Конструктор класса threading.Thread имеет следующие аргументы: </p><p>Thread(group, target, name, args, kwargs) </p><p> </p><p>Здесь group - группа потоков (пока что не используется, должен быть равен None ), target - объект, который будет вызван в методе run(), name - имя потока, args и kwargs - последовательность и словарь позиционных и именованных параметров (соответственно) для вызова заданного в параметре target объекта. В примере выше были использованы только позиционные параметры, но то же самое можно было выполнить и с применением именованных параметров: </p><p> 	 </p><p>import threading </p><p>             def proc(n): </p><p>              print &quot;Процесс&quot;, n </p><p> </p><p>            p1 = threading.Thread(target=proc, name=&quot;t1&quot;, kwargs={&quot;n&quot;: &quot;1&quot;})             p2 = threading.Thread(target=proc, name=&quot;t2&quot;, kwargs={&quot;n&quot;: &quot;2&quot;})             p1.start()             p2.start() </p><p> </p><p>То же самое можно проделать через наследование от класса threading.Thread с определением собственного конструктора и метода run(): </p><p>import threading </p><p>             class T(threading.Thread):               def __init__(self, n): </p><p>                threading.Thread.__init__(self, name=&quot;t&quot; + n)                 self.n = n               def run(self): </p><p>                print &quot;Процесс&quot;, self.n </p><p> </p><p>            p1 = T(&quot;1&quot;)             p2 = T(&quot;2&quot;)             p1.start()             p2.start() </p><p> </p><p>Самое первое, что необходимо сделать в конструкторе - вызвать конструктор базового класса. Как и раньше, для запуска потока нужно выполнить метод start() объекта-потока, что приведет к выполнению действий в методе run(). </p><p>Жизнью потоков можно управлять вызовом методов: </p><ul><li>start() Дает потоку жизнь.  </li><li>run() Этот метод представляет действия, которые должны быть выполнены в потоке.  </li><li>join([timeout]) Поток, который вызывает этот метод, приостанавливается, ожидая завершения потока, чей метод вызван. Параметр timeout (число с плавающей точкой) позволяет указать время ожидания (в секундах), по истечении которого приостановленный поток продолжает свою работу независимо от завершения потока, чей метод join был вызван. Вызывать join() некоторого потока можно много раз. Поток не может вызвать метод join() самого себя. Также нельзя ожидать завершения еще не запущенного потока. Слово &quot;join&quot; в переводе с английского означает &quot;присоединить&quot;, то есть, метод, вызвавший join(), желает, чтобы поток по завершении присоединился к вызывающему метод потоку.  </li><li>getName() Возвращает имя потока. Для главного потока это &quot;MainThread&quot;.  </li><li>setName(name) Присваивает потоку имя name.  </li><li>isAlive() Возвращает истину, если поток работает (метод run() уже вызван, но еще не завершился).  </li><li>isDaemon() Возвращает истину, если поток имеет признак демона. Программа на Python завершается по завершении всех потоков, не являющихся демонами. Главный поток демоном не является.  </li><li>setDaemon(daemonic) Устанавливает признак daemonic того, что поток является демоном. Начальное значение этого признака заимствуется у потока, запустившего данный. Признак можно изменять только для потоков, которые еще не запущены. </li></ul><p>В модуле Thread пока что не реализованы возможности, присущие потокам в Java (определение групп потоков, приостановка и прерывание потоков извне, приоритеты и некоторые другие вещи), однако они, скорее всего, будут созданы в недалеком будущем. </p><p><strong>Таймер </strong></p><p>Класс threading.Timer представляет действие, которое должно быть выполнено через заданное время. Этот класс является подклассом класса threading.Thread, поэтому запускается также методом start(). Следующий простой пример, печатающий на стандартном выводе Hello, world! поясняет сказанное: </p><p>def hello(): </p><p>              print &quot;Hello, world!&quot; </p><p> </p><p>            t = Timer(30.0, hello) </p><p>            t.start() </p><p><strong>Замки </strong></p><p>Простейший замок может быть реализован на основе класса Lock модуля threading. Замок имеет два состояния: он может быть или открыт, или заперт. В последнем случае им владеет некоторый поток. Объект класса Lock имеет следующие методы: </p><ul><li>acquire([blocking=True]) Делает запрос на запирание замка. Если параметр blocking не указан или является истиной, то поток будет ожидать освобождения замка. Если параметр не был задан, метод не возвратит значения. Если blocking был задан и истинен, метод возвратит True (после успешного овладения замком). Если блокировка не требуется (то есть задан blocking=False ), метод вернет True, если замок не был заперт и им успешно овладел данный поток. В противном случае будет возвращено False.  </li><li>release() Запрос на отпирание замка.  </li><li>locked() Возвращает текущее состояние замка ( True - заперт, False - открыт). Следует иметь в виду, что даже если состояние замка только что проверено, это не означает, что он сохранит это состояние до следующей команды. </li></ul><p>Имеется еще один вариант замка - threading.RLock, который отличается от threading.Lock тем, что некоторый поток может запрашивать его запирание много раз. Отпирание такого замка должно происходить столько же раз, сколько было запираний. Это может быть полезно, например, внутри рекурсивных функций. </p><p>Вопросы:</p><ol><li>Функции модуля threading </li><li>Класс Thread</li><li>Таймер</li><li>Замки</li></ol><h1><a id="_Toc454873539"></a><a id="_Toc454109383"></a>Лекция 26. Указатели. Описание указателей.</h1><p>План:</p><ol><li>Tkinter </li><li>wxPython</li><li>PyGTK</li><li>PyQT</li><li>О графическом интерфейсе</li></ol><p>Строить <strong>графический интерфейс пользователя</strong> (GUI, <strong>G</strong> raphical <strong>U</strong> ser <strong>I</strong> nterface) для программ на языке Python можно при помощи соответствующих <strong>библиотек компонентов графического интерфейса</strong> или, используя кальку с английского, <strong>библиотек виджетов</strong>. </p><p>Следующий список далеко не полон, но отражает многообразие существующих решений: </p><ol><li>Tkinter Многоплатформенный пакет имеет хорошее управление расположением компонентов. Интерфейс выглядит одинаково на различных платформах (Unix, Windows, Macintosh). Входит в стандартную поставку Python. В качестве документации можно использовать руководство &quot;An Introduction to Tkinter&quot; </li></ol><p>	(&quot;Введение 	в 	Tkinter&quot;), 	написанное 	Фредриком 	Лундом: </p><p><a href="http://www.pythonware.com/library/tkinter/introduction/">http://www.pythonware.com/library/tkinter/introduction/ </a> </p><ol><li>wxPython Построен на многоплатформной библиотеке wxWidgets (раньше называлась wxWindows). Выглядит родным для всех платформ, активно совершенствуется, осуществлена поддержка GL. Имеется для всех основных платформ. Возможно, займет место Tkinter в будущих версиях Python. Сайт: <a href="http://www.wxpython.org/">http://www.wxpython.org/ </a> </li><li>PyGTK Набор визуальных компонентов для GTK+ и Gnome. Только для платформы GTK.  </li><li>PyQT/PyKDE Хорошие пакеты для тех, кто использует Qt (под UNIX или Windows) или KDE.  </li><li>Pythonwin Построен вокруг MFC, поставляется вместе с оболочкой в пакете win32all; только для Windows.  </li><li>pyFLTK Аналог Xforms, поддержка OpenGL. Имеется для платформ Windows и Unix. Сайт: <a href="http://pyfltk.sourceforge.net/">http://pyfltk.sourceforge.net/ </a> </li><li>AWT, JFC, Swing Поставляется вместе с Jython, а для Jython доступны средства, которые использует Java. Поддерживает платформу Java.  </li><li>anygui Независимый от нижележащей платформы пакет для построения графического интерфейса для программ на Python. Сайт: <a href="http://anygui.sourceforge.net/">http://anygui.sourceforge.net/ </a> </li><li>PythonCard Построитель графического интерфейса, сходный по идеологии с HyperCard/MetaCard. Разработан на базе wxPython. Сайт: </li></ol><p><a href="http://pythoncard.sourceforge.net/">http://pythoncard.sourceforge.net/ </a></p><p>Список актуальных ссылок на различные графические библиотеки, доступные из </p><p>Python, 	можно 	найти 	по 	следующему 	адресу: </p><p><a href="http://phaseit.net/claird/comp.lang.python/python_GUI.html">http://phaseit.net/claird/comp.lang.python/python_GUI.html </a></p><p>Библиотеки могут быть многоуровневыми. Например, PythonCard использует wxPython, который, скажем, на платформе Linux базируется на многоплатформной GUIбиблиотеке wxWindows, которая, в свою очередь, базируется на GTK+ или на Motif, а те - тоже используют для вывода X Window. Кстати, для Motif в Python имеются свои привязки. </p><p>В лекции будет рассматриваться пакет Tkinter, который по сути является оберткой для Tcl/Tk - известного графического пакета для сценарного языка Tcl. На примере этого пакета легко изучить основные принципы построения графического интерфейса пользователя. </p><p><strong>О графическом интерфейсе </strong></p><p>Почти все современные графические интерфейсы общего назначения строятся по модели WIMP - Window, Icon, Menu, Pointer (окно, иконка, меню, указатель). Внутри окон рисуются <strong>элементы графического интерфейса</strong>, которые для краткости будут называться <strong>виджетами</strong> (widget - штучка). Меню могут располагаться в различных частях окна, но их поведение достаточно однотипно: они служат для выбора действия из набора предопределенных действий. Пользователь графического интерфейса &quot;объясняет&quot; компьютерной программе требуемые действия с помощью указателя. Обычно указателем служит курсор мыши или джойстика, однако есть и другие &quot;указательные&quot; устройства. С помощью иконок графический интерфейс приобретает независимость от языка и в некоторых случаях позволяет быстрее ориентироваться в интерфейсе. </p><p>Основной задачей графического интерфейса является упрощение коммуникации между пользователем и компьютером. Об этом следует постоянно помнить при проектировании интерфейса. Применение имеющихся в наличии у программиста (или дизайнера) средств при создании графического интерфейса нужно свести до минимума, выбирая наиболее удобные пользователю виджеты в каждом конкретном случае. Кроме того, полезно следовать принципу наименьшего удивления: из формы интерфейса должно быть понятно его поведение. Плохо продуманный интерфейс портит ощущения пользователя от программы, даже если за фасадом интерфейса скрывается эффективный алгоритм. Интерфейс должен быть удобен для типичных действий пользователя. Для многих приложений такие действия выделены в отдельные серии экранов, называемые &quot;мастерами&quot; (wizards). Однако если приложение - скорее конструктор, из которого пользователь может строить нужные ему решения, типичным действием является именно построение решения. Определить типичные действия не всегда легко, поэтому компромиссом может быть гибрид, в котором есть &quot;мастера&quot; и хорошие возможности для собственных построений. Тем не менее, графический интерфейс не является самым эффективным интерфейсом во всех случаях. Для многих предметных областей решение проще выразить с помощью деклараций на некотором формальном языке или алгоритма на сценарном языке.</p><p>Вопросы:</p><ol><li>Tkinter </li><li>wxPython</li><li>PyGTK</li><li>PyQT</li><li>О графическом интерфейсе</li></ol><h1><a id="_Toc454873540"></a><a id="_Toc454109384"></a>Лекция 27. Структуры данных на основе указателей</h1><p>План:</p><ol><li>Основы Tk </li><li>менеджеры расположения </li><li>Классы виджетов</li><li>События</li></ol><p>Основы Tk </p><p>Основная черта любой программы с графическим интерфейсом - <strong>интерактивность</strong>. Программа не просто что-то считает (в пакетном режиме) от начала своего запуска до конца: ее действия зависят от вмешательства пользователя. Фактически, графическое приложение выполняет бесконечный цикл обработки событий. Программа, реализующая графический интерфейс, <strong>событийно-ориентирована</strong>. Она ждет от интерфейса событий, которые и обрабатывает сообразно своему внутреннему состоянию. </p><p>Эти события возникают в элементах графического интерфейса (виджетах) и обрабатываются прикрепленными к этим виджетам обработчиками. Сами виджеты имеют многочисленные свойства (цвет, размер, расположение), выстраиваются в иерархию принадлежности (один виджет может быть хозяином другого), имеют методы для доступа к своему состоянию. </p><p>Расположением виджетов (внутри других виджетов) ведают так называемые <strong>менеджеры расположения</strong>. Виджет устанавливается на место по правилам менеджера расположения. Эти правила могут определять не только координаты виджета, но и его размеры. В Tk имеются три типа менеджеров расположения: простой упаковщик (pack), сетка (grid) и произвольное расположение (place). </p><p>Но этого для работы графической программы недостаточно. Дело в том, что некоторые виджеты в графической программе должны быть взаимосвязаны определенным образом. Например, полоска прокрутки может быть взаимосвязана с текстовым виджетом: при использовании полоски текст в виджете должен двигаться, и наоборот, при перемещении по тексту полоска должна показывать текущее положение. Для связи между виджетами в Tk используются переменные, через которые виджеты и передают друг другу параметры. </p><p><strong>Классы виджетов </strong></p><p>Для построения графического интерфейса в библиотеке Tk отобраны следующие классы виджетов (в алфавитном порядке): </p><ol><li>Button (Кнопка) Простая кнопка для вызова некоторых действий (выполнения определенной команды).  </li><li>Canvas (Рисунок) Основа для вывода графических примитивов.  </li><li>Checkbutton (Флажок) Кнопка, которая умеет переключаться между двумя состояниями при нажатии на нее.  </li><li>Entry (Поле ввода) Горизонтальное поле, в которое можно ввести строку текста.  </li><li>Frame (Рамка) Виджет, который содержит в себе другие визуальные компоненты.  </li><li>Label (Надпись) Виджет может показывать текст или графическое изображение.  </li><li>Listbox (Список) Прямоугольная рамка со списком, из которого пользователь может выделить один или несколько элементов.  </li><li>Menu (Меню) Элемент, с помощью которого можно создавать всплывающие (popup) и ниспадающие (pulldown) меню.  </li><li>Menubutton (Кнопка-меню) Кнопка с ниспадающим меню.  </li><li>Message (Сообщение) Аналогично надписи, но позволяет заворачивать длинные строки и менять размер по требованию менеджера расположения.  </li><li>Radiobutton (Селекторная кнопка) Кнопка для представления одного из альтернативных значений. Такие кнопки, как правило, действует в группе. При нажатии на одну из них кнопка группы, выбранная ранее, &quot;отскакивает&quot;.  </li><li>Scale (Шкала) Служит для задания числового значения путем перемещения движка в определенном диапазоне.  </li><li>Scrollbar (Полоса прокрутки) Полоса прокрутки служит для отображения величины прокрутки в других виджетах. Может быть как вертикальной, так и горизонтальной.  </li><li>Text (Форматированный текст) Этот прямоугольный виджет позволяет редактировать и форматировать текст с использованием различных стилей, внедрять в текст рисунки и даже окна.  </li><li>Toplevel (Окно верхнего уровня) Показывается как отдельное окно и содержит внутри другие виджеты. </li></ol><p>Все эти классы не имеют отношений наследования друг с другом - они равноправны. Этот набор достаточен для построения интерфейса в большинстве случаев. </p><p><strong> События </strong></p><p>В системе современного графического интерфейса имеется возможность отслеживать различные события, связанные с клавиатурой и мышью, и происходящие на &quot;территории&quot; того или иного виджета. В Tk события описываются в виде текстовой строки - шаблона события, состоящего из трех элементов (модификаторы, тип события и детализация события). </p><table><tr><td><p><strong>Тип события </strong></p></td><td><p><strong>Содержание события </strong></p></td></tr><tr><td><p>Activate </p></td><td><p>Активизация окна </p></td></tr><tr><td><p>ButtonPress </p></td><td><p>Нажатие кнопки мыши </p></td></tr><tr><td><p>ButtonRelease </p></td><td><p>Отжатие кнопки мыши </p></td></tr><tr><td><p>Deactivate </p></td><td><p>Деактивация окна </p></td></tr><tr><td><p>Destroy </p></td><td><p>Закрытие окна </p></td></tr><tr><td><p>Enter </p></td><td><p>Вхождение курсора в пределы виджета </p></td></tr><tr><td><p>FocusIn </p></td><td><p>Получение фокуса окном </p></td></tr><tr><td><p>FocusOut </p></td><td><p>Потеря фокуса окном </p></td></tr><tr><td><p>KeyPress </p></td><td><p>Нажатие клавиши на клавиатуре </p></td></tr><tr><td><p>KeyRelease </p></td><td><p>Отжатие клавиши на клавиатуре </p></td></tr><tr><td><p>Leave </p></td><td><p>Выход курсора за пределы виджета </p></td></tr><tr><td><p>Motion </p></td><td><p>Движение мыши в пределах виджета </p></td></tr><tr><td><p>MouseWheel </p></td><td><p>Прокрутка колесика мыши </p></td></tr><tr><td><p>Reparent </p></td><td><p>Изменение родителя окна </p></td></tr><tr><td><p>Visibility </p></td><td><p>Изменение видимости окна </p></td></tr></table><p> </p><p>Вопросы:</p><ol><li>Основы Tk </li><li>менеджеры расположения </li><li>Классы виджетов</li><li>События</li></ol><h1><a id="_Toc454873541"></a><a id="_Toc454109385"></a>Лекция 28. Связанные списки</h1><p>План:</p><ol><li>API  </li><li>Написание модуля расширения </li><li>Пример встраивания интерпретатора в программу на C</li><li>SWIG</li></ol><p><strong>API </strong></p><p>Доступные из языка Python модули расширяются за счет <strong>модулей расширения (extension modules)</strong>. Модули расширения можно писать на языке C или C++ и вызывать из программ на Python. В этой лекции речь пойдет о реализации Python, называемой CPython(Jython, реализация Python на платформе Java не будет рассматриваться). </p><p>Сама необходимость использования языка C может возникнуть, если реализуемый алгоритм, будучи запрограммирован на Python, работает медленно. Например, высокопроизводительные операции с массивами модуля Numeric (о котором говорилось в одной из предыдущих лекций) написаны на языке C. Модули расширения позволяют объединить эффективность порождаемого компилятором C/C++ кода c удобством и гибкостью интерпретатора Python. Необходимые сведения для создания модулей расширения для Python даны в исчерпывающем объеме в стандартной документации, а именно в документе &quot;Python/C API Reference Manual&quot; (справочное руководство по &quot;Python/C API&quot;). Здесь будут рассмотрены лишь основные принципы построения модуля расширения, без детальных подробностей об API. Стоит заметить, что возможности Python равно доступны и в C++, просто они выражены в Cдекларациях, которые можно использовать в C++. </p><p>Все необходимые для модуля расширения определения находятся в заголовочном файле Python.h, который должен находится где-то на пути заголовочных файлов компилятора C/C++. Следует пользоваться теми же версиями библиотек, с которыми был откомпилирован Python. Желательно, и той же маркой компилятора C/C++. </p><p>Связь с интерпретатором Python из кода на C осуществляется путем вызова функций, определенных в интерпретаторе Python. Все функции начинаются на Py или _Py, потому во избежание конфликтов в модулях расширения не следует определять функций с подобными именами. </p><p>Через C API доступны все встроенные возможности языка Python (при необходимости, детальнее изучить этот вопрос можно по документации): </p><ol><li>высокоуровневый интерфейс интерпретатора (функции и макросы Py_Main(), </li></ol><p>PyRun_String(), PyRun_File(), Py_CompileString(), PyCompilerFlags() и т.п.),  </p><ol><li>функции 	для 	работы 	со 	встроенным 	интерпретатором 	и 	потоками 	( </li></ol><p>Py_Initialize(), Py_Finalize(), Py_NewInterpreter(), Py_EndInterpreter(), Py_SetProgramName() и другие),  </p><ol><li>управление подсчетом ссылок (макросы Py_INCREF(), Py_DECREF(), Py_XINCREF(), Py_XDECREF(), Py_CLEAR() ). Требуется при создании или удалении Pythonобъектов в C/C++-коде.  </li><li>обработка исключений ( PyErr* -функции и PyExc_* -константы, например, </li></ol><p>PyErr_NoMemory() и PyExc_IOError )  </p><ol><li>управление процессом и сервисы операционной системы ( Py_FatalError(), </li></ol><p>Py_Exit(), Py_AtExit(), PyOS_CheckStack(), и другие функции/макросы PyOS* ),  6. импорт модулей ( PyImport_Import() и другие),  </p><ol><li>поддержка сериализации объектов ( PyMarshal_WriteObjectToFile(), PyMarshal_ReadObjectFromFile() и т.п.)  </li><li>поддержка анализа строки аргументов ( PyArg_ParseTuple(), PyArg_VaParse(), </li></ol><p>PyArg_ParseTupleAndKeywords(), PyArg_VaParseTupleAndKeywords(), PyArg_UnpackTuple() и Py_BuildValue() ). С помощью этих функций облегчается задача получения в коде на C параметров, заданных при вызове функции из Python. Функции PyArg_Parse* принимают в качестве аргумента строку формата полученных аргументов,  </p><ol><li>поддержка 	протоколов 	абстрактных 	объектов: 	+ 	Протокол 	объекта 	( </li></ol><p>PyObject_Print(), PyObject_HasAttrString(), PyObject_GetAttrString(), PyObject_HasAttr(), PyObject_GetAttr(), PyObject_RichCompare(), ..., </p><p>PyObject_IsInstance(), PyCallable_Check(), PyObject_Call(), PyObject_Dir() и другие). То, что должен уметь делать любой объект Python + Протокол числа ( </p><p>	PyNumber_Check(), 	PyNumber_Add(), 	..., 	PyNumber_And(), 	..., </p><p>PyNumber_InPlaceAdd(), ..., PyNumber_Coerce(), PyNumber_Int(), ...). То, что должен делать любой объект, представляющий число + Протокол последовательности ( PySequence_Check(), PySequence_Size(), </p><p>PySequence_Concat(), PySequence_Repeat(), PySequence_InPlaceConcat(), ..., </p><p>PySequence_GetItem(), ..., PySequence_GetSlice(), PySequence_Tuple(), PySequence_Count(), ...) + Протокол отображения (например, словарь является отображением) (функции: PyMapping_Check(), PyMapping_Length(), </p><p>PyMapping_HasKey(), PyMapping_Keys(), ..., PyMapping_SetItemString(), PyMapping_GetItemString() и др.) + Протокол итератора ( PyIter_Check(), PyIter_Next() ) + Протокол буфера ( PyObject_AsCharBuffer(), PyObject_AsReadBuffer(), PyObject_AsWriteBuffer(), </p><p>PyObject_CheckReadBuffer() )  </p><ol><li>поддержка встроенных типов данных. Аналогично описанному в предыдущем пункте, но уже для конкретных встроенных типов данных. Например: + Булевский объект ( PyBool_Check() - проверка принадлежности типу PyBool_Type, Py_False - объект False, Py_True - объект True,  </li><li>управление 	памятью 	(то 	есть 	кучей 	интерпретатора 	Python) 	(функции </li></ol><p>PyMem_Malloc(), PyMem_Realloc(), PyMem_Free(), PyMem_New(), PyMem_Resize(), PyMem_Del() ). Разумеется, можно применять и средства выделения памяти C/C++, однако, в этом случае не будут использоваться преимущества управления памятью интерпретатора Python (сборка мусора и т.п.). Кроме того, освобождение памяти нужно производить тем же способом, что и ее выделение. Еще раз стоит напомнить, что повторное освобождение одной и той же области памяти (а равно использование области памяти после ее освобождения) чревато серьезными ошибками, которые компилятор C не имеет возможности распознать.  </p><ol><li>структуры для определения объектов встроенных типов ( PyObject, PyVarObject и много других) </li></ol><p><strong>Написание модуля расширения </strong></p><p>Если необходимость встроить Python в программу возникает нечасто, то его расширение путем написания модулей на C/C++ - довольно распространенная практика. Изначально Python был нацелен на возможность расширения, поэтому в настоящий момент очень многие C/C++-библиотеки имеют привязки к Python. </p><p>Привязка к Python, хотя и может быть несколько автоматизирована, все же это процесс творческий. Дело в том, что если предполагается интенсивно использовать библиотеку в Python, ее привязку желательно сделать как можно более тщательно. Возможно, в ходе привязки будет сделана объектно-ориентированная надстройка или другие архитектурные изменения, которые позволят упростить использование библиотеки. </p><p>В качестве примера можно привести выдержку из исходного кода модуля md5, который реализует функцию для получения md5-дайджеста. Модуль приводится в целях иллюстрации (то есть, с сокращениями). Модуль вводит собственный тип данных, MD5Type, поэтому можно увидеть не только реализацию функций, но и способ описания встроенного типа. В рамках этого курса не изучить все тонкости программирования модулей расширения, главное понять дух этого занятия. </p><p>На основе этого примера можно строить собственные модули расширения, ознакомившись с документацией по C/API и документом &quot;Extending and Embedding&quot; (&quot;Расширение и встраивание&quot;) из стандартной поставки Python. Перед тем, как приступать к созданию своего модуля, следует убедиться, что это целесообразно: подходящего модуля еще не создано и реализация в виде чистого Python неэффективна. Если создан действительно полезный модуль, его можно предложить для включения в поставку Python. Для этого нужно просто связаться с кем-нибудь из разработчиков по электронной почте или предложить модуль в виде &quot;патча&quot; через <a href="http://sourceforge.net/">http://sourceforge.net.</a> </p><p><strong>Пример встраивания интерпретатора в программу на C </strong></p><p>Интерпретатор Python может быть встроен в программу на C с использованием C API. Это лучше всего демонстрирует уже работающий пример: </p><p>Здесь следует отметить следующие моменты: </p><ul><li>программу необходимо компилировать вместе с библиотекой libpython соответствующей версии (для этого используется опция -l, за которой следует имя библиотеки) и еще с библиотеками, которые требуются для Python: libpthread, libm, libutil и т.п.)  </li><li>опция pic порождает код, не зависящий от позиции, что позволяет в дальнейшем динамически компоновать код  </li><li>обычно требуется явно указать каталог, в котором лежит заголовочный файл Python.h (в gcc это делается опцией -I )  </li><li>чтобы получившийся исполняемый файл мог корректно предоставлять имена для динамически загружаемых модулей, требуется передать компоновщику опцию -E: это можно сделать из gcc с помощью опции -Wl, -E. (В противном случае, модуль time, а это модуль расширения в виде динамически загружаемого модуля, не будет работать из-за того, что не увидит имен, определенных в libpython) </li></ul><p>Здесь же следует сделать еще одно замечание: программа, встраивающая Python, не должна много раз выполнять Py_Initialize() и Py_Finalize(), так как это может приводить к утечке памяти. Сам же интерпретатор Python очень стабилен и в большинстве случаев не дает утечек памяти. </p><p><strong>Использование SWIG </strong></p><p><strong>SWIG</strong> (Simplified Wrapper and Interface Generator, упрощенный упаковщик и генератор интерфейсов) - это программное средства, сильно упрощающее (во многих случаях - автоматизирующее) использование библиотек, написанных на C и C++, а также на других языках программирования, в том числе (не в последнюю очередь!) на Python. Нужно отметить, что SWIG обеспечивает достаточно полную поддержку практически всех возможностей C++, включая предобработку, классы, указатели, наследование и даже шаблоны C++. Последнее очень важно, если необходимо создать интерфейс к библиотеке шаблонов. </p><p>Пользоваться SWIG достаточно просто, если уметь применять компилятор и компоновщик (что в любом случае требуется при программировании на C/C++). </p><p>Вопросы:</p><ol><li>API  </li><li>Написание модуля расширения </li><li>Пример встраивания интерпретатора в программу на C</li><li>SWIG</li></ol><h1><a id="_Toc454873542"></a><a id="_Toc454109386"></a>Лекция 29. Общие сведения о подпрограммах. Рекурсия</h1><p>План:</p><ol><li>Интеграция Python и Java  </li><li>Интеграция Python и Prolog </li><li>Интеграция Python и OCaml</li><li>Интеграция Python и Pyrex</li></ol><p>Язык программирования Python является сценарным языком, а значит его основное назначение - интеграция в единую систему разнородных программных компонентов. Выше рассматривалась (низкоуровневая) интеграция с C/C++приложениями. Нужно заметить, что в большинстве случаев достаточно интеграции с использованием протокола. Например, интегрируемые приложения могут общаться через XML-RPC, SOAP, CORBA, COM, .NET и т.п. В случаях, когда приложения имеют интерфейс командной строки, их можно вызывать из Python и управлять стандартным вводом-выводом, переменными окружения. Однако есть и более интересные варианты интеграции. </p><p>Современное состояние дел по излагаемому вопросу можно узнать по адресу: </p><p><a href="http://www.python.org/moin/IntegratingPythonWithOtherLanguages">http://www.python.org/moin/IntegratingPythonWithOtherLanguages </a></p><p><strong>Java </strong></p><p>Документация по Jython (это реализация Python на Java-платформе) отмечает, что Jython обладает следующими неоспоримыми преимуществами над другими языками, использующими Java-байт-код: </p><ul><li>Jython-код динамически компилирует байт-коды Java, хотя возможна и статическая компиляция, что позволяет писать апплеты, сервлеты и т.п.;  </li><li>Поддерживает объектно-ориентированную модель Java, в том числе, возможность наследовать от абстрактных Java-классов;  </li><li>Jython является реализацией Python - языка с практичным синтаксисом, обладающего большой выразительностью, что позволяет сократить сроки разработки приложений в разы. </li></ul><p>Правда, имеются и некоторые ограничения по сравнению с &quot;обычным&quot; Python. Например, Java не поддерживает множественного наследования, поэтому в некоторых версиях Jython нельзя наследовать классы от нескольких Java-классов (в то же время, множественное наследование поддерживается для Python-классов). </p><p> 	 </p><p><strong> </strong></p><p><strong>Prolog </strong></p><p>Для тех, кто хочет использовать Prolog из Python, существует несколько возможностей: </p><ul><li>Версия GNU Prolog (сайт: <a href="http://gprolog.sourceforge.net/">http://gprolog.sourceforge.net)</a> интегрируется с Python посредством пакета bedevere (сайт: <a href="http://bedevere.sourceforge.net/">http://bedevere.sourceforge.net)</a>  </li><li>Имеется пакет PyLog (<a href="http://www.gocept.com/angebot/opensource/Pylog">http://www.gocept.com/angebot/opensource/Pylog)</a> для работы с SWI-Prolog (<a href="http://www.swi-prolog.org/">http://www.swi-prolog.org)</a> из Python  </li><li>Можно использовать пакет pylog (доступен с сайта: <a href="http://christophe.delord.free.fr/en/pylog/">http://christophe.delord.free.fr/en/pylog/)</a>, который добавляет основные возможности Prolog в Python </li></ul><p>Эти три варианта реализуют различные способы интеграции возможностей Prolog в Python. Первый вариант использует SWIG, второй организует общение с Prologсистемой через конвейер, а третий является специализированной реализацией Prolog. </p><p><strong>	 </strong></p><p><strong>OCaml </strong></p><p>Язык программирования OCaml - это язык функционального программирования (семейства ML, что означает Meta Language), созданный в институте INRIA, Франция. Важной особенностью OCaml является то, что его компилятор порождает исполняемый код, по быстродействию сравнимый с С, родной для платформ, на которых OCaml реализован. В то же время, будучи функциональным по своей природе, он приближается к Python по степени выразительности. Именно поэтому для OCaml была создана <strong>библиотека Pycaml</strong>, фактически реализующая аналог C API для OCaml. Таким образом, в программах на OCaml могут использоваться модули языка Python, в них даже может быть встроен интерпретатор Python. Для Python имеется большое множество адаптированных C-библиотек, это дает возможность пользователям OCaml применять в разработке комбинированное преимущество Python и OCaml. Минусом является только необходимость знать функции Python/C API, имена которого использованы для связи OCaml и Python. </p><p><strong>Pyrex </strong></p><p>Для написания модулей расширения можно использовать специальный язык - Pyrex - который совмещает синтаксис Python и типы данных C. Компилятор Pyrex написан на Python и превращает исходный файл (например, primes.pyx) в файл на C - готовый для компиляции модуль расширения. Язык Pyrex заботится об управлении памятью, удаляя после себя ставшие ненужными объекты. </p><p>Разумеется, в Pyrex можно использовать C-библиотеки, именно поэтому он, как и SWIG, может служить для построения оберток C-библиотек для Python. </p><p>Следует отметить, что для простых операций Pyrex применяет C, а для обращения к объектам Python - вызовы Python/C API. Таким образом, объединяется выразительность Python и эффективность C. Конечно, некоторые вещи в Pyrex не доступны, например, генераторы, списковые включения и Unicode, однако, цель Pyrex - создание быстродействующих модулей расширения, и для этого он превосходно подходит. Ознакомится с Pyrex можно по документации (которая, к сожалению, есть пока только на английском языке).</p><p>Вопросы:</p><ol><li>Интеграция Python и Java  </li><li>Интеграция Python и Prolog </li><li>Интеграция Python и OCaml</li><li>Интеграция Python и Pyrex</li></ol><h1><a id="_Toc454873543"></a><a id="_Toc454109387"></a>Лекция 30. Организация функций. Использование функций</h1><p>План:</p><ol><li>Лексический анализатор  </li><li>деревья синтаксического разбора </li><li>Получение байт-кода</li><li>Оптимизация</li></ol><p><strong>Лексический анализатор</strong> языка программирования разбивает исходный текст программы (состоящий из одиночных символов) на лексемы - неделимые &quot;слова&quot; языка. </p><p>Основные категории лексем Python: идентификаторы и ключевые слова (NAME), литералы (STRING, NUMBER и т.п.), операции (OP), разделители, специальные лексемы для обозначения (изменения) отступов (INDENT, DEDENT) и концов строк (NEWLINE), а также комментарии (COMMENT). Лексический анализатор доступен через модуль tokenize, а определения кодов лексем содержатся в модуле token стандартной библиотеки Python.</p><p>   ''  </p><p>Фактически получен поток лексем, который может использоваться для различных целей. Например, для синтаксического &quot;окрашивания&quot; кода на языке Python. Словарь token.tok_name позволяет получить мнемонические имена для типа лексемы по номеру. </p><p><strong>Синтаксический анализ </strong></p><p>Вторая стадия преобразования исходного текста программы в байт-код интерпретатора состоит в синтаксическом анализе исходного текста. Модуль parser содержит функции suite() и expr() для построения <strong>деревьев синтаксического разбора</strong> соответственно для кода программ и выражений Python. Модуль symbol содержит номера символов грамматики Python, словарь для получения названия символа из грамматики Python. </p><p><strong>Получение байт-кода </strong></p><p>После того как получено дерево синтаксического разбора, компилятор должен превратить его в байт-код, подходящий для исполнения интерпретатором.  </p><p>Функция parser.suite() (или parser.expr() ) возвращает AST-объект (дерево синтаксического анализа), которое методом compile() компилируется в Python байткод и сохраняется в кодовом объекте code. Теперь этот код можно выполнить (или, в случае выражения - вычислить) с помощью оператора exec (или функции eval() ). </p><p>Здесь необходимо заметить, что недавно в Python появился пакет compiler, который объединяет модули для работы анализа исходного кода на Python и генерации кода. В данной лекции он не рассматривается, но те, кто хочет глубже изучить эти процессы, может обратиться к документации по Python. </p><p><strong>Оптимизация </strong></p><p>Основная реализация языка Python пока что не имеет оптимизирующего компилятора, поэтому разговор об оптимизации касается только <strong>оптимизации кода</strong> самим программистом. В любом языке программирования имеются свои характерные приемы оптимизации кода. Оптимизация (улучшение) кода может происходить в двух (зачастую конкурирующих) направлениях: скорость и занимаемая память. В условиях достатка оперативной памяти приложения обычно оптимизируют по скорости. При оптимизации по времени программы для одноразового вычисления следует иметь в виду, что в общее время решения задачи входит не только выполнение программы, но и время ее написания. Не стоит тратить усилия на оптимизацию программы, если она будет использоваться очень редко. </p><p>Следует учитывать, что программа, реализующая некоторый алгоритм, не может быть оптимизирована до бесконечно малого времени вычисления: используемый алгоритм имеет определенную <strong>временную сложность</strong> и программу, основанную на слишком сложном алгоритме, существенно оптимизировать не удастся. Можно попытаться сменить алгоритм (хотя многие задачи этого сделать не позволяют) или ослабить требования к решениям. Иногда помогает упрощение алгоритма. К сожалению, оптимизация кода, как и программирование - задача неформальная, поэтому умение оптимизировать код приходит с опытом. </p><p>Если скорость работы программы при большой длине данных не устраивает, следует поискать более эффективный алгоритм. Если же более эффективный алгоритм практически нецелесообразен, можно попытаться провести оптимизацию кода. </p><p>Собственно, в данном примере для модуля timeit уже показан практический способ нахождения оптимального кода. Стоит также отметить, что с помощью профайлера нужно определить места кода, отнимающие наибольшую часть времени. Обычно это действия, выполняемые в самом вложенном цикле. Можно попытаться вынести из цикла все, что можно вычислить в более внешнем цикле или вообще вне цикла. </p><p>В языке Python вызов функции является относительно дорогостоящей операцией, поэтому на критичных по скорости участках кода следует избегать вызова большого числа функций. </p><p>В некоторых случаях работу программы на Python можно ускорить в несколько раз с помощью специального оптимизатора (он не входит в стандартную поставку Python, но свободно распространяется): psyco. Для ускорения программы достаточно добавить следующие строки в начале главного модуля программы: </p><p>import psyco </p><p>                psyco.full() </p><p> </p><p>Правда, некоторые функции не поддаются &quot;компиляции&quot; с помощью psyco. В этих случаях будут выданы предупреждения. Посмотрите документацию по psyco с тем, чтобы узнать ограничения в его использовании и способы их преодоления. </p><p>Еще одним вариантом ускорения работы приложения является переписывание критических участков алгоритма на языках более низкого уровня (С/С++) и использование модулей расширения из Python. Однако эта крайняя мера обычно не требуется или модули для задач, требующих большей эффективности, уже написаны. Например, для работы с растровыми изображениями имеется прекрасная библиотека модулей PIL (Python Imaging Library). Численные расчеты можно выполнять с помощью пакета Numeric и т.д. </p><p><strong>Pychecker </strong></p><p>Одним из наиболее интересных инструментов для анализа исходного кода Python программы является Pychecker. Как и lint для языка C, Pychecker позволяет выявлять слабости в исходном коде на языке Python. Можно рассмотреть следующий пример с использованием Pychecker: </p><p>import re, string             import re             a = &quot;a b c&quot;              def test(x, y):               from string import split               a = &quot;x y z&quot;               print split(a) + x </p><p> </p><p>            test(['d'], 'e') </p><p> </p><p>Pychecker выдаст следующие предупреждения: </p><p>badcode.py:1: Imported module (string) not used                 badcode.py:2: Imported module (re) not used                 badcode.py:2: Module (re) re-imported                 badcode.py:5: Parameter (y) not used </p><p>                badcode.py:6: Using import and from ... import for (string)                 badcode.py:7: Local variable (a) shadows global defined on line 3                 badcode.py:8: Local variable (a) shadows global defined on line 3 </p><p> </p><p>В первой строке импортирован модуль, который далее не применяется, то же самое с модулем re. Кроме того, модуль re импортирован повторно. Другие проблемы с кодом: параметр y не использован; модуль string применен как в операторе import, так и во from-import ; локальная переменная a затеняет глобальную, которая определена в третьей строке. </p><p>Можно переписать этот пример так, чтобы Pychecker выдавал меньше предупреждений: </p><p>import string </p><p>                a = &quot;a b c&quot; </p><p>                 def test(x, y):                   a1 = &quot;x y z&quot; </p><p>                  print string.split(a1) + x </p><p> </p><p>                test(['d'], 'e') </p><p> </p><p>Теперь имеется лишь одно предупреждение: </p><p>goodcode.py:4: Parameter (y) not used </p><p> Такое тоже бывает. Программист должен лишь убедиться, что он не сделал ошибки. </p><p>Вопросы:</p><ol><li>Лексический анализатор  </li><li>деревья синтаксического разбора </li><li>Получение байт-кода</li><li>Оптимизация</li></ol><h1><a id="_Toc454873544"></a>Литература</h1><ol><li>Семакин И.Г., Шестаков А.П. Основы алгоритмизации и программирования: Учебник для сред. проф. образования / И.Г. Семакин, А.П. Шестаков. — М.: Издательский центр &quot;Академия&quot;, 2012. — 400 с. (Допущено Министерством образования и науки Российской Федерации) </li><li>Златопольский, Д.М. Сборник задач по программированию._2-е изд., перераб. и доп./ Д. М. Златопольский. - СПб.: БХВ-Петербург, 2013 </li></ol><p>Дополнительные источники:  </p><ol><li>Саммерфилд М. Программирование на Python 3. Подробное руководство. - Пер. с англ. - СПб.: Символ-Плюс, 2015. - 608 с. </li><li>Марк луц, Программирование на Python,  - Пер. с англ. - СПб.: Символ-Плюс, 2014. - 992 с.. </li></ol>