---
layout: page
title: Технология разработки программных продуктов. Лекции
---

<p><a href="#_Toc454873021">Лекция 1. Программные продукты и их характеристики 3</a></p>
<p><a href="#_Toc454873022">Лекция 2. Стадии разработки программ и программной документации 8</a></p>
<p><a href="#_Toc454873023">Лекция 3. Методы проектирования программных продуктов 13</a></p>
<p><a href="#_Toc454873024">Лекция 4. Проектирование интерфейса пользователя 18</a></p>
<p><a href="#_Toc454873025">Лекция 5. Структурное программирование 23</a></p>
<p><a href="#_Toc454873026">Лекция 6. Объектно-ориентированное программирование 26</a></p>
<p><a href="#_Toc454873027">Лекция 7. Консультационное обеспечение качества программ 30</a></p>
<p><a href="#_Toc454873028">Лекция 8. Экзамены и тесты как средства поиска ошибок в программном обеспечении 35</a></p>
<p><a href="#_Toc454873029">Лекция 9. Инструментальные средства разработки программ 39</a></p>
<p><a href="#_Toc454873030">Лекция 10. Коллективная разработка программных продуктов 43</a></p>
<p><a href="#_Toc454873031">Литература 46</a></p>
<h1><a id="_Toc454873021"></a>Лекция 1. Программные продукты и их характеристики</h1>
<p>План:</p>
<ol>
	<li>Введение.</li>
	<li>Понятие жизненного цикла программного продукта</li>
	<li>Процесс создания программ</li>
	<li>Понятие качества ПС</li>
</ol>
<p><strong>Введение</strong></p>
<p>В основном именно программное обеспечение, или, иными словами, программные продукты, обеспечивают возможность
	широкого использования компьютеров. Стоит нам переустановить программное обеспечение компьютера или добавить
	какой-либо новый программный продукт, и мы сможем решать на этом компьютере совершенно новые задачи. Следовательно,
	используемые программные продукты должны соответствовать определенным критериям, обеспечивающим надежность работы
	компьютера и удобство работы пользователя.</p>
<p>Если аппаратура компьютера, даже самые простейшие ее компоненты, с самого начала разрабатывались и выпускались в
	соответствии с установленным технологическим процессом, то какой-то определенной технологии разработки программных
	продуктов первое время не существовало. Разработчики опирались в основном на свой личный опыт, используя кустарные
	способы разработки. Такой подход не мог не отразиться на качестве разрабатываемых программных продуктов, сроках их
	разработки и, следовательно, на их стоимости. Данная ситуация была названа кризисом программирования.</p>
<p>Чтобы выйти из кризиса, необходимо было создать индустриальные способы разработки программных продуктов, т.е.
	технологию их разработки, которая включала бы в себя различные передовые инженерные методы и средства создания
	программных продуктов. В дальнейшем эти методы и средства были объединены общим понятием «программная инженерия»
	(software engineering).</p>
<p><em>Программное средство (ПС) –</em> это программа или логически связанная совокупность программ на носителях данных,
	снабженная программной документацией.</p>
<p>Программная документация позволяет понять, какие функции выполняет та или иная программа, как подготовить исходные
	данные и запустить требуемую программу в процесс ее выполнения, а также: что означают получаемые результаты (или
	каков эффект выполнения этой программы). </p>
<p>Будем считать, что в ПС имеется ошибка, если оно не выполняет функции, описанные в документации по ее
	применению. </p>
<p><em>Надежность ПС</em> - это его способность безотказно выполнять определенные функции при заданных условиях в
	течение заданного периода времени с достаточно большой вероятностью.</p>
<p><em>Технология программирования</em> – это система научно-обоснованных принципов, методов и средств, обеспечивающих
	создание и развитие ПС, в течении всего жизненного периода (жизненного цикла) программного средства.</p>
<p>Состав технологии программирования:</p>
<ol>
	<li>принципы и методы организации труда при разработке, эксплуатации ПС;</li>
	<li>принципы и методы разработки самих программ;</li>
	<li>средства инструментальной поддержки и автоматизации, позволяющие унифицировать разработку ПС.</li>
</ol>
<p><strong>Понятие жизненного цикла программного продукта</strong></p>
<p><em>Программный продукт (ПП)</em> представляет собой набор компьютерных программ, процедур и связанной с ними
	документации и данных.</p>
<p><em>Жизненный цикл программного продукта</em> — это период времени, начинающийся с момента принятия решения о
	необходимости создания ПП и заканчивающийся в момент его полного изъятия из эксплуатации.</p>
<p>Структуру жизненного цикла ПП, состав процессов, действия и задачи, которые должны быть выполнены во время создания
	ПП, определяет и регламентирует международный стандарт ISO/IEC 12207: 1995 «Information Technology — Software Life
	Cycle Processes» (ISO — International Organization for Standardization — Международная организация по
	стандартизации; IEC — International Electrotechnical Commission — Международная комиссия по электротехнике; название
	стандарта «Информационные технологии — Процессы жизненного цикла программ»).</p>
<p><img alt="3" src="1.png"/></p>
<p>Под <em>процессом</em> понимают совокупность взаимосвязанных действий, преобразующих входные данные в выходные.
	Каждый процесс характеризуется определенными задачами и методами их решения, а также исходными данными, полученными
	от других процессов, и результатами.</p>
<p>Каждый процесс разделен на набор действий, каждое действие — на набор задач. Запуск и выполнение процесса, действия
	или задачи осуществляются другими процессами.</p>
<p>В соответствии со стандартом ISO/IEC 12207 все процессы жизненного цикла ПП разделены на три базовые группы: основные
	процессы; вспомогательные (поддерживающие) процессы; организационные процессы.</p>
<p><strong>Процесс создания программ</strong></p>
<p><em>Внешнее описание </em>ПС является описанием его поведения с точки зрения внешнего по отношению к нему наблюдателю
	с фиксацией требований относительно его качества. Внешнее описание ПС начинается с определения требований к ПС со
	стороны пользователей (заказчика). </p>
<p><em>Конструирование </em>ПС охватывает процессы: разработку архитектуры ПС, разработку структур программ ПС и их
	детальную спецификацию. </p>
<p><em>Кодирование: </em>создание текстов программ на языке программирования, их отладка и тестирование ПС. </p>
<p>На этапе <em>аттестации </em>ПС производится оценка качества ПС, после успешного завершения которого, разработка ПС
	считается законченной. </p>
<p><em>Программное изделие (ПИ)</em> - экземпляр или копия, снятая с разработанного ПС. <em>Изготовление </em>ПИ - это
	процесс генерации и/или воспроизведения (снятия копии) программ и программных документов ПС с целью их поставки
	пользователю для применения по назначению. <em>Производство </em>ПИ - это совокупность работ по обеспечению
	изготовления требуемого количества ПИ в установленные сроки.<em> Стадия производства </em>ПС в жизненном цикле ПС
	является, по-существу, вырожденной (не существенной), так как представляет рутинную работу, которая может быть
	выполнена автоматически и без ошибок.</p>
<p>Стадия <em>эксплуатации </em>ПС охватывает процессы хранения, внедрения и сопровождения ПС, а также транспортировки и
	применения ПИ по своему назначению. Она состоит из двух параллельно проходящих фаз: фазы применения ПС и фазы
	сопровождения ПС. </p>
<p><em>Применение </em>ПС - это использование ПС для решения практических задач на компьютере путем выполнения ее
	программ. </p>
<p><em>Сопровождение </em>ПС - это процесс сбора информации о его качестве в эксплуатации, устранения обнаруженных в нем
	ошибок, его доработки и модификации, а также извещения пользователей о внесенных в него изменениях. </p>
<p><strong>Понятие качества ПС.</strong></p>
<p><em>Качество </em>ПС - это совокупность его черт и характеристик, которые влияют на его способность удовлетворять
	заданные потребности пользователей.</p>
<p>Качество ПС является удовлетворительным, когда оно обладает указанными свойствами в такой степени, чтобы
	гарантировать успешное его использование.</p>
<p>Критерии качества ПС:</p>
<ul>
	<li>функциональность,</li>
	<li>надежность,</li>
	<li>легкость применения,</li>
	<li>эффективность,</li>
	<li>сопровождаемость,</li>
	<li>мобильность.</li>
</ul>
<p><em>Функциональность </em>- это способность ПС выполнять набор функций, удовлетворяющих заданным или подразумеваемым
	потребностям пользователей. Набор указанных функций определяется во внешнем описании ПС. </p>
<p><em>Легкость применения </em>- это характеристики ПС, которые позволяют минимизировать усилия пользователя по
	подготовке исходных данных, применению ПС и оценке полученных результатов, а также вызывать положительные эмоции
	определенного или подразумеваемого пользователя. </p>
<p><em>Эффективность </em>- это отношение уровня услуг, предоставляемых ПС пользователю при заданных условиях, к объему
	используемых ресурсов. </p>
<p><em>Сопровождаемость </em>- это характеристики ПС, которые позволяют минимизировать усилия по внесению изменений для
	устранения в нем ошибок и по его модификации в соответствии с изменяющимися потребностями пользователей. </p>
<p><em>Мобильность </em>- это способность ПС быть перенесенным из одной среды (окружения) в другую, в частности, с одной
	ЭВМ на другую. </p>
<p>Обязательные критерии качества: функциональность и надежность.</p>
<p>Вопросы:</p>
<ol>
	<li>Программное средство</li>
	<li>Понятие жизненного цикла программного продукта</li>
	<li>Процесс создания программ</li>
	<li>Понятие качества ПС</li>
</ol>
<h1><a id="_Toc454873022"></a>Лекция 2. Стадии разработки программ и программной документации</h1>
<p>План:</p>
<ol>
	<li>Классы программных продуктов</li>
	<li>Организационные процессы жизненного цикла программного продукта</li>
	<li>Взаимосвязь между процессами жизненного цикла программного продукта</li>
	<li>Microsoft Solutions Framework</li>
	<li>Rational Unified Process</li>
	<li>eXtreme Programming</li>
</ol>
<p><strong>Классы программных продуктов</strong></p>
<p><em>Системное программное обеспечение (System Software)</em> - совокупность программ и программных комплексов для
	обеспечения работы компьютера</p>
<p><em>Пакет прикладных программ (aplication program package)</em> комплекс взаимосвязанных программ для решения задач
	определенного класса конкретной предметной области.</p>
<p><em>Инструментарий технологии программирования</em> - совокупность программ и программных комплексов для
	обеспечивающих технологию разработки и внедрения программных продуктов</p>
<p><strong>Организационные процессы жизненного цикла программного продукта</strong></p>
<p><strong><em>Процесс управления (management process</em></strong>) состоит из действий и задач, которые могут
	выполняться любой стороной, управляющей своими процессами. Данная сторона (менеджер) отвечает за управление выпуском
	продукта, проектом и задачами соответствующих процессов, таких как приобретение, поставка, разработка, эксплуатация,
	сопровождение и др. Процесс управления включает в себя: инициирование и определение области управления;
	планирование;управление работами по созданию ПП и контроль за их выполнением; проверку и оценку; завершение работ.
</p>
<p>При<em> инициировании и определении области управления</em> менеджер должен определить необходимые для управления
	ресурсы (персонал, оборудование и технология) и убедиться, что они имеются в его распоряжении, причем в достаточном
	количестве.</p>
<p><em>Планирование</em> подразумевает выполнение, как минимум, следующих задач: составление графиков выполнения работ;
	оценку затрат; выделение требуемых ресурсов; распределение ответственности; оценку рисков, связанных с конкретными
	задачами; создание инфраструктуры управления.</p>
<p><strong><em>Процесс создания инфраструктуры (infrastructure process)</em></strong> охватывает выбор и поддержку
	(сопровождение) технологии, стандартов и инструментальных средств, выбор и установку аппаратных и программных
	средств, используемых для разработки, эксплуатации или сопровождения ПП. Процесс создания инфраструктуры включает в
	себя: подготовительную работу;</p>
<p>создание инфраструктуры; сопровождение инфраструктуры.</p>
<p><em>Подготовительная работа</em> заключается в координации с другими организационными процессами и планировании работ
	по созданию инфраструктуры с учетом выбранных технологий, стандартов, инструментальных, программных и аппаратных
	средств.</p>
<p><em>Создание инфраструктуры</em> включает в себя все действия по разработке в соответствии с выбранной концепцией и
	планом инфраструктуры для выполнения работ по созданию ПП.</p>
<p><em>Сопровождение инфраструктуры</em> вызвано необходимостью сопровождения ПП и возможными модификациями продукта в
	со- ь таетствии с изменившимися требованиями к нему.</p>
<p><strong><em>Процесс усовершенствования (improvement process)</em></strong> предусматривает оценку, измерение,
	контроль и усовершенствование процессов жизненного цикла ПП. Данный процесс включает в себя: создание процесса;
	оценку процесса;</p>
<p>усовершенствование процессов жизненного цикла ПП. <em>Создание процесса</em> усовершенствования процессов жизненного
	цикла ПП позволяет на основе контроля за ходом выполнения процессов жизненного цикла, измерения характеристик и
	оценки полученных результатов существенно улучшить качество разрабатываемого ПП и сократить сроки его создания.</p>
<p><em>Оценка процесса</em> разработки ПП позволяет выявить его сильные и слабые стороны и на основе полученных
	результатов провести необходимые улучшения.</p>
<p><em>Усовершенствование процессов жизненного цикла ПП</em> направлено на повышение производительности труда всех
	участвующих в них специалистов за счет совершенствования используемой технологии, методов управления, выбора
	инструментальных средств и обучения персонала. Усовершенствование основано на анализе достоинств и недостатков
	каждого процесса. Такому анализу в большой степени способствует накопление в организации исторической, технической,
	экономической и иной информации по реализованным проектам.</p>
<p><strong><em>Процесс обучения (training process)</em></strong> охватывает первоначальное обучение и последующее
	постоянное повышение квалификации персонала. Приобретение, поставка, разработка, эксплуатация и сопровождение
	программного продукта в значительной степени зависят от уровня знаний и квалификации персонала. Например,
	разработчики ПП должны пройти необходимое обучение методам и средствам программной инженерии. Содержание процесса
	обучения определяется требованиями к проекту. Для этого процесса должны быть запланированы необходимые ресурсы и
	технические средства обучения. Кроме того, должны быть разработаны и представлены методические материалы,
	необходимые для обучения пользователей в соответствии с учебным планом.</p>
<p>Процесс обучения включает в себя:</p>
<p>подготовительную работу;</p>
<p>разработку учебных материалов;</p>
<p>реализацию плана обучения.</p>
<p><a id="bookmark12"></a><strong>Взаимосвязь между процессами жизненного цикла программного продукта</strong></p>
<p>В<em> договорном аспекте</em> заказчик и поставщик вступают в договорные отношения и реализуют соответственно
	процессы приобретения и поставки.</p>
<p>В<em> аспекте управления</em> заказчик, поставщик, разработчик, оператор, служба сопровождения и другие стороны,
	участвующие в жизненном цикле ПП, управляют выполнением своих процессов. Менеджер является связующим звеном между
	организационными и основными процессами.</p>
<p>В<em> аспекте эксплуатации</em> оператор, эксплуатирующий систему, предоставляет необходимые услуги пользователям.
</p>
<p>В<em> инженерном аспекте</em> разработчик или служба сопровождения решают соответствующие технические задачи,
	разрабатывая или модифицируя ПП.</p>
<p>В<em> аспекте поддержки</em> службы, реализующие вспомогательные процессы, предоставляют необходимые услуги всем
	остальным участникам работ. В рамках аспекта поддержки можно выделить аспект управления качеством ПП.</p>
<p><img src="2.jpeg"/></p>
<p><strong>рис.</strong> 1.1. Связь между процессами жизненного цикла программного продукта</p>
<p><strong>Microsoft Solutions Framework</strong></p>
<p>Microsoft Solutions Framework (MSF) - это методология ведения проектов и разработки решений, базирующаяся на
	принципах работы над продуктами самой фирмы Microsoft и предназначенная для использования в организациях,
	нуждающихся в концептуальной схеме для построения современных решений.</p>
<p><img src="3.png"/></p>
<p><br/><strong>Рис. 1.2.</strong>  Жизненный цикл в MSF</p>
<p>При управлении проектом четко ставится цель, которую необходимо достичь в результате, и учитываются ограничения,
	накладываемые на проект. Все виды ограничений могут быть отнесены к одному из трех видов: ограничения ресурсов,
	ограничения времени и ограничения возможностей. Эти три вида ограничений и приоритетность задач по их преодолению
	образуют треугольник приоритетов в MSF.</p>
<p><img src="4.png"/></p>
<p><br/><strong>Рис. 1.3.</strong>  Треугольник приоритетов в MSF</p>
<p><strong>Rational Unified Process</strong></p>
<p>Rational Unified Process - это методология создания программного обеспечения, оформленная в виде размещаемой на Web
	базы знаний, которая снабжена поисковой системой.</p>
<p><strong>eXtreme Programming</strong></p>
<p>Экстремальное программирование - сравнительно молодая методология разработки программных систем, основанная на
	постепенном улучшении системы и разработки ее очень короткими итерациями. </p>
<p>Вопросы:</p>
<ol>
	<li>Классы программных продуктов</li>
	<li>Организационные процессы жизненного цикла программного продукта</li>
	<li>Взаимосвязь между процессами жизненного цикла программного продукта</li>
	<li>Microsoft Solutions Framework</li>
	<li>Rational Unified Process</li>
	<li>eXtreme Programming</li>
</ol>
<h1><a id="_Toc454873023"></a>Лекция 3. Методы проектирования программных продуктов</h1>
<p>План:</p>
<ol>
	<li>Понятие жизненного цикла программы</li>
	<li>Каскадная модель</li>
	<li>Поэтапная модель с промежуточным контролем</li>
	<li>Спиральная модель ЖЦ</li>
	<li>V-образная модель</li>
	<li>Модель прототипирования</li>
	<li>Модель быстрой разработки приложений</li>
	<li>Многопроходная модель</li>
</ol>
<p><strong>Понятие жизненного цикла программы</strong></p>
<p>Жизненный цикл ПС - период его разработки и эксплуатации (использования), начиная от момента возникновения замысла ПС
	и заканчивая прекращением всех видов его использования.</p>
<p>Жизненный цикл ИС можно представить как ряд событий, происходящих с системой в процессе ее создания и
	использования.</p>
<p>Модель жизненного цикла отражает различные состояния системы, начиная с момента возникновения необходимости в данной
	ИС и заканчивая моментом ее полного выхода из употребления. Модель жизненного цикла - структура, содержащая
	процессы, действия и задачи, которые осуществляются в ходе разработки, функционирования и сопровождения программного
	продукта в течение всей жизни системы, от определения требований до завершения ее использования.</p>
<p>В настоящее время известны и используются следующие модели жизненного цикла:</p>
<ul>
	<li>Каскадная модель (рис. 2.1) предусматривает последовательное выполнение всех этапов проекта в строго
		фиксированном порядке. Переход на следующий этап означает полное завершение работ на предыдущем этапе.
	</li>
</ul>
<p><img alt="Каскадная модель ЖЦ ИС" src="5.gif"/></p>
<p><strong>Рис. 2.1.</strong>  Каскадная модель ЖЦ ИС</p>
<ul>
	<li>Поэтапная модель с промежуточным контролем (рис. 2.2). Разработка ИС ведется итерациями с циклами обратной связи
		между этапами. Межэтапные корректировки позволяют учитывать реально существующее взаимовлияние результатов
		разработки на различных этапах; время жизни каждого из этапов растягивается на весь период разработки.
	</li>
</ul>
<p><img alt="Поэтапная модель с промежуточным контролем" src="6.gif"/></p>
<p><strong>Рис. 2.2.</strong>  Поэтапная модель с промежуточным контролем</p>
<ul>
	<li>Спиральная модель (рис. 2.3). На каждом витке спирали выполняется создание очередной версии продукта, уточняются
		требования проекта, определяется его качество и планируются работы следующего витка. Особое внимание уделяется
		начальным этапам разработки - анализу и проектированию, где реализуемость тех или иных технических решений
		проверяется и обосновывается посредством создания прототипов (макетирования).
	</li>
</ul>
<p><img alt="Спиральная модель ЖЦ ИС" src="7.gif"/></p>
<p><br/><strong>Рис. 2.3.</strong>  Спиральная модель ЖЦ ИС</p>
<p>А также их разновидности.</p>
<ul>
	<li>V-образная модель. Особое внимание уделяется верификации и аттестации ПП. Модель показывает, что тестирование
		продукта обсуждается, проектируется и планируется, начиная с ранних этапов жизненного цикла разработки. От
		каскадной модели V-образная модель унаследовала последовательную структуру, в соответствии с которой каждая
		последующая фаза начинается только после успешного завершения предыдущей фазы.
	</li>
</ul>
<p><img src="8.jpeg"/></p>
<p><strong>Рис. 2.4.</strong>  V-образная модель</p>
<ul>
	<li><em>Модель прототипирования</em> позволяет создать прототип ПП до или в течение этапа составления требований к
		ПП. В результате прототипирования разработчик демонстрирует пользователям готовый прототип, а пользователи
		оценивают его функционирование. После этого определяются проблемы, над устранением которых совместно работают
		пользователи и разработчики. Этот процесс продолжается до тех пор, пока пользователи не будут удовлетворены
		степенью соответствия ПП, поставленным перед ним требованиям.
	</li>
</ul>
<p><img src="9.png"/></p>
<p><strong>Рис. 2.5.</strong>  Модель прототипирования</p>
<ul>
	<li><em>Модель быстрой разработки приложений (RAD-модель).</em> В RAD-модели конечный пользователь играет решающую
		роль. В тесном взаимодействии с разработчиками он участвует в формировании требований и апробации их на
		работающих прототипах. При автоматизации программирования и повторном использовании кода, применяемых в
		RAD-модели, большую часть работы составляют планирование и проектирование.
	</li>
</ul>
<p><img src="10.png"/></p>
<p><strong>Рис. 2.6.</strong>  Модель быстрой разработки приложений (RAD-модель).</p>
<ul>
	<li><em>Многопроходная модель </em>— это несколько итераций процесса построения прототипа ПП с добавлением на каждой
		следующей итерации новых функциональных возможностей или повышением эффективности ПП. Сначала выполняются
		конструирование, тестирование и реализация базовых функций, составляющих основу ПП. Последующие итерации
		направлены на улучшение функциональных возможностей ПП.
	</li>
</ul>
<p><img src="11.jpeg"/></p>
<p><strong>Рис. 2.7.</strong>  Многопроходная модель</p>
<p>На практике наибольшее распространение получили две основные модели жизненного цикла:</p>
<ul>
	<li>каскадная модель (характерна для периода 1970-1985 гг.);</li>
	<li>спиральная модель (характерна для периода после 1986.г.).</li>
</ul>
<p>Вопросы:</p>
<ol>
	<li>Понятие жизненного цикла программы</li>
	<li>Каскадная модель</li>
	<li>Поэтапная модель с промежуточным контролем</li>
	<li>Спиральная модель ЖЦ</li>
	<li>V-образная модель</li>
	<li>Модель прототипирования</li>
	<li>Модель быстрой разработки приложений</li>
	<li>Многопроходная модель</li>
</ol>
<h1><a id="_Toc454873024"></a>Лекция 4. Проектирование интерфейса пользователя</h1>
<p>План:</p>
<ol>
	<li>Этапы разработки программного обеспечения</li>
	<li>Анализ требований, предъявленных системе</li>
	<li>Определение спецификаций</li>
	<li>Проектирование</li>
	<li>Кодирование.</li>
	<li>Тестирование</li>
</ol>
<p><strong>Этапы разработки программного обеспечения</strong></p>
<p>Как правило, выделяют шесть этапов (в скобках указано распределение затрат по этапам</p>
<p>разработки): </p>
<p>- анализ требований, предъявляемых системе(10%); </p>
<p>- определение спецификаций(10%); </p>
<p>- проектирование(15%); </p>
<p>- кодирование(20%); </p>
<p>- тестирование: </p>
<p>1. автономное(25%); </p>
<p>2. комплексное(20%); </p>
<p>- эксплуатация и сопровождение; </p>
<p><strong>Анализ требований, предъявленных системе. </strong></p>
<p>На этом этапе формулируются целевое назначение и основные свойства разрабатываемой</p>
<p>программной системы. </p>
<p>1. Если предметом разработки является не программная система, а более сложная система, </p>
<p>включающая в себя программы только в качестве составной части, требования формируются ко</p>
<p>всему предмету разработки. </p>
<p>2. Если предметом разработки является программная система, то тогда используются методы</p>
<p>составления исходных описаний. Одним из самых эффективных методов исходных описаний</p>
<p>является метод структурного анализа, а именно декомпозиции объекта. </p>
<p>В общем случае на этом этапе внимание должно быть сосредоточено на интерфейсе между</p>
<p>человеком и ЭВМ. Базовые требования для программных подсистем: </p>
<p>- время обработки(работы) программы; </p>
<p>- стоимость обработки; </p>
<p>- вероятность ошибки; </p>
<p>- реакция на непредсказуемые действия пользователя; </p>
<p>Особое внимание следует уделять пространственно-временным ограничениям и средствам</p>
<p>системы, которые в будущем могут претерпеть изменения. К важнейшим требованиям относятся</p>
<p>ресурсные требования и затраты на реализацию системы. </p>
<p><strong>Определение спецификаций. </strong></p>
<p>На этом этапе осуществляется точное описание реализуемых функций, а также задаются</p>
<p>структура входных и выходных данных, методы и средства их размещения. Определяются</p>
<p>алгоритмы обработки данных. </p>
<p>Центральным вопросом определения спецификаций является проблема организации базы</p>
<p>данных(если новая система создается на основе старой, то частью спецификации является схема</p>
<p>приведения старой БД к ному формату), а так же комплекс вопросов связанный со структурой</p>
<p>файлов и работы с ними. </p>
<p>Функциональные спецификации- это документ, являющийся основополагающим при</p>
<p>разработке системе, так как имеет ее конкретное описание. В них должны быть представлены</p>
<p>данные для тестирования элементов системы и системы целиком. В общем случае, спецификации</p>
<p>определяют те функции, которые должны выполнять система. </p>
<p>Спецификации можно использовать для начальных оценок временных затрат, числа</p>
<p>специалистов и других необходимых ресурсов. </p>
<p><strong>Проектирование. </strong></p>
<p>На стадии проектирования разрабатываются алгоритмы, задаваемые спецификациями, и</p>
<p>формируется общая структура вычислительной системы. При этом система разбивается на</p>
<p>составные части, чтобы ответственность за реализацию каждой составной части можно было бы</p>
<p>возложить на одного или группу разработчиков. При этом выдвигаются сформулированные</p>
<p>требования: </p>
<p>- реализуемые функции; </p>
<p>- размеры; </p>
<p>- время выполнения; </p>
<p>И тд. </p>
<p>Схема проектирования программных систем: </p>
<p><img src="12.png"/></p>
<p>Проектирование– это описание процесса обработки информации, определенных в</p>
<p>спецификациях. Поскольку в начале проектирования решение ряда функциональных задач</p>
<p>зачастую не определено, процесс разбиения на подзадачи может быть весьма сложным. </p>
<p><strong>Кодирование. </strong></p>
<p>Это этап разработки программного обеспечения, посредством алгоритмических языков</p>
<p>высокого уровня. По статистике64% всех ошибок вносятся на этапе проектирования и36% на</p>
<p>этапе кодирования. </p>
<p><strong>Тестирование. </strong></p>
<p>Этап тестирования обычно в фин. затратах составляет половину расходов на создание</p>
<p>системы. В процессе тестирования используются данные, характерные для системы в рабочем</p>
<p>состоянии. </p>
<p>Тестирование подразумевает три стадии: </p>
<p>- Автономное. Модуль проверяется с помощью данных, подготовленных программистом. </p>
<p>При этом программная среда модуля имитируется с помощью программ управления тестированием, </p>
<p>содержащих фиктивные программы, вместо реальных., с которыми имеется обращение из модуля. </p>
<p>Такую процедуру называют программным тестированием, а программу тестирования- UUT. </p>
<p>- Комплексное. В процессе тестирования проводится совместная проверка групп</p>
<p>программных компонентов. На данном этапе обнаруживаются ошибки, пропущенные на стадии</p>
<p>автономного тестирования. Исправление этих ошибок может составлять до¼ общих затрат. </p>
<p>- Системное. Завершающий этап проверки системы, то есть проверка системы в целом с</p>
<p>помощью независимых тестов. </p>
<p>Вопросы:</p>
<ol>
	<li>Этапы разработки программного обеспечения</li>
	<li>Анализ требований, предъявленных системе</li>
	<li>Определение спецификаций</li>
	<li>Проектирование</li>
	<li>Кодирование.</li>
	<li>Тестирование</li>
</ol>
<h1><a id="_Toc454873025"></a>Лекция 5. Структурное программирование</h1>
<p>План:</p>
<ol>
	<li>Общая характеристика структурного программирования</li>
	<li>Подчинение структур</li>
</ol>
<p><strong>Общая характеристика структурного программирования</strong></p>
<p>На самом деле изложение структурного стиля не может уместиться в рамки одной лекции. Но данный стиль программирования
	(вернее, его вариант, основанный на <a id="keyword1"></a><em>циклах</em> и массивах, слегка пополненный рекурсивными
	процедурами) описывается и навязывается как единственно возможный во всех ныне предлагаемых учебных пособиях по
	программированию на традиционных языках. В связи с этим мы имеем право предположить, что обучающийся знаком с ним
	(более того, знаком только с ним, и мы надеемся, что он еще не потерял способность воспринимать другие стили). И
	хотя Вы считаете, что с этим вариантом структурного стиля уже освоились, особенности, опускаемые в традиционных
	изложениях, могут полностью изменить Ваш взгляд на данный стиль.</p>
<p>В качестве методики структурного программирования <a id="keyword6"></a><em>Э. Дейкстра</em> предложил пользоваться
	лишь конструкциями <a id="keyword7"></a><em>цикла</em> и условного оператора, изгоняя go to как концептуально
	противоречащее этому стилю</p>
<p>Пожалуй, это первое <a id="keyword8"></a><em>концептуальное противоречие</em>, явно отмеченное и учтенное в теории и
	практике программирования (и даже во всей современной науке). Но, поскольку не было даже наметок теории
	неформализуемых понятий, и на работу с ними переносили <a id="keyword9"></a><em>опыт</em> работы с малыми
	формализациями, структурное противоречие было воспринято следующим образом.</p>
<p>Структурное <a id="keyword18"></a><em>программирование</em> естественно возникает во многих классах задач, прежде
	всего в таких, где <strong>задача естественно расщепляется на подзадачи, а информация - на достаточно независимые
		структуры данных</strong>. Основной его <a id="keyword19"></a><em>инвариант</em>:<strong>действия и условия
		локальны</strong>.</p>
<p>Необходимой чертой хорошей реализации структурного стиля программирования является соблюдение согласованности, а в
	идеале и единства, следующих компонентов программы:</p>
<ol>
	<li><strong>Структура информационного пространства</strong>. Содержательно любую задачу можно описать как
		переработку объектов, полный набор которых называется <strong>информационным пространством</strong> задачи.
	</li>
	<li><strong>Структуры управления</strong>. Стиль структурного программирования в его общепринятом варианте
		предполагает использование строго ограниченного набора <a id="keyword21"></a><em>управляющих конструкций</em>:
		последовательность операторов, условные и выбирающие операторы, все вычислительные ветви которых сходятся в
		одной точке программы, а также процедуры, вычисления которых всегда заканчиваются возвратом управления в точку
		вызова.
	</li>
	<li>К структурным операторам добавляются <strong>либо </strong><a
			id="keyword22"></a><em>циклы</em>, <strong>либо </strong><a id="keyword23"></a><em>рекурсии</em>.
	</li>
</ol>
<p><strong>Все структуры подчиняются структуре информационного пространства</strong>.</p>
<p>Это общее требование конкретизируется в следующие.</p>
<ol>
	<li>Необходимо, чтобы структура управления программы была согласована со структурой ее информационного пространства.
		Каждой структуре управления соответствуют согласующиеся с ней структуры данных и часть информационного
		пространства. Это условие позволяет человеку легко отслеживать порядок выполнения конструкций в программе.
	</li>
	<li>Подзадачи могут обмениваться данными только посредством обращения к объектам из общей части их информационных
		пространств (в современных языках чаще всего к глобальным).
	</li>
	<li>Информационные потоки должны протекать согласно иерархии структур управления; мы должны четко видеть для каждого
		блока программы, что он имеет на входе и что дает на выходе. Таким образом, <strong>свойства каждого логически
			завершенного фрагмента программы должны ясно осознаваться и в идеале четко описываться в самом тексте
			программы и в сопровождающей ее </strong>документации.
	</li>
	<li>Описание переменных, представляющих перерабатываемые объекты, а также других, вспомогательных переменных при
		структурном программировании строго подчиняется разбиению задачи на подзадачи.
	</li>
	<li>Все <a id="keyword38"></a><em>призраки</em> действуют на своем структурном месте и соответствуют идеальным
		сущностям, которые, согласно парадоксу изобретателя, должны вводиться для эффективного решения задачи.
	</li>
	<li>Все <a id="keyword39"></a><em>подпорки</em> строго локализованы в том месте, где их вынуждены ввести. Желательно
		даже обозначать их по-другому, чем идеальные сущности, например, оставляя мнемонические имена лишь для идеальных
		сущностей, а <a id="keyword40"></a><em>подпорки</em> именовать джокерами типа x или i. Необходимо строго следить
		за тем, чтобы <a id="keyword41"></a><em>подпорки</em> не искажали идеальную структуру программы.
	</li>
</ol>
<p>Вопросы:</p>
<ol>
	<li>Общая характеристика структурного программирования</li>
	<li>Подчинение структур</li>
</ol>
<h1><a id="_Toc454873026"></a>Лекция 6. Объектно-ориентированное программирование</h1>
<p>План:</p>
<ol>
	<li>Объект</li>
	<li>Класс</li>
	<li>Инкапсуляция</li>
	<li>Наследование</li>
	<li>полиморфизм</li>
</ol>
<p>Объектно-ориентированное программирование (ООП) - это новый подход к созданию программ. </p>
<p><strong>Объект</strong> - это структурированная переменная, содержащая всю информацию о некотором физическом предмете
	или реализуемом в программе понятии. </p>
<p><strong>Класс</strong> - это описание множества объектов программирования (объектов) и выполняемых над ними действий.
</p>
<p>Это определение можно проиллюстрировать средствами классического C: </p>
<p><em>struct myclass /*класс - описание множества объектов*/ </em></p>
<p><em>{ int data1; </em></p>
<p><em>... }; </em></p>
<p><em>void method1(struct myclass *this,...) /*метод*/ </em></p>
<p><em>{ ... this-&gt;data1 ... } </em></p>
<p><em>void method2(struct myclass *this,...) /*метод*/ </em></p>
<p><em>{ ... this-&gt;data1 ... } </em></p>
<p><em>struct myclass obj1, obj2; /*объекты*/ </em></p>
<p><em>... method1(&amp;obj1,...); /*для работы с объектами*/ </em></p>
<p><em>... method2(&amp;obj2,...); /*применяются методы*/ </em></p>
<p></p>
<p>Основные понятия объектно-ориентированного программирования: <strong>инкапсуляция</strong>,
	<strong>наследование</strong> и <strong>полиморфизм</strong>. </p>
<p>“Эпизодическое” использование технологии ООП заключается в разработке отдельных, не связанных между собой классов и
	использовании их как необходимых программисту базовых типов данных, отсутствующих в языке. При этом общая структура
	программы остается традиционной (“от функции к функции”). Однако, строгое следование технологии ООП предполагает,
	что любая функция в про грамме представляет собой метод для объекта некоторого класса. Это не означает, что нужно
	вводить в программу какие попало классы ради того, чтобы написать необходимые для работы функции. Наоборот, класс
	должен формироваться в программе естественным образом, как только в ней возникает необходимость описания новых
	объектов программирования. С другой стороны, каждый новый шаг в разработке алгоритма также должен представлять собой
	разработку нового класса на основе уже существующих. В конце концов, вся программа в таком виде представляет собой
	объект некоторого класса с единственным методом run (выполнить). Именно этот переход (а не понятия класса и объекта,
	как таковые) создает психологический барьер перед программистом, осваивающим технологию ООП. </p>
<p>Программирование “от класса к классу” включает в себя ряд новых понятий. Прежде всего, это - инкапсуляция данных.
	<strong><em>Инкапсуляция</em></strong> - это механизм, который объединяет данные и код, манипулирующий с этими
	данными, а также защищает и то, и другое от внешнего вмешательства или неправильного использования. </p>
<p>В ООП код и данные могут быть объединены вместе (в так называемый “черный ящик”) при создании объекта. Внутри объекта
	коды и данные могут быть закрытыми или открытыми. Закрытые коды или данные доступны только для других частей того же
	самого объекта и, соответственно, недоступны для тех частей программы, которые существуют вне объекта. Открытые коды
	и данные, напротив, доступны для всех частей программы, в том числе и для других частей того же самого объекта. </p>
<p>Для примера, рассмотрим такую структуру хранения информации как стек. Пользователя интересует выполнение операций:
	push(), top(), empty(), pop(), reset(), full(). Внутренняя реализация (адреса ячеек памяти, значения регистров
	процессора, имена массивов и т.д.) пользователя не интересует, то есть она должна быть скрыта от него. Пользователю
	нyжны только указанные операции, и он должен получить в свое распоряжение набор методов для их выполнения. Объектом
	программирования в этом случае является структура хранения информации типа стек. Соответственно, внутренняя
	организация объекта стек должна быть недоступна (закрыта) для пользователя, то есть все его попытки обратиться
	непосредственно к </p>
<p>элементам, обеспечивающим функционирование структуры хранения данных, должны отвергаться (выдавать сообщение об
	ошибке). А вызов методов, напротив, должен приводить к выполнению желаемого действия и является общедоступным. </p>
<p></p>
<p> Вторым по значимости понятием является <strong><em>наследование</em></strong>. Новый, или производный класс может
	быть определен на основе уже имеющегося, или базового класса. При этом но- вый класс сохраняет все свойства старого:
	данные объекта базового класса включаются в данные объекта производного, а методы базового класса могут быть вызваны
	для объекта производного класса, причем они будут выполняться над данными включенного в него объекта базового
	класса. Иначе говоря, новый класс наследует как данные старого класса, так и методы их обработки. Если объект
	наследует свои свойства от одного родителя, то говорят об одиночном наследовании. Если же объект наследует данные и
	методы от нескольких базовых классов, то говорят о множественном наследовании. Простой пример наследования -
	определение структуры, отдельный член которой является ранее определенной структурой. </p>
<p>Рассмотрим еще один пример. Например, базовый класс “животные” может иметь производные классы: “млекопитающие”,
	“рыбы”, “птицы” и т.д. Они будут наследовать все характеристики базового класса, но каждый из них может иметь и свои
	собственные свойства: </p>
<p>“рыбы – плавники”, “птицы – крылья” и т.д. </p>
<p>Третьим по значимости понятием является полиморфизм. <strong><em>Полиморфизм</em></strong> - это свойство, которое
	позволяет один и тот же идентификатор (одно и то же имя) использовать для решения двух и более схожих, но технически
	разных задач. Целью полиморфизма, применительно к ООП, является использование одного имени для задания действий,
	общих для ряда классов объектов. Такой полиморфизм основывается на возможности включения в данные объекта также и
	информации о методах их обработки (в виде указателей на функции). Принципиально важно, что такой объект становится
	“самодостаточным”. Будучи доступным в некоторой точке программы, даже при отсутствии полной информации о его типе,
	он всегда может корректно вызвать свойственные ему методы. Таким образом, полиморфная функция - это семейство
	функций с одним и тем же именем, но выполняющие различные действия в зависимости от условий вызова. </p>
<p>Например, нахождение абсолютной величины в языке С требует трех разных функций: <em>int abs(int); long labs(long);
	double fabs(double); </em></p>
<p>Эти функции подсчитывают и возвращают абсолютную величину целых, длинных целых и чисел с плавающей точкой
	соответственно. С точки зрения полиморфизма, каждую из этих функций может быть названа abs(), а тип данных, который
	используется при вызове функции, определяет, какая конкретная версия функции действительно выполняется. </p>
<p>Вопросы:</p>
<ol>
	<li>Объект</li>
	<li>Класс</li>
	<li>Инкапсуляция</li>
	<li>Наследование</li>
	<li>полиморфизм</li>
</ol>
<h1><a id="_Toc454873027"></a>Лекция 7. Консультационное обеспечение качества программ</h1>
<p>План:</p>
<ol>
	<li>ЕСПД</li>
	<li>стандарт ISO/IEC 12207: 1995-08-01</li>
	<li>Стандарты комплекса ГОСТ 34</li>
	<li>Перечень документов ЕСПД</li>
</ol>
<p><strong>Понятие о ЕСПД</strong></p>
<p>Основу отечественной нормативной базы в области документирования ПС составляет комплекс стандартов Единой системы
	программной документации (ЕСПД). Основная и большая часть комплекса ЕСПД была разработана в 70-е и 80-е годы. Сейчас
	этот комплекс представляет собой систему межгосударственных стандартов стран СНГ (ГОСТ), действующих на территории
	Российской Федерации на основе межгосударственного соглашения по стандартизации. </p>
<p>Стандарты ЕСПД в основном охватывают ту часть документации, которая создается в процессе разработки ПС, и связаны, по
	большей части, с документированием функциональных характеристик ПС. Следует отметить, что стандарты ЕСПД (ГОСТ 19)
	носят рекомендательный характер. Впрочем, это относится и ко всем другим стандартам в области ПС (ГОСТ 34,
	Международному стандарту ISO/IEC, и др.). Дело в том, что в соответствии с Законом РФ &quot;О стандартизации&quot;
	эти стандарты становятся обязательными на контрактной основе — то есть при ссылке на них в договоре на разработку
	(поставку) ПС. </p>
<p>Говоря о состоянии ЕСПД в целом, можно констатировать, что большая часть стандартов ЕСПД морально устарела. </p>
<p>К числу основных недостатков <strong>ЕСПД</strong> можно отнести: </p>
<ul>
	<li>ориентацию на единственную, &quot;каскадную&quot; модель жизненного цикла (ЖЦ) ПС;</li>
	<li>отсутствие четких рекомендаций по документированию характеристик качества ПС;</li>
	<li>отсутствие системной увязки с другими действующими отечественными системами стандартов по ЖЦ и документированию
		продукции в целом, например, ЕСКД;
	</li>
	<li>нечетко выраженный подход к документированию ПС как товарной продукции;</li>
	<li>отсутствие рекомендаций по самодокументированию ПС, например, в виде экранных меню и средств оперативной помощи
		пользователю (&quot;хелпов&quot;);
	</li>
	<li>отсутствие рекомендаций по составу, содержанию и оформлению перспективных документов на ПС, согласованных с
		рекомендациями международных и региональных стандартов.
	</li>
</ul>
<p>Надо сказать, что наряду с комплексом ЕСПД официальная нормативная база РФ в области документирования ПС и в смежных
	областях включает ряд перспективных стандартов (отечественного и международного уровней). </p>
<p>Международный стандарт <strong>ISO/IEC 12207: 1995-08-01</strong> на организацию ЖЦ продуктов программного
	обеспечения (ПО) — казалось бы весьма неконкретный, но вполне новый и отчасти &quot;модный&quot; стандарт. </p>
<p>Стандарты комплекса <strong>ГОСТ 34</strong> на создание и развитие автоматизированных систем (АС) — обобщенные, но
	воспринимаемые как весьма жесткие по структуре ЖЦ и проектной документации. Но эти стандарты многими считаются
	бюрократическими до вредности и консервативными до устарелости. Насколько это так, а насколько ГОСТ 34 остается
	работающим с пользой — полезно разобраться. </p>
<p>Тем не менее, до пересмотра всего комплекса, многие стандарты ЕСПД могут с пользой применяться в практике
	документирования ПС. Эта позиция основана на следующем: </p>
<ul>
	<li>стандарты ЕСПД вносят элемент упорядочения в процесс документирования ПС;</li>
	<li>предусмотренный стандартами ЕСПД состав программных документов вовсе не такой &quot;жесткий&quot;, как некоторым
		кажется: стандарты позволяют вносить в комплект документации на ПС дополнительные виды
	</li>
	<li>стандарты ЕСПД позволяют вдобавок мобильно изменять структуры и содержание установленных видов ПД исходя из
		требований заказчика и пользователя.
	</li>
</ul>
<p>При этом стиль применения стандартов может соответствовать современному общему стилю адаптации стандартов к специфике
	проекта: заказчик и руководитель проекта выбирают уместное в проекте подмножество стандартов и ПД, дополняют
	выбранные ПД нужными разделами и исключают ненужные, привязывают создание этих документов к той схеме ЖЦ, которая
	используется в проекте. </p>
<p>Стандарты ЕСПД (как и другие ГОСТы) подразделяют на группы, приведённые в таблице: </p>
<table>
	<tr>
		<td><p><strong>Kод группы</strong></p></td>
		<td><p><strong>Наименование группы</strong></p></td>
	</tr>
	<tr>
		<td><p>0</p></td>
		<td><p>Общие положения</p></td>
	</tr>
	<tr>
		<td><p>1</p></td>
		<td><p>Основополагающие стандарты</p></td>
	</tr>
	<tr>
		<td><p>2</p></td>
		<td><p>Правила выполнения документации разработки</p></td>
	</tr>
	<tr>
		<td><p>3</p></td>
		<td><p>Правила выполнения документации изготовления</p></td>
	</tr>
	<tr>
		<td><p>4</p></td>
		<td><p>Правила выполнения документации сопровождения </p></td>
	</tr>
	<tr>
		<td><p>5</p></td>
		<td><p>Правила выполнения эксплуатационной документации</p></td>
	</tr>
	<tr>
		<td><p>6</p></td>
		<td><p>Правила обращения программной документации</p></td>
	</tr>
	<tr>
		<td><p>7</p></td>
		<td rowspan="2"><p>Резервные группы</p></td>
	</tr>
	<tr>
		<td><p>8</p></td>
	</tr>
	<tr>
		<td><p>9</p></td>
		<td><p>Прочие стандарты</p></td>
	</tr>
</table>
<p>Обозначение стандарта ЕСПД должно состоять из: </p>
<ul>
	<li>числа 19 (присвоенных классу стандартов ЕСПД);</li>
	<li>одной цифры (после точки), обозначающей код классификационной группы стандартов, указанной таблице;</li>
	<li>двузначного числа (после тире), указывающего год регистрации стандарта.</li>
</ul>
<p><strong>Перечень документов ЕСПД.</strong></p>
<ol>
	<li>ГОСТ 19.001-77 ЕСПД. Общие положения.</li>
	<li>ГОСТ 19.101-77 ЕСПД. Виды программ и программных документов.</li>
	<li>ГОСТ 19.102-77 ЕСПД. Стадии разработки.</li>
	<li>ГОСТ 19.103-77 ЕСПД. Обозначение программ и программных документов.</li>
	<li>ГОСТ 19.104-78 ЕСПД. Основные надписи.</li>
	<li>ГОСТ 19.105-78 ЕСПД. Общие требования к программным документам.</li>
	<li>ГОСТ 19.106-78 ЕСПД. Требования к программным документам, выполненным печатным способом.</li>
	<li>ГОСТ 19.201-78 ЕСПД. Техническое задание. Требования к содержанию и оформлению.</li>
	<li>ГОСТ 19.202-78 ЕСПД. Спецификация. Требования к содержанию и оформлению.</li>
	<li>ГОСТ 19.301-79 ЕСПД. Порядок и методика испытаний.</li>
	<li>ГОСТ 19.401-78 ЕСПД. Текст программы. Требования к содержанию и оформлению.</li>
	<li>ГОСТ 19.402-78 ЕСПД. Описание программы.</li>
	<li>ГОСТ 19.404-79 ЕСПД. Пояснительная записка. Требования к содержанию и оформлению.</li>
	<li>ГОСТ 19.501-78 ЕСПД. Формуляр. Требования к содержанию и оформлению.</li>
	<li>ГОСТ 19.502-78 ЕСПД. Описание применения. Требования к содержанию и оформлению.</li>
	<li>ГОСТ 19.503-79 ЕСПД. Руководство системного программиста. Требования к содержанию и оформлению.</li>
	<li>ГОСТ 19.504-79 ЕСПД. Руководство программиста.</li>
	<li>ГОСТ 19.505-79 ЕСПД. Руководство оператора.</li>
	<li>ГОСТ 19.506-79 ЕСПД. Описание языка.</li>
	<li>ГОСТ 19.508-79 ЕСПД. Руководство по техническому обслуживанию. Требования к содержанию и оформлению.</li>
	<li>ГОСТ 19.604-78 ЕСПД. Правила внесения изменений в программные документы, выполняемые печатным способом.</li>
	<li>ГОСТ 19.701-90 ЕСПД. Схемы алгоритмов, программ, данных и систем. Условные обозначения и правила выполнения.
	</li>
	<li>ГОСТ 19.781-90. Обеспечение систем обработки информации программное.</li>
</ol>
<p>Из всех стандартов ЕСПД остановимся только на тех, которые могут чаще использоваться на практике. Первым укажем
	стандарт, который можно использовать при формировании заданий на программирование. </p>
<p><em>ГОСТ (СТ СЭВ) 19.201-78 (1626-79). ЕСПД. Техническое задание. Требование к содержанию и оформлению. (Переиздан в
	ноябре 1987г с изм.1).</em></p>
<p>Техническое задание (ТЗ) содержит совокупность требований к ПС и может использоваться как критерий проверки и приемки
	разработанной программы. Поэтому достаточно полно составленное (с учетом возможности внесения дополнительных
	разделов) и принятое заказчиком и разработчиком, ТЗ является одним из основополагающих документов проекта ПС. </p>
<p>Техническое задание должно содержать следующие разделы: </p>
<ul>
	<li>введение;</li>
	<li>основания для разработки;</li>
	<li>назначение разработки;</li>
	<li>требования к программе или программному изделию;</li>
	<li>требования к программной документации;</li>
	<li>технико-экономические показатели;</li>
	<li>стадии и этапы разработки;</li>
	<li>порядок контроля и приемки;</li>
	<li>в техническое задание допускается включать приложения.</li>
</ul>
<p>В зависимости от особенностей программы или программного изделия допускается уточнять содержание разделов, вводить
	новые разделы или объединять отдельные из них. </p>
<p>Следующий стандарт <em>ГОСТ (СТ СЭВ) 19.101-77 (1626-79). ЕСПД. Виды программ и программных документов (Переиздан в
	ноябре 1987г с изм.1). </em><br/>Устанавливает виды программ и программных документов для вычислительных машин,
	комплексов и систем независимо от их назначения и области применения. </p>
<p>Вопросы:</p>
<ol>
	<li>ЕСПД</li>
	<li>стандарт ISO/IEC 12207: 1995-08-01</li>
	<li>Стандарты комплекса ГОСТ 34</li>
	<li>Перечень документов ЕСПД</li>
</ol>
<h1><a id="_Toc454873028"></a>Лекция 8. Экзамены и тесты как средства поиска ошибок в программном обеспечении</h1>
<p>План:</p>
<ol>
	<li>Виды ошибок</li>
	<li>Виды контроля ПС</li>
	<li>Основные цели и принципы отладки</li>
	<li>Основные принципы организации тестирования ПС</li>
</ol>
<p><strong>Виды ошибок:</strong></p>
<ol>
	<li>Ошибки в описании задачи</li>
</ol>
<p>Отсутствие взаимопонимания между программистом и заказчиком и качественное определение требований, приводит к
	получению нежелательных результатов, такие ошибки являются разрушительными и ведут к полному
	перепрограммированию.</p>
<ol>
	<li>Ошибки в выборе алгоритма</li>
</ol>
<p>Неэффективный алгоритм может привести весь процесс программирования также к нежелательному результату, т.е. не
	эффективный метод может привести к перепрограммированию.</p>
<ol>
	<li>Ошибки анализа</li>
</ol>
<p>Эти ошибки связаны с неполным учетом возникающих ситуаций (например, пренебрежение или не знание области допустимых
	значений переменных могут привести к нереальным результатам). Мелкие или крупные логические ошибки из которых можно
	выделить :</p>
<ul>
	<li>
		<ol>
			<li>отсутствие заданий начальных значений</li>
			<li>не верное условие окончания цикла</li>
			<li>не верная индексация цикла</li>
			<li>отсутствие задания обнуления циклов.</li>
		</ol>
	</li>
</ul>
<ol>
	<li>Ошибки общего характера - ошибки из-за не достаточного знания тонкостей языка или самой системы или машины.</li>
	<li>Синтаксические ошибки - ошибки, вызванные не правильным написанием операторов.</li>
	<li>Семантические ошибки – неправильное использование написанных операторов.</li>
	<li>Ошибки в данных</li>
</ol>
<p><strong>Виды контроля ПС: </strong></p>
<ul>
	<li>Визуальный,</li>
	<li>Статический</li>
	<li>динамический</li>
</ul>
<p>Визуальный контроль - это проверка программ “ за столом “, без использования компьютера. </p>
<ol>
	<li>сначала осуществляется чтение программы</li>
	<li>затем осуществляется сквозной контроль программы (ее ручная прокрутка на нескольких заранее подобранных простых
		тестах).
	</li>
</ol>
<p>Статический контроль - это проверка программы по ее тексту (без выполнения) с помощью инструментальных средств. <em>Формы
	статического контроля:</em></p>
<ul>
	<li>
		<ol>
			<li>синтаксический контроль программы с помощью компилятора, при котором проверяется соответствие текста
				программы синтаксическим правилам языка программирования.
			</li>
			<li>контроль правдоподобия программы, то есть выявление в ее тексте конструкций, которые хотя и
				синтаксически корректны, но скорее всего содержат ошибку или свидетельствуют о ней. <em>Основные
					неправдоподобные ситуации</em> :
			</li>
		</ol>
	</li>
	<li>использование в программе неинициализированных переменных (то есть переменных, не получивших начального
		значения) ;
	</li>
	<li>наличие в программе описаний переменных, процедур, меток, файлов, в дальнейшем не используемых в ее тексте;</li>
	<li>наличие в тексте программы фрагментов, никогда не выполняющихся;</li>
	<li>наличие в тексте программы переменных, ни разу не используемых для чтения после присваивая им значений;</li>
	<li>наличие в тексте программы заведомо бесконечных циклов ;</li>
</ul>
<p>Даже если присутствие в тексте программы неправдоподобных конструкций не приводит к ее неправильной работе,
	исправление этого фрагмента повысит ясность и эффективность программы, т. е. благотворно скажется на ее
	качестве.</p>
<p><strong>Основные цели и принципы отладки</strong></p>
<p><strong><em>Отладка </em>ПС</strong> - это деятельность, направленная на обнаружение и исправление ошибок в ПС с
	использованием процессов выполнения его программ. </p>
<p><strong><em>Тестирование </em>ПС</strong> - это процесс выполнения его программ на некотором наборе данных, для
	которого заранее известен результат применения или известны правила поведения этих программ. Указанный набор данных
	называется тестовым или просто <em>тестом</em>. </p>
<p>Таким образом, отладку можно представить в виде многократного повторения трех процессов: тестирования, в результате
	которого может быть констатировано наличие в ПС ошибки, поиска места ошибки в программах и документации ПС и
	редактирования программ и документации с целью устранения обнаруженной ошибки. </p>
<p><strong>Отладка = Тестирование + Поиск ошибок + Редактирование. </strong></p>
<p>Каждому программисту известно, сколько времени и сил уходит на отладку программ. На этот этап приходится около 50%
	общей стоимости разработки программного обеспечения. Тестирование - это процесс выполнения программы с целью
	обнаружения в ней ошибок. Но Нельзя гарантировать, что тестированием ПС можно установить наличие каждой имеющейся в
	ПС ошибки. Поэтому возникает две задачи:</p>
<ol>
	<li>подготовить такой набор тестов и применить к ПС, чтобы обнаружить в нем по возможности большее число ошибок.
		Однако чем дольше продолжается процесс тестирования (и отладки в целом), тем большей становится стоимость ПС.
	</li>
	<li>определить момент окончания отладки ПС (или отдельной его компоненты). Отладка заканчивается, когда тестами
		охвачено множество различных ситуаций, возникающих при выполнении программ ПС, и относительно редко появляются
		ошибки в ПС на последнем отрезке процесса тестирования.
	</li>
</ol>
<p><strong>Советы по организации тестирования</strong></p>
<ul>
	<li>необходимой частью каждого теста должно являться описание ожидаемых результатов работы программы, чтобы можно
		было быстро выяснить наличие или отсутствие ошибки в ней;
	</li>
	<li>должны являться правилом доскональное изучение результатов каждого теста, чтобы не пропустить малозаметную на
		поверхностный взгляд ошибку в программе;
	</li>
	<li>тестирования не должно планироваться исходя из предположения, что в программе не будут обнаружены ошибки;</li>
	<li>следует всегда помнить, что тестирование - творческий процесс, а не относиться к нему как к рутинному занятию.
	</li>
</ul>
<p><strong>Основные принципы организации тестирования ПС</strong></p>
<p>Существует 4 этапа тестирования многомодульных ПС:</p>
<ol>
	<li>тестирование отдельных модулей;</li>
	<li>совместное тестирование модулей;</li>
	<li>тестирование функций программного комплекса;</li>
	<li>тестирование всего комплекса в целом.</li>
</ol>
<p>На первых двух этапах используются прежде всего методы структурного программирования. При структурном тестировании
	программа рассматривается как “белый ящик” (т.е. ее текст открыт для пользования). Происходит проверка логики
	программы. </p>
<p>Вопросы:</p>
<ol>
	<li>Виды ошибок</li>
	<li>Виды контроля ПС</li>
	<li>Основные цели и принципы отладки</li>
	<li>Основные принципы организации тестирования ПС</li>
</ol>
<p></p>
<h1><a id="_Toc454873029"></a>Лекция 9. Инструментальные средства разработки программ</h1>
<p>План:</p>
<ol>
	<li>Инструменты разработки программных средств</li>
	<li>Инструментальные среды разработки и сопровождения программных средств</li>
	<li>Инструментальные среды программирования</li>
	<li>CASE технологии</li>
</ol>
<p><strong>Инструменты разработки программных средств.</strong></p>
<p>В процессе разработки программных средств в той или иной мере используется компьютерная поддержка процессов
	разработки ПС. </p>
<p>Это достигается путем представления хотя бы некоторых программных документов ПС (прежде всего, программ) на
	компьютерных носителях данных (например, дисках) и предоставлению в распоряжение разработчика ПС <strong>специальных
		ПС </strong>или включенных в состав компьютера <strong>специальных устройств</strong>, созданных для какой-либо
	обработки таких документов. </p>
<p>В качестве такого специального ПС можно указать <strong>компилятор</strong> с какого-либо языка программирования.
</p>
<p><em>Компилятор</em> избавляет разработчика ПС от необходимости писать программы на языке компьютера, который для
	разработчика ПС был бы крайне неудобен, - вместо этого он составляет программы на удобном ему языке
	программирования, которые соответствующий компилятор автоматически переводит на язык компьютера. </p>
<p>В качестве специального устройства, поддерживающего процесс разработки ПС, может служит <strong>эмулятор</strong>
	какого-либо языка. </p>
<p><em>Эмулятор</em> позволяет выполнять (интерпретировать) программы на языке, отличном от языка компьютера,
	поддерживающего разработку ПС, например на языке компьютера, для которого эта программа предназначена. </p>
<p>ПС, предназначенное для поддержки разработки других ПС, будем <strong>называть программным инструментом разработки
	ПС,</strong> а устройство компьютера, специально предназначенное для поддержки разработки ПС, будем называть<strong>
	аппаратным инструментом разработки ПС.</strong></p>
<p>Инструменты разработки ПС могут использоваться в течении всего жизненного цикла ПС для работы с разными программными
	документами. Так текстовый редактор может использоваться для разработки практически любого программного
	документа. </p>
<p>С точки зрения функций, которые инструменты выполняют при разработке ПС, их можно разбить на следующие четыре группы:
	· </p>
<p>− редакторы,· </p>
<p>− анализаторы,· </p>
<p>− преобразователи,· </p>
<p>− инструменты, поддерживающие процесс выполнения программ. </p>
<p><em>Редакторы</em> поддерживают конструирование (формирование) тех или иных программных документов на различных
	этапах жизненного цикла. </p>
<p>Как уже упоминалось, для этого можно использовать один какойнибудь универсальный текстовый редактор. </p>
<p>Однако, более сильную поддержку могут обеспечить специализированные редакторы: для каждого вида документов - свой
	редактор. В частности, на ранних этапах разработки в документах могут широко использоваться графические средства
	описания (диаграммы, схемы и т.п.). В таких случаях весьма полезными могут быть графические редакторы. </p>
<p>На этапе программирования (кодирования) вместо текстового редактора </p>
<p><strong>Инструментальные среды разработки и сопровождения программных средств.</strong></p>
<p> Для таких инструментальных сред характерно: </p>
<p>− во-первых, использование как программных, так и аппаратных инструментов, и, </p>
<p>− во-вторых, определенная ориентация либо на конкретный язык программирования, либо на конкретную предметную
	область. </p>
<p>Инструментальная среда не обязательно должна функционировать на том компьютере, на котором должно будет применяться
	разрабатываемое с помощью ее ПС. Часто такое совмещение бывает достаточно удобным (если только мощность
	используемого компьютера позволяет это): не нужно иметь дело с компьютерами разных типов, в разрабатываемое ПС можно
	включать компоненты самой инструментальной среды. </p>
<p>Различают <strong>три основных класса инструментальных сред разработки и сопровождения ПС </strong>· </p>
<p>− среды программирования, · </p>
<p>− рабочие места компьютерной технологии,· </p>
<p>− инструментальные системы технологии программирования. Среда программирования предназначена </p>
<p>в основном для поддержки процессов программирования </p>
<p>(кодирования), тестирования и отладки ПС. </p>
<p>Рабочее место компьютерной технологии ориентировано на поддержку ранних этапов разработки ПС (спецификаций) и
	автоматической генерации программ по спецификациям. </p>
<p>Инструментальная система технологии программирования предназначена для поддержки всех процессов разработки и
	сопровождения в течение всего жизненного цикла ПС и ориентирована на коллективную разработку больших программных
	систем с длительным жизненным циклом. </p>
<p>Для таких систем стоимость сопровождения обычно превышает стоимость разработки. </p>
<p><img src="13.jpeg"/></p>
<p>Рис. Основные классы инструментальных сред разработки и сопровождения ПС.</p>
<p><strong>Инструментальные среды программирования.</strong></p>
<p>Инструментальные среды программирования содержат прежде всего текстовый редактор, позволяющий конструировать
	программы на заданном языке программирования, инструменты, позволяющие компилировать или интерпретировать программы
	на этом языке, а также тестировать и отлаживать полученные программы. </p>
<p>Различают следующие <strong>классы инструментальных сред программирования</strong>: </p>
<p>− среды общего назначения;</p>
<p> −языково-ориентированные среды. </p>
<p><img src="14.jpeg"/></p>
<p>Рис. Классификация инструментальных сред программирования. </p>
<p><strong>Понятие компьютерной технологии разработки программных средств и ее рабочие места.</strong></p>
<p>Имеются некоторые трудности в выработке строгого определения CASE-технологии (компьютерной технологии разработки
	ПС). </p>
<p>CASE - это абревиатура от английского Computer-Aided Software Engineering (Компьютерно-Помогаемая Инженерия
	Программирования). Но без помощи (поддержки) компьютера ПС уже давно не разрабатываются (используется хотя бы
	компилятор). </p>
<p>В действительности, в это понятие вкладывается более узкий (специальный) смысл, который постепенно размывается (как
	это всегда бывает, когда какое-либо понятие не имеет строгого определения). </p>
<p>Первоначально под CASE понималась инженерия ранних этапов разработки ПС (определение требований, разработка внешнего
	описания и архитектуры ПС) с использованием программной поддержки </p>
<p>(программных инструментов). </p>
<p> Вопросы:</p>
<ol>
	<li>Инструменты разработки программных средств</li>
	<li>Инструментальные среды разработки и сопровождения программных средств</li>
	<li>Инструментальные среды программирования</li>
	<li>CASE технологии</li>
</ol>
<h1><a id="_Toc454873030"></a>Лекция 10. Коллективная разработка программных продуктов</h1>
<p>План:</p>
<ol>
	<li>Системы контроля версий</li>
	<li>CVS</li>
	<li>Subversion, SVN</li>
	<li>GIT</li>
	<li>Бесплатные VCS серверы</li>
</ol>
<p>Системы контроля версий</p>
<p>• Системы управления версиями (Version Control Systems, VCS) или Системы управления исходным кодом (Source Management
	Systems, SMS) — важный аспект разработки современного ПО.</p>
<p>• VCS предоставляет следующие возможности:</p>
<p>o Поддержка хранения файлов в репозитории.</p>
<p>o Поддержка истории версий файлов в репозитории.</p>
<p>o Нахождение конфликтов при изменении исходного кода и обеспечение синхронизации при работе в многопользовательской
	среде разработки.</p>
<p>o Отслеживание авторов изменений.</p>
<p>Классификация:</p>
<p>• Централизованные/распределённые — в централизованных системах контроля версий вся работа производится с центральным
	репозиторием, в распределённых — у каждого разработчика есть локальная копия репозитория.</p>
<p>• Блокирующие/не блокирующие — блокирующие системы контроля версий позволяют наложить запрет на изменение файла, пока
	один из разработчиков работает над ним, в неблокирующих один файл может одновременно изменяться несколькими
	разработчиками.</p>
<p>• Для текстовых данных/для бинарных данных — для VCS для текстовых данных очень важна поддержка слияния изменений,
	для VCS с инарными данными важна возможность блокировки.</p>
<p><img src="15.png"/><strong>Пример ветвления в проекте</strong></p>
<p><strong>CVS</strong></p>
<p>Одна из наиболее старых систем контроля версий. Создана в 1984 году как развитие RCS (Revision Control System),
	которая не поддерживала совместную работу.</p>
<p><strong>Subversion, SVN</strong></p>
<p>Subversion, SVN — свободная централизованная система управления версиями, официально выпущенная в 2004 году компанией
	CollabNet Inc.</p>
<p>• Копирование объектов с разветвлением истории.</p>
<p>• Поддержка ветвления: создания ветвей (копированием директорий) и слияние ветвей (переносом изменений)</p>
<p>• Поддержка меток (копированием директорий).</p>
<p>• Поддержка разделение прав пользователей.</p>
<p>• История изменений и копии объектов (в том числе ветви и метки) хранятся в виде связанных разностных копий.</p>
<p><strong>Subversion, SVN</strong></p>
<p><img src="16.png"/></p>
<p><strong>GIT</strong></p>
<p>В 2005 году он решил запилить свою VCS с простыми мерджами и децентрализированной структурой.</p>
<p>Достоинства:</p>
<p>• Простая работа с ветками</p>
<p>• Развитые средства интеграции с другими VCS</p>
<p>• Продуманная система команд, позволяющая удобно встраивать git команды в скрипты</p>
<p>• Репозитории git могут распространяться и обновляться общесистемными файловыми утилитами, такими как rsync</p>
<p>Недостатки:</p>
<p>• Отсутствие переносимой на другие операционные системы поддержки путей в кодировке Unicode</p>
<p>• Команды ориентированы на наборы изменений, а не на файлы.</p>
<p>• Использование для идентификации ревизий хешей SHA1</p>
<p>• Проблемы с производительностью</p>
<p><strong>GIT</strong></p>
<p><img src="17.png"/></p>
<p><strong>Бесплатные VCS серверы</strong></p>
<p>Есть много сервисов, которые предоставляют открытые репозитории для совместной работы:</p>
<p>•sourceforge.net — SVN, Git, Mercurial, Bazaar, CVS репозитории.</p>
<p>•code.google.com — SVN, Git, Mercurial репозитории.</p>
<p>•github.com — Git репозитории.</p>
<p>•bitbucket.org — Git и Mercurial репозитории.</p>
<p>Вопросы:</p>
<ol>
	<li>Системы контроля версий</li>
	<li>CVS</li>
	<li>Subversion, SVN</li>
	<li>GIT</li>
	<li>Бесплатные VCS серверы</li>
</ol>
<p><a id="_Toc454873031"></a><a id="_Toc454872994"></a><strong>Литература</strong></p>
<ol>
	<li>Рудаков А.В. Технология разработки программных продуктов. – М.: “Издательский центр “Академия”, 2013;</li>
	<li>Рудаков А. В. Технология разработки программных продуктов. Практикум. – М.: “Издательский центр “Академия”,
		2014;
	</li>
	<li>Котляров В. П. Основы тестирования программного обеспечения. – М.: “Интернет-Университет Информационных
		Технологий; БИНОМ. Лаборатория знаний”, 2012;
	</li>
	<li>Э. Орама, Г. Уилсона. Идеальная разработка ПО. Рецепты лучших программистов. – СПб.: “Питер”, 2012;</li>
	<li>Партыка Т. Л., Попов И.И. Информационная безопасность. – М.: “Форум”, “ИНФРА- М”, 2010;</li>
	<li>Н. В. Макарова, В. Б. Волков. Информатика. – СПб.: “Питер”, 2011;</li>
	<li>Вендров А.М. Проектирование программного обеспечения экономических информационных систем: Учебник. - 2-е изд.,
		перераб. и доп. – М.: Финансы и статистика, 2012;
	</li>
	<li>C/C++. Структурное Программирование: Практикум / Т. А. Павловская. Ю. А. Щупак. – СПб.: “Питер”, 2013;</li>
	<li>Лафоре. Р. Объектно-ориентированное программирование в C++. – СПб.: “Питер”, 2013;</li>
</ol>
