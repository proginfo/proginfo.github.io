---
layout: page
title: Технология разработки программных продуктов. Пректические работы
---
{% raw %}
<p>Оглавление</p>
<p><a href="#_Toc454872983">Лабораторная работа №1: “Классификация программных продуктов” 3</a></p>
<p><a href="#_Toc454872984">Лабораторная работа №2: “Жизненный цикл программ” 12</a></p>
<p><a href="#_Toc454872985">Лабораторная работа №3: “Документирование программных средств” 20</a></p>
<p><a href="#_Toc454872986">Лабораторная работа №4: “Документирование программных средств” 25</a></p>
<p><a href="#_Toc454872987">Лабораторная работа №5: “Структура программных продуктов” 32</a></p>
<p><a href="#_Toc454872988">Лабораторная работа №6: “Стиль программирования” 41</a></p>
<p><a href="#_Toc454872989">Лабораторная работа №7: “Языки программирования” 49</a></p>
<p><a href="#_Toc454872990">Лабораторная работа №8: “Модульное программирование” 58</a></p>
<p><a href="#_Toc454872991">Лабораторная работа №9, 10, 11, 12, 13, 14: “Структурное программирование” 64</a></p>
<p><a href="#_Toc454872992">Лабораторная работа №15, 16, 17, 18, 19: “Объектно-ориентированное программирование” 68</a>
</p>
<p><a href="#_Toc454872993">Лабораторная работа №20: “Программирование и оптимизация программ” 99</a></p>
<p><a href="#_Toc454872994">Литература 112</a></p>
<h1><a id="_Toc454872983"></a>Лабораторная работа №1: “Классификация программных продуктов”</h1>
<p><strong>Порядок выполнения работы </strong></p>
<p>1. Ознакомьтесь с теоретическими основами в настоящих указаниях и конспектах лекций. </p>
<p>2. Получите задание у преподавателя. </p>
<p>3. Сделайте скриншоты (кнопка клавиатуры PrtSc) выполненных заданий в текстовом (Word) файле <em>Фамилия_ЛР</em></p>
<p>4. Составьте отчет по лабораторной работе. </p>
<p>5. Отчитайте работу преподавателю.</p>
<p><strong>Цель работы</strong></p>
<p>Изучение основ использования OpenGL и GLUT. Создание простейшего приложения с использованием OpenGL.</p>
<p><a id="2"></a><a id="1"></a><strong>1. Что такое GLUT?</strong></p>
<p>OpenGL является мультиплатформенной библиотекой, т.е. программы, написанные с помощью OpenGL, можно легко переносить
	на различные операционные системы, при этом получая один и тот же визуальный результат. Единственное, что плохо –
	это то, что для конкретной операционной системы необходимо по-своему производить настройку OpenGL. То есть,
	допустим, Вы написали OpenGL программу под Windows и захотели перенести её в Linux, код OpenGL должен перенестись
	без проблем, но операции с окнами, интерфейс управления, операции с устройствами ввода/вывода нужно заново
	переписать уже под другую операционную систему – Linux. К счастью, существует специальная мультиплатформенная
	библиотека, позволяющая решить вышеописанные проблемы. И называется эта библиотека – GLUT.</p>
<p><a id="2"></a><strong>2. Основные шаги для построения минимальной программы</strong></p>
<p>Прежде всего необходимо научиться самому основному – это созданию окна, в котором можно будет рисовать с помощью
	OpenGL. Минимальная программа, которая создает окно и что-нибудь рисует там, состоит из следующих шагов:</p>
<p>1. Инициализация GLUT</p>
<p>2. Установка параметров окна.</p>
<p>3. Создание окна.</p>
<p>4. Установка функций, отвечающих за рисование в окне и изменение формы окна.</p>
<p>5. Вход в главный цикл GLUT.</p>
<p>Рассмотрим все 5 пунктов поподробнее.</p>
<p>1. Инициализация GLUT производится командой: </p>
<p><em>void glutInit(int *argcp, char **argv);  </em></p>
<p>Первый параметр представляет собой указатель на количество аргументов в командной строке, а второй – указатель на
	массив аргументов. Обычно эти значения берутся из главной функции программы: int main(int argc, char *argv[]).</p>
<p>2. Установка параметров окна содержит в себе несколько этапов. Прежде всего, необходимо указать размеры окна:</p>
<p><em>void glutInitWindowSize(int width, int height);</em></p>
<p>Первый параметр width – ширина окна в пикселях, второй height – высота окна в пикселях. Если эту команду опустить, то
	GLUT сам установит размеры окна по умолчанию, обычно это 300x300.</p>
<p>Далее можно задать положение создаваемого окна относительно верхнего левого угла экрана. Делается это командой:</p>
<p><em>void glutInitWindowPosition(int x, int y); </em></p>
<p>Необходимо также установить для окна режим отображения информации, т. е. установить для окна такие параметры, как:
	используемая цветовая модель, количество различных буферов, и т.д. Для этого в GLUT существует команда:</p>
<p><em>void glutInitDisplayMode(unsigned int mode); </em></p>
<p>У команды имеется единственный параметр, который может быть представлен одной из следующих констант или комбинацией
	этих констант с помощью побитового ИЛИ.</p>
<table>
	<tr>
		<td><p>Константа</p></td>
		<td><p>Значение</p></td>
	</tr>
	<tr>
		<td><p>GLUT_RGB</p></td>
		<td><p>Для отображения графической информации используются 3 компоненты цвета RGB</p></td>
	</tr>
	<tr>
		<td><p>GLUT_RGBA</p></td>
		<td><p>То же что и RGB, но используется также 4 компонента ALPHA (прозрачность)</p></td>
	</tr>
	<tr>
		<td><p>GLUT_INDEX</p></td>
		<td><p>Цвет задается не с помощью RGB компонентов, а с помощью палитры. Используется для старых дисплеев, где
			количество цветов, например, 256</p></td>
	</tr>
	<tr>
		<td><p>GLUT_SINGLE</p></td>
		<td><p>Вывод в окно осуществляется с использованием 1 буфера. Обычно используется для статического вывода
			информации</p></td>
	</tr>
	<tr>
		<td><p>GLUT_DOUBLE</p></td>
		<td><p>Вывод в окно осуществляется с использованием 2 буферов. Применяется для анимации, чтобы исключить эффект
			мерцания</p></td>
	</tr>
	<tr>
		<td><p>GLUT_ACCUM</p></td>
		<td><p>Использовать также буфер накопления (Accumulation Buffer). Этот буфер применяется для создания
			специальных эффектов, например отражения и тени</p></td>
	</tr>
	<tr>
		<td><p>GLUT_ALPHA</p></td>
		<td><p>Использовать буфер ALPHA. Этот буфер, как уже говорилось, используется для задания 4-го компонента
			цвета – ALPHA. Обычно применяется для таких эффектов, как прозрачность объектов и антиалиасинг</p></td>
	</tr>
	<tr>
		<td><p>GLUT_DEPTH</p></td>
		<td><p>Создать буфер глубины. Этот буфер используется для отсечения невидимых линий в 3D пространстве при выводе
			на плоский экран монитора</p></td>
	</tr>
	<tr>
		<td><p>GLUT_STENCIL</p></td>
		<td><p>Буфер трафарета используется для таких эффектов, как вырезание части фигуры, делая этот кусок прозрачным.
			Например, наложив прямоугольный трафарет на стену дома, Вы получите окно, через которое можно увидеть, что
			находится внутри дома</p></td>
	</tr>
	<tr>
		<td><p>GLUT_STEREO</p></td>
		<td><p>Этот флаг используется для создания стереоизображений. Используется редко, так как для просмотра такого
			изображения нужна специальная аппаратура</p></td>
	</tr>
</table>
<p>Вот пример использования этой команды: void glutInitDisplayMode(GLUT_RGB | GLUT_DOUBLE); </p>
<p>3. Создание окна. После того как окно установлено, необходимо его создать. </p>
<p><em>int glutCreateWindow(const char *title);  </em></p>
<p>Эта команда создаёт окно с заголовком, который Вы укажете в качестве параметра, и возвращает HANDLER окна в виде
	числа int. Этот HANDLER обычно используется для последующих операций над этим окном, таких как изменение параметров
	окна и закрытие окна. </p>
<p>4. Установка функций, отвечающих за рисование в окне и изменение формы окна.</p>
<p>После того как окно, в которое будет выводиться графическая информация, подготовлено и создано, необходимо связать с
	ним процедуры, которые будут отвечать за вывод графической информации, следить за размерами окна, следить за
	нажатиями на клавиши и т.д. Самая первая и самая необходимая функция, которую мы рассмотрим, отвечает за рисование.
	Именно она всегда будет вызываться операционной системой, чтобы нарисовать (перерисовать) содержимое окна. Итак,
	задаётся эта функция командой:</p>
<p><em>void glutDisplayFunc(void (*func)(void));</em></p>
<p>Единственный параметр этой функции – это указатель на функцию, которая будет отвечать за рисование в окне. Например,
	чтобы функция void Draw(void), определенная в вашей программе, отвечала за рисование в окне, надо присоединить ее к
	GLUT следующим образом: glutDisplayFunc(Draw);</p>
<p>И ещё одна функция, которая является важной – это функция, которая отслеживает изменения окна. Как только у окна
	изменились размеры, необходимо перестроить вывод графической информации уже в новое окно с другими размерами. Если
	этого не сделать, то, например, увеличив размеры окна, вывод информации будет производиться в старую область окна, с
	меньшими размерами. Определить функцию, отвечающую за изменение размеров окна, нужно следующей командой:</p>
<p><em>void glutReshapeFunc(void (*func)(int width, int height));</em></p>
<p>Единственный параметр – это указатель на функцию, отвечающую за изменение размеров окна, которая как видно должна
	принимать два параметра width и height, соответственно ширина и высота нового (измененного) окна.</p>
<p>5. Вход в главный цикл GLUT.</p>
<p>Ну и последнее, что необходимо сделать, чтобы запустить программу – это войти в так называемый главный цикл GLUT.
	Этот цикл запускает на выполнение так называемое сердце GLUT, которое обеспечивает взаимосвязь между операционной
	системой и теми функциями, которые отвечают за окно, получают информацию от устройств ввода/вывода. Для того чтобы
	перейти в главный цикл GLUT, надо выполнить единственную команду:</p>
<p><em>void glutMainLoop(void);</em></p>
<p>Вот в принципе основные шаги для самой простейшей GLUT программы. Ниже приведена простейшая программа с
	использованием средств библиотеки GLUT, которая рисует в окне изображение сферы.</p>
<p>Команда <em>glFlush()</em> гарантирует, что команда рисования будет выполнена немедленно, а не сохранена в буфере.
</p>
<p>И ещё, прежде чем использовать функции из GLUT, необходимо к программе подключить заголовок: #include &lt;GL/glut.h&gt;.</p>
<p><strong>3. Создание консольного приложения, использующего OpenGL</strong></p>
<p>Самым простым объектом, с помощью которого можно увидеть всю мощь OpenGL, является сфера. Давайте попытаемся ее
	изобразить. Для этого надо создать новый проект в VisualC++, выполнить следующие действия: </p>
<p>1. Запустите MSVisualC++6.0.</p>
<p>2. Щелкните меню File-&gt;New-&gt;Win32 Console Application. </p>
<p>3. Выберите каталог и имя проекта, впишите – sphere, щелкните OK. </p>
<p>4. Выберите An Empty Project, щелкните Finish. </p>
<p>5. Создайте в проекте файл sphere.c. </p>
<p>6. Щелкните Build-&gt;Set Active Configuration и установите тип проекта sphere – Win32 Release </p>
<p>7. Далее, щелкайте Project-&gt;Settings-&gt;Link-&gt;Object/library modules и добавьте туда opengl32.lib, glu32.lib и
	gllut32a.lib.</p>
<p>8. Теперь откомпилируйте и запустите Вашу программу. <br/>Меню Build-&gt;Execute Sphere.exe </p>
<p>Текст программы Sphere.exe:</p>
<p>#include &lt;windows.h&gt;</p>
<p>#include &lt;GL/gl.h&gt;</p>
<p>#include &lt;GL/glu.h&gt;</p>
<p>#include &lt;GL/glaux.h&gt;</p>
<p>#include &lt;GL/glut.h&gt;</p>
<p>void resize<strong>(</strong>int width<strong>,</strong>int height<strong>)</strong></p>
<p><strong>{</strong></p>
<p><strong>}</strong></p>
<p>void display<strong>(</strong>void<strong>)</strong></p>
<p><strong>{</strong></p>
<p> glColor3d<strong>(</strong>1<strong>,</strong>1<strong>,</strong>0<strong>);</strong></p>
<p> glutSolidSphere<strong>(</strong>1.0<strong>,</strong> 25<strong>,</strong> 25<strong>);</strong></p>
<p> glFlush<strong>();</strong></p>
<p><strong>}</strong></p>
<p>void init<strong>(</strong>void<strong>)</strong></p>
<p><strong>{</strong></p>
<p> glEnable<strong>(</strong>GL_COLOR_MATERIAL<strong>);</strong></p>
<p> glEnable<strong>(</strong>GL_LIGHTING<strong>);</strong></p>
<p> glEnable<strong>(</strong>GL_LIGHT0<strong>);</strong></p>
<p> glEnable<strong>(</strong>GL_DEPTH_TEST<strong>);</strong></p>
<p> glClearColor <strong>(</strong>0.0<strong>,</strong> 0.0<strong>,</strong> 0.0<strong>,</strong>
	0.0<strong>);</strong></p>
<p> glClear<strong>(</strong>GL_COLOR_BUFFER_BIT <strong>|</strong> GL_DEPTH_BUFFER_BIT<strong>);</strong></p>
<p> glMatrixMode<strong>(</strong> GL_PROJECTION <strong>);</strong></p>
<p> glLoadIdentity<strong>();</strong></p>
<p>
	glOrtho<strong>(-</strong>5.0<strong>,</strong>5.0<strong>,-</strong>5.0<strong>,</strong>5.0<strong>,</strong>2.0<strong>,</strong>12.0<strong>);</strong>
</p>
<p> gluLookAt<strong>(</strong> 0<strong>,</strong>0<strong>,</strong>5<strong>,</strong>
	0<strong>,</strong>1<strong>,</strong>0<strong>,</strong> 0<strong>,</strong>1<strong>,</strong>0
	<strong>);</strong></p>
<p> glMatrixMode<strong>(</strong> GL_MODELVIEW<strong>);</strong></p>
<p><strong>}</strong></p>
<p>int main<strong>(</strong>int argc<strong>,</strong>char <strong>**</strong> argv<strong>)</strong></p>
<p><strong>{</strong></p>
<p> glutInitDisplayMode<strong>(</strong>GLUT_SINGLE <strong>|</strong> GLUT_RGB <strong>|</strong>
	GLUT_DEPTH<strong>);</strong></p>
<p> glutInitWindowPosition<strong>(</strong>50<strong>,</strong>10<strong>);</strong></p>
<p> glutInitWindowSize<strong>(</strong>400<strong>,</strong>400<strong>);</strong></p>
<p> glutCreateWindow<strong>(</strong>«Hello»<strong>);</strong></p>
<p> glutReshapeFunc<strong>(</strong>resize<strong>);</strong></p>
<p> init<strong>();</strong></p>
<p> glutDisplayFunc<strong>(</strong>display<strong>);</strong></p>
<p> glutMainLoop<strong>();</strong></p>
<p><strong>return</strong> 0<strong>;</strong></p>
<p><strong>}</strong></p>
<p><strong>4. Синтаксис команд OpenGl</strong></p>
<p>Командами в OpenGl называются функции или процедуры. Для их описания используется следующий синтаксис:</p>
<p><strong>type glCommand_name[1 2 3 4][b s i f d ub us ui][v](type1 arg1,-,typeN argN)</strong></p>
<p>gl – это имя библиотеки, в которой описана эта функция:<br/>для базовых функций OpenGL, функций из библиотек GLU,
	GLUT, GLAUX это gl, glu, glut, aux соответственно.</p>
<p>Command_name имя команды<br/>[1 2 3 4]число аргументов команды<br/>[b s i f d ub us ui ]тип аргумента:</p>
<p>Доступны следующие типы: </p>
<p>b – GLbyte байт; s – GLshort короткое целое; i – GLint целое; f – GLfloat дробное; d – GLdouble дробное с двойной
	точностью; ub – GLubyte беззнаковый байт; us – GLushort беззнаковое короткое целое; ui – GLuint беззнаковое целое;
	v – массив из n параметров указанного типа; </p>
<p>[v] – наличие этого символа показывает, что в качестве параметров функции используется указатель на массив
	значений. </p>
<p>Символы в квадратных скобках в некоторых названиях не используются. Например, команда glVertex2i() описана как
	базовая в библиотеке OpenGL, и использует в качестве параметров два целых числа, а команда glColor3fv() использует в
	качестве параметра указатель на массив из трех вещественных чисел.</p>
<p>Ниже приведены примеры использования команд OpenGL с различными типами аргументов.</p>
<p> double array[] = {0.5, 0.75, 0.3, 0.7};</p>
<p> ...</p>
<p> glColor3dv(array);</p>
<p> glColor3ub(200,100,0); // приводится к 200/256, 100/256, 0/256</p>
<p> glColor3d(0.25,0.25,0); // темно-желтый</p>
<p> glColot3ub(0,100,0); // темно-зеленый</p>
<p> glColor3ub(0,0,255); // синий</p>
<p><strong>Задание на лабораторную работу</strong></p>
<p>1. Ввести и отладить программу, приведенную в п.3.</p>
<p>2.Заменить функцию glutSolidSphere на функцию, из указанных ниже с соответсвующими параметрами. Значения параметров
	устанавливайте порядка единицы – 0,5…1,7. Если Вы укажете слишком маленький размер, фигуру будет плохо видно; если
	слишком большой, то она получится урезанной. Это связано с тем, что ее край как бы вылезет из монитора. </p>
<p><a id="auxSolidCube23"></a><a id="auxSolidBox23"></a><a id="auxSolidTorus23"></a><a id="auxSolidCylinder23"></a><a
		id="auxSolidCone23"></a><a id="auxSolidIcosahedron23"></a><a id="auxSolidOctahedron23"></a><a
		id="auxSolidTeapot23"></a><a id="auxWireCube23"></a><a id="auxWireBox23"></a><a id="auxWireTorus23"></a><a
		id="auxWireCylinder23"></a><a id="auxWireCone23"></a><a id="auxWireIcosahedron23"></a><a
		id="auxWireOctahedron23"></a><a id="auxWireTeapot23"></a>glutSolidCube(width) // куб </p>
<p>glutSolidTorus(r,R) // тор </p>
<p>glutSolidCylinder(r,height) // цилиндр </p>
<p>glutSolidCone(r,height) // конус </p>
<p>glutSolidIcosahedron(width) // многогранники </p>
<p>glutSolidOctahedron(width) </p>
<p>glutSolidTetrahedron(width) </p>
<p>glutSolidDodecahedron(width) </p>
<p>glutSolidTeapot(width) // рисует чайник </p>
<p>3. С помощью вышеуказанных функций нарисовать проволочные фигуры, заменив и имена функций Solid на Wire. </p>
<p><strong>Контрольные вопросы</strong></p>
<p>1. Назначение пакета OpenGl.</p>
<p>2. Назначение и использование библиотеки GLUT.</p>
<p>3. Синтаксис команд OpenGL.</p>
<p>4. Создание приложения с использованием OpenGL в среде Visual C++.</p>
<p>5. Режимы отображения информации в окне.</p>
<h1><a id="_Toc454872984"></a>Лабораторная работа №2: “Жизненный цикл программ”</h1>
<p><strong>Порядок выполнения работы </strong></p>
<p>1. Ознакомьтесь с теоретическими основами в настоящих указаниях и конспектах лекций. </p>
<p>2. Получите задание у преподавателя. </p>
<p>3. Сделайте скриншоты (кнопка клавиатуры PrtSc) выполненных заданий в текстовом (Word) файле <em>Фамилия_ЛР</em></p>
<p>4. Составьте отчет по лабораторной работе. </p>
<p>5. Отчитайте работу преподавателю.</p>
<p><strong>Цель работы</strong></p>
<p>Изучение команд OpenGL для рисования графических примитивов.</p>
<p><strong>1. Примитивы OpenGL</strong></p>
<p><a id="glBegin31"></a><a id="glVertex31"></a><a id="glEnd31"></a>Точки, линии, треугольники, четырехугольники,
	многоугольники – простые объекты, из которых состоят любые сложные фигуры. В предыдущей лаборатоной работе мы
	рисовали сферу, конус и тор. OpenGL непосредственно не поддерживает функций для создания таких сложных объектов,
	т.е. таких функций нет в opengl32.dll. Эти функции есть в библиотеке утилит glu32.dll, и устроены они следующим
	образом. Для того чтобы нарисовать сферу, функция glutSolidSphere использует функции из библиотеки glu32.dll, а те,
	в свою очередь, используют базовую библиотеку opengl32.dll и из линий или многоугольников строят сферу. Примитивы
	создаются следующим образом: </p>
<p> glBegin(GLenum mode); // указываем, что будем рисовать </p>
<p> glVertex[2 3 4][s i f d](...); // первая вершина</p>
<p> // тут остальные вершины </p>
<p> glVertex[2 3 4][s i f d](...); // последняя вершина</p>
<p> glEnd(); // закончили рисовать примитив</p>
<p>Сначала Вы говорите, что будете рисовать – glBegin с соответсвующим параметром. Возможные значения mode перечислены
	ниже в табл. 2.1. Далее Вы указываете вершины, определяющие объекты указанного типа. Обычно, Вы будете задавать
	вершину одним из четырех способов. </p>
<p>glVertex2d(x,y); // две переменных типа double</p>
<p>glVertex3d(x,y,z); // три переменных типа double</p>
<p>glVertex2dv(array); // массив из двух переменных типа double</p>
<p>glVertex3dv(array); // массив из трех переменных типа double</p>
<p>И, наконец, Вы вызваете glEnd(), чтобы указать, что Вы закончили рисовать объекты типа, указанного в glBegin(). Далее
	мы подробно разберем создание всех примитивов.</p>
<p>Таблица 2.1</p>
<table>
	<tr>
		<td><p>Значение mode</p></td>
		<td><p>Описание</p></td>
	</tr>
	<tr>
		<td><p>GL_POINTS</p></td>
		<td><p>Каждый вызов glVertex задает отдельную точку</p></td>
	</tr>
	<tr>
		<td><p>GL_LINES</p></td>
		<td><p>Каждая пара вершин задает отрезок</p></td>
	</tr>
	<tr>
		<td><p>GL_LINE_STRIP</p></td>
		<td><p>Рисуется ломаная</p></td>
	</tr>
	<tr>
		<td><p>GL_LINE_LOOP</p></td>
		<td><p>Рисуется ломаная, причем ее последняя точка соединяется с первой</p></td>
	</tr>
	<tr>
		<td><p>GL_TRIANGLES</p></td>
		<td><p>Каждые три вызова glVertex задают треугольник</p></td>
	</tr>
	<tr>
		<td><p>GL_TRIANGLE_STRIP</p></td>
		<td><p>Рисуются треугольники с общей стороной</p></td>
	</tr>
	<tr>
		<td><p>GL_TRIANGLE_FAN</p></td>
		<td><p>То же самое, но по другому правилу соединяются вершины</p></td>
	</tr>
	<tr>
		<td><p>GL_QUADS</p></td>
		<td><p>Каждые четыре вызова glVertex задают четырехугольник</p></td>
	</tr>
	<tr>
		<td><p>GL_QUAD_STRIP</p></td>
		<td><p>Четырехугольники с общей стороной</p></td>
	</tr>
	<tr>
		<td><p>GL_POLYGON</p></td>
		<td><p>Многоугольник</p></td>
	</tr>
</table>
<p><strong>2. Точки</strong></p>
<p><a id="glPointSize32"></a><a id="GL\_POINTS32"></a>Вы можете нарисовать столько точек, сколько вам нужно. Вызывая
	glVertex3d, вы устанавливаете новую точку. Размер точки можно устанавливать с помощью функции: </p>
<p><em>void glPointSize(GLfloat size);</em></p>
<p>Режим сглаживания можно устанавливать вызовом функции </p>
<p><em>glEnable(GL_POINT_SMOOTH);</em></p>
<p><a id="GL\_POINT\_SMOOTH32"></a>Отключается, соответственно, вызовом glDisable() c этим параметром. Последние
	функции – glPointSize и glEnable/glDisable надо вызывать вне glBegin/glEnd, иначе они будут проигнорированы. </p>
<p>Примеры рисования точек:</p>
<p> // рисуем точки</p>
<p> glPointSize(2); </p>
<p> glBegin(GL_POINTS); </p>
<p> glColor3d(1,0,0); </p>
<p> glVertex3d(-4.5,4,0); // первая точка</p>
<p> glColor3d(0,1,0); </p>
<p> glVertex3d(-4,4,0); // вторая точка</p>
<p> glColor3d(0,0,1); // третья</p>
<p> glVertex3d(-3.5,4,0);</p>
<p> glEnd();</p>
<p></p>
<p> glPointSize(5); </p>
<p> glBegin(GL_POINTS); </p>
<p> glColor3d(1,0,0); </p>
<p> glVertex3d(-2,4,0); // первая точка</p>
<p> glColor3d(0,1,0); </p>
<p> glVertex3d(-1,4,0); // вторая точка </p>
<p> glColor3d(0,0,1); // третья точка</p>
<p> glVertex3d(0,4,0);</p>
<p> glEnd();</p>
<p><strong>3. Линии</strong></p>
<p>Для линий Вы также можете изменять ширину, цвет, размер, сглаживание. Если вы зададите разные цвета для начала и
	конца линии, то ее цвет будет переливающимся. OpenGL по умолчанию делает интерполяцию. Так же Вы можете рисовать
	прерывистые линии, делается это путем наложения маски при помощи следующей функции: </p>
<p><em>void glLineStipple(GLint factor, GLushort pattern );</em></p>
<p>Второй параметр задает саму маску. Например, если его значение равно 255(0x00FF), то, чтобы вычислить задаваемую
	маску, воспользуемся калькулятором. В двоичном виде это число выглядит так: 0000000011111111, т.е. всего 16 бит.
	Старшие восемь установлены в ноль, значит, тут линии не будет. Младшие установлены в единицу, тут будет рисоваться
	линия. Первый параметр определяет, сколько раз повторяется каждый бит. Скажем, если его установить равным 2, то
	накладываемая маска будет выглядить так: </p>
<p>00000000000000001111111111111111</p>
<p>Далее приведен исходный текст с комментариями </p>
<p> glLineWidth(1); // ширину линии устанавливаем 1</p>
<p> glBegin(GL_LINES);</p>
<p> glColor3d(1,0,0); // красный цвет</p>
<p> glVertex3d(-4.5,3,0); // первая линия</p>
<p> glVertex3d(-3,3,0); </p>
<p> glColor3d(0,1,0); // зеленый</p>
<p> glVertex3d(-3,3.3,0); // вторая линия</p>
<p> glVertex3d(-4,3.4,0); </p>
<p> glEnd();</p>
<p> glLineWidth(3); // ширина 3</p>
<p> glBegin(GL_LINE_STRIP); // см. ниже</p>
<p> glColor3d(1,0,0);</p>
<p> glVertex3d(-2.7,3,0);</p>
<p> glVertex3d(-1,3,0);</p>
<p> glColor3d(0,1,0);</p>
<p> glVertex3d(-1.5,3.3,0); </p>
<p> glColor3d(0,0,1);</p>
<p> glVertex3d(-1,3.5,0); </p>
<p> glEnd();</p>
<p> glLineWidth(5);</p>
<p> glEnable(GL_LINE_SMOOTH); </p>
<p> glEnable(GL_LINE_STIPPLE); // разрешаем рисовать прерывистую линию</p>
<p> glLineStipple(2,58360); // устанавливаем маску</p>
<p> glBegin(GL_LINE_LOOP);</p>
<p> glColor3d(1,0,0);</p>
<p> glVertex3d(1,3,0);</p>
<p> glVertex3d(4,3,0);</p>
<p> glColor3d(0,1,0);</p>
<p> glVertex3d(3,2.7,0); </p>
<p> glColor3d(0,0,1);</p>
<p> glVertex3d(2.5,3.7,0); </p>
<p> glEnd();</p>
<p> glDisable(GL_LINE_SMOOTH);</p>
<p> glDisable(GL_LINE_STIPPLE);</p>
<p><strong>4. Треугольники</strong></p>
<p>Для треугольника можно задавать те же параметры, что и для линии, плюс есть еще одна функция glPolygonMode. Она
	устанавливает опции для отрисовки многоугольника. Первый параметр может принимать значения – GL_FRONT, GL_BACK и
	GL_FRONT_AND_BACK. Второй параметр указывает, как будет рисоваться многоугольник. Он принимает значения:
	GL_POINT(рисуются только точки), GL_LINE(рисуем линии) и GL_FILL(рисуем заполненный многоугольник). Первый параметр
	указывает: к лицевой, тыльной или же к обеим сторонам применяется опция, заданная вторым параметром. Треугольники
	можно рисовать, передав GL_TRIANGLE_STRIP или GL_TRIANGLE_FAN в glBegin. В первом случае, первая, вторая и третья
	вершины задают первый треугольник. Вторая, третья и четвертая вершины – второй треугольник. Третья, четвертая и
	пятая вершина – третий треугольник и т.д. Вершины n, n+1 и n+2 определят n-й треугольник. Во втором случае, первая,
	вторая и третья вершины задают первый треугольник. Первая, третья и четвертая вершины задают второй треугольник и
	т.д. Вершины 1, n+1, n+2 определяют n-й треугольник. Далее следует пример с комментариями. </p>
<p>glPolygonMode(GL_FRONT_AND_BACK, GL_FILL); // см. выше</p>
<p> glBegin(GL_TRIANGLES);</p>
<p> glColor3d(1,0,0); // рисуем треугольник</p>
<p> glVertex3d(-4,2,0);</p>
<p> glVertex3d(-3,2.9,0);</p>
<p> glVertex3d(-2,2,0);</p>
<p> glEnd();</p>
<p>glLineWidth(2);</p>
<p> glPolygonMode(GL_FRONT_AND_BACK, GL_LINE); //рисуем проволочные треугольники</p>
<p>glBegin(GL_TRIANGLE_STRIP); // обратите внимание на порядок вершин</p>
<p> glColor3d(0,1,0);</p>
<p> glVertex3d(1,2,0);</p>
<p> glVertex3d(0,2.9,0);</p>
<p> glVertex3d(-1,2,0);</p>
<p> glVertex3d(0,1.1,0);</p>
<p> glEnd();</p>
<p> glEnable(GL_LINE_STIPPLE); </p>
<p> glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);</p>
<p> glBegin(GL_TRIANGLE_FAN);</p>
<p> glColor3d(0,0,1);</p>
<p> glVertex3d(4,2,0);</p>
<p> glVertex3d(2.6,2.8,0);</p>
<p> glVertex3d(2,2,0);</p>
<p> glVertex3d(3,1.1,0);</p>
<p> glEnd();</p>
<p> glDisable(GL_LINE_STIPPLE);</p>
<p><strong>5. Четырехугольники</strong></p>
<p>Четырехугольники рисуются вызовом функции glBegin с параметром GL_QUADS или GL_QUAD_STRIP. Для первого случая каждые
	четыре вершины определяют свой четырехугольник. Во втором случае рисуются связанные четырехугольники. Первая,
	вторая, третья и четвертая вершины определяют первый четырехугольник. Третья, четвертая, пятая и шестая вершины –
	второй четырехугольник и т.д. (2n-1), 2n, (2n+1) и (2n+2) вершины задают n-й четырехугольник. Многоугольники
	задаются вызовом glBegin с параметром GL_POLYGON. Все вершины определяют один многоугольник. Для многоугольников
	можно задавать стили при помощи вышеописанной функции glPolygonMode, толщину линии, толщину точек и цвет.</p>
<p><strong>Задание на лабораторную работу</strong></p>
<p>1. Изобразить точки, линии, треугольники, многоугольники в одном окне. </p>
<p>2. Построить изображение фигуры, заданной преподавателем.</p>
<p><strong>Контрольные вопросы</strong></p>
<p>1. Определение примитива. Примитивы OpenGL.</p>
<p>2. Рисование точек и линий средствами OpenGL.</p>
<p>3. Рисование треугольников и многоугольников средствами OpenGL.</p>
<p>4. Полосы из треугольников и прямоугольников.</p>
<h1><a id="_Toc454872985"></a>Лабораторная работа №3: “Документирование программных средств”</h1>
<p><strong>Порядок выполнения работы </strong></p>
<p>1. Ознакомьтесь с теоретическими основами в настоящих указаниях и конспектах лекций. </p>
<p>2. Получите задание у преподавателя. </p>
<p>3. Сделайте скриншоты (кнопка клавиатуры PrtSc) выполненных заданий в текстовом (Word) файле <em>Фамилия_ЛР</em></p>
<p>4. Составьте отчет по лабораторной работе. </p>
<p>5. Отчитайте работу преподавателю.</p>
<p><strong>Цель работы</strong></p>
<p>Изучение способов организации интерактивного взвамодействия с пользователем в программах, использующих OpenGL.</p>
<p><strong>1. Взаимодействие с пользователем в OpenGL</strong></p>
<p>Функции библиотеки GLUT реализуют так называемый событийно-управляемый механизм. Это означает, что есть некоторый
	внутренний цикл, который запускается после соответствующей инициализации и обрабатывает одно за другим все события,
	объявленные во время инициализации. К событиям относятся: щелчок мыши, закрытие окна, изменение свойств окна,
	передвижение курсора, нажатие клавиши, и «пустое» (idle) событие, когда ничего не происходит. Для проведения
	периодической проверки совершения того или иного события надо зарегистрировать функцию, которая будет его
	обрабатывать. Для этого используются функции вида:</p>
<p>void glutDisplayFunc (void (*func) (void))</p>
<p>void glutReshapeFunc (void (*func) (int width, int height))</p>
<p>void glutMouseFunc (void (*func) (int button, int state, int x, int y))</p>
<p>void glutIdleFunc (void (*func) (void))</p>
<p>void glutKeyboardFunc(void (*func)(unsigned int key, int x, int y)</p>
<p>void glutMotionFunc(void (*func)(int x, int y)); </p>
<p><em>void glutKeyboardFunc(void (*func)(unsigned int key, int x, int y); </em></p>
<p>Определяет функцию (func), которая вызывается, когда нажата клавиша на клавиатуре. Возвращаемые параметры:</p>
<p>key – сгенерированный клавиатурой ASCII код;</p>
<p>x,y – координаты положения мыши в координатах отображаемого окна, в момент, когда была нажата кнопка на
	клавиатуре.</p>
<p><em>void glutMouseFunc(void (*func)(int button, int state, int x, int y)); </em></p>
<p>Определяет функцию (func) которая вызывается, когда кнопка мыши нажата или отпущена. Возвращаемый функцией параметр
	button может принимать значения GLUT_LEFT_BUTTON, GLUT_MIDDLE_BUTTON, или GLUT_RIGHT_BUTTON. Значение параметра
	state есть GLUT_UP или GLUT_DOWN в зависимости от того, была ли кнопка мыши нажата или отпущена, x and y параметры
	указывают на координаты в текущем окне, где находилась мышь в момент нажатия или отпускания кнопки.</p>
<p><em>void glutMotionFunc(void (*func)(int x, int y)); </em></p>
<p>Определяет функцию (func) которая вызывается, когда указатель мыши перемещается в пределах окна при нажатой одной или
	более кнопке, x and y параметры указывают на координаты в текущем окне, где находилась мышь в момент начала события
	<em>void glutPostRedisplay(void); </em></p>
<p>Отмечает текущее окно как требующее перерисовки. На следующем шаге работы программы будет вызвана функция,
	зарегистрированная в glutDisplayFunc().</p>
<p><em>void glutIdleFunc (void (*func) (void));</em></p>
<p>glutIdleFunc() задает функцию, которая будет вызываться каждый раз, когда нет событий от пользователя.</p>
<p><strong>2. Видовое преобразование</strong></p>
<p>К видовым преобразованиям будем относить перенос, поворот и изменение масштаба вдоль координатных осей. Для
	проведения этих операций достаточно умножить на соответствующую матрицу каждую вершину объекта и получить измененные
	координаты этой вершины:</p>
<p>(x-, y-, z-, 1)<sup>T</sup> = M * (x, y, z, 1)<sup>T</sup>,</p>
<p>где M – матрица видового преобразования. Матрица M может быть создана с помощью следующих команд:</p>
<p>void glTranslate[f d](GLtype x, GLtype y, GLtype z)</p>
<p>void glRotate[f d](GLtype angle, GLtype x, GLtype y, GLtype z)</p>
<p>void glScale[f d](GLtype x, GLtype y, GLtype z)</p>
<p>glTranlsate..() производит перенос объекта, прибавляя к координатам его вершин значения своих параметров.</p>
<p>glRotate..() производит поворот объекта против часовой стрелки на угол angle (измеряется в градусах) вокруг вектора (
	x,y,z ).</p>
<p>glScale..() производит масштабирование объекта (сжатие или растяжение), домножая соответствующие координаты его
	вершин на значения своих параметров.</p>
<p>Все эти преобразования применимы к примитивам, описания которых будут находиться ниже в программе. В случае, если
	надо, например, повернуть один объект сцены, а другой оставить неподвижным, удобно сначала сохранить текущую видовую
	матрицу в стеке командой glPushMatrix(), затем вызвать glRotate..() с нужными параметрами, описать примитивы, из
	которых состоит этот объект, а затем восстановить текущую матрицу командой glPopMatrix().</p>
<p><strong>3. Анимация</strong></p>
<p>Если содержимое буфера кадра изменяется в процессе регенерации изображения, то зритель может увидеть совершенно
	нежелательные эффекты, например, дерганье изменяющейся картинки.</p>
<p>Эту проблему можно решить с использованием двойной буферизации – стандартной технологии организации компьютерной
	анимации. В этом случае в нашем распоряжении имеется два буфера кадра, которые принято называть рабочим и фоновым.
	Рабочий буфер – это тот, из которого выполняется регенерация изображения на экране, а в фоновом буфере изображение
	формируется программой. По командам из прикладной программы можно переключать функции буферов: сделать рабочим тот,
	который ранее был фоновым, а фоновым – тот, который ранее был рабочим. Механизм двойной буферизации устанавливается
	в процессе инициализации аргументом функции glutInitDisplayMode(). Вместо константы GLUT_SINGLE нужно задать
	константу GLUT_DOUBLE. Переключение буферов выполняется функцией glutSwapBuffers(). Все операторы формирования
	изображения включатся в функцию display(), но при использовании двойной буферизации в этой функции сначала нужно
	очистить рабочий буфер, вызвав команду glClear(), а последним оператором вызвать функцию переключения буферов
	glutSwapBuffers().</p>
<p>Программа рисования вращающегося квадрата </p>
<p>#include &lt;GL/glut.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>static GLfloat spin <strong>=</strong> 0.0<strong>;</strong></p>
<p>void spinDisplay<strong>(</strong>void<strong>)</strong></p>
<p><strong>{</strong></p>
<p> spin <strong>=</strong> spin <strong>+</strong> 2.0<strong>;</strong></p>
<p><strong>if</strong> <strong>(</strong>spin <strong>&gt;</strong> 360.0<strong>)</strong></p>
<p> spin <strong>=</strong> spin – 360.0<strong>;</strong></p>
<p> glutPostRedisplay<strong>();</strong></p>
<p><strong>}</strong></p>
<p>void display<strong>(</strong>void<strong>)</strong></p>
<p><strong>{</strong></p>
<p> glClear<strong>(</strong>GL_COLOR_BUFFER_BIT<strong>);</strong></p>
<p> glPushMatrix<strong>();</strong></p>
<p> glRotatef<strong>(</strong>spin<strong>,</strong> 0.0<strong>,</strong> 0.0<strong>,</strong> 1.0<strong>);</strong>
</p>
<p> glColor3f<strong>(</strong>1.0<strong>,</strong> 1.0<strong>,</strong> 1.0<strong>);</strong></p>
<p> glBegin<strong>(</strong>GL_POLYGON<strong>);</strong></p>
<p> glVertex2f<strong>(-</strong>25.0<strong>,-</strong>25.0<strong>);</strong></p>
<p> glVertex2f<strong>(</strong>25.0<strong>,-</strong>25.0<strong>);</strong></p>
<p> glVertex2f<strong>(</strong>25.0<strong>,</strong>25.0<strong>);</strong></p>
<p> glVertex2f<strong>(-</strong>25.0<strong>,</strong>25.0<strong>);</strong></p>
<p> glEnd<strong>(</strong> <strong>);</strong></p>
<p> glPopMatrix<strong>();</strong></p>
<p> glutSwapBuffers<strong>();</strong></p>
<p><strong>}</strong></p>
<p>void init<strong>(</strong>void<strong>)</strong></p>
<p><strong>{</strong></p>
<p> glClearColor <strong>(</strong>0.0<strong>,</strong> 0.0<strong>,</strong> 0.0<strong>,</strong>
	0.0<strong>);</strong></p>
<p> glShadeModel <strong>(</strong>GL_FLAT<strong>);</strong></p>
<p><strong>}</strong></p>
<p>void reshape<strong>(</strong>int w<strong>,</strong> int h<strong>)</strong></p>
<p><strong>{</strong></p>
<p> glViewport <strong>(</strong>0<strong>,</strong> 0<strong>,</strong> <strong>(</strong>GLsizei<strong>)</strong>
	w<strong>,</strong> <strong>(</strong>GLsizei<strong>)</strong> h<strong>);</strong></p>
<p> glMatrixMode<strong>(</strong>GL_PROJECTION<strong>);</strong></p>
<p> glLoadIdentity<strong>();</strong></p>
<p> glOrtho<strong>(-</strong>50.0<strong>,</strong> 50.0<strong>,</strong> <strong>-</strong>50.0<strong>,</strong>
	50.0<strong>,</strong> <strong>-</strong>1.0<strong>,</strong> 1.0<strong>);</strong></p>
<p> glMatrixMode<strong>(</strong>GL_MODELVIEW<strong>);</strong></p>
<p> glLoadIdentity<strong>();</strong></p>
<p><strong>}</strong></p>
<p>int main<strong>(</strong>int argc<strong>,</strong> char<strong>**</strong> argv<strong>)</strong></p>
<p><strong>{</strong></p>
<p> glutInit<strong>(&amp;</strong>argc<strong>,</strong> argv<strong>);</strong></p>
<p> glutInitDisplayMode <strong>(</strong>GLUT_DOUBLE <strong>|</strong> GLUT_RGB<strong>);</strong></p>
<p> glutInitWindowSize <strong>(</strong>250<strong>,</strong> 250<strong>);</strong></p>
<p> glutInitWindowPosition <strong>(</strong>100<strong>,</strong> 100<strong>);</strong></p>
<p> glutCreateWindow <strong>(</strong>argv<strong>[</strong>0<strong>]);</strong></p>
<p> init <strong>();</strong></p>
<p> glutDisplayFunc<strong>(</strong>display<strong>);</strong></p>
<p> glutReshapeFunc<strong>(</strong>reshape<strong>);</strong></p>
<p> glutIdleFunc<strong>(</strong>spinDisplay<strong>);</strong></p>
<p> glutMainLoop<strong>();</strong></p>
<p><strong>return</strong> 0<strong>;</strong> /* ANSI C requires main to return int. */</p>
<p><strong>}</strong></p>
<p><strong>Порядок выполнения лабораторной работы</strong></p>
<p>1. Ввести и отладить программу рисования вращающегося квадрата.</p>
<p>2. Изменить программу п.1 таким образом, чтобы она управлялась нажатием клавиш на клавиатуре – при нажатии клавиши
	«x», квадрат вращается, при нажатии клавиши «X»- вращение прекращается, при нажатии клавиши «Esc» – программа
	завершает свою работу. </p>
<p>3. Изменить программу п.1 таким образом, чтобы она управлялась нажатием клавиши мыши – при нажатии левой
	клавиши–квадрат вращается, при нажатии правой клавиши–вращение прекращается.</p>
<p>4. Нарисовать любую фигуру в одном из углов экрана. Обеспечить перемещение этой фигуры по экрану при нажатой и
	удерживаемой клавише мыши.</p>
<p><strong>Контрольные вопросы</strong></p>
<p>1. Назначение анимации. Методы создания анимации средствами OpenGL.</p>
<p>2. Диалоговые средства ввода. Реализация диалоговых средств ввода в библиотеке GLUT.</p>
<p>3. Видовое преобразование. Функции OpenGL, обеспечивающие видовое преобразование.</p>
<p>4. Матричное представление геометрических преобразований в однородных координатах.</p>
<h1><a id="_Toc454872986"></a>Лабораторная работа №4: “Документирование программных средств”</h1>
<p><strong>Порядок выполнения работы </strong></p>
<p>1. Ознакомьтесь с теоретическими основами в настоящих указаниях и конспектах лекций. </p>
<p>2. Получите задание у преподавателя. </p>
<p>3. Сделайте скриншоты (кнопка клавиатуры PrtSc) выполненных заданий в текстовом (Word) файле <em>Фамилия_ЛР</em></p>
<p>4. Составьте отчет по лабораторной работе. </p>
<p>5. Отчитайте работу преподавателю.</p>
<p><strong>Цель работы</strong></p>
<p>Изучение методов создания трехмерных объектов средствами OpenGL. Ислледование свойств полоских проекций трехмерных
	объектов.</p>
<p><strong>1. Рисование трехмерного куба</strong></p>
<p>Куб следует рассматривать как шесть многоугольников, которые определяют его грани. Массив вершин куба может быть
	представлен в следующем виде:</p>
<p>GLfloat vertices[][3]={{-1.0,-1.0,-1.0},{1.0,-1.0,-1.0},</p>
<p>{1.0,1.0,-1.0},{-1.0,1.0,-1.0},{-1.0,-1.0,1.0},</p>
<p>{1.0,-1.0,1.0},{1.0,1.0,1.0},{-1.0,1.0,1.0}};</p>
<p>Для определения граней куба можно использовать список точек–элементов массива вершин. Например, одна грань куба в
	тексте программы определяется следующим образом:</p>
<p>glBegin(GL_POLYGON);</p>
<p> glVertex3fv(vertices[0]);</p>
<p> glVertex3fv(vertices[3]);</p>
<p> glVertex3fv(vertices[2]);</p>
<p> glVertex3fv(vertices[1]);</p>
<p>glEnd();</p>
<p>Другие пять граней определяются аналогично. При определении трехмерных многогранников порядок перечисления вершин
	имеет большое значение. Следует учитывать, что многоугольник имеет две стороны – внутреннюю и внешнюю. Будем
	называть грань внешней, если при взгляде с внешней стороны объекта на эту грань ее вершины «обходятся» против
	часовой стрелки. Этот метод известен как «правило правой руки», поскольку, если расположить четыре согнутых пальца
	правой руки вдоль направления обхода контура, большой палец будет указывать наружную сторону грани. </p>
<p>Список вершин можно использовать и для хранения информации, необходимой для раскрашивания куба. С вершинами в данном
	примере будут ассоциироваться чистые цвета вершин цветового куба (черный, белый, красный, зеленый, синий, голубой,
	фиолетовый, желтый):</p>
<p>GLfloat colors[][3]={{0.0,0.0,0.0},{1.0,0.0,0.0},</p>
<p>{1.0,1.0,0.0},{0.0,1.0,0.0},{0.0,0.0,1.0},</p>
<p>{1.0,0.0,1.0},{1.0,1.0,1.0},{0.0,1.0,1.0}};</p>
<p>Для управления режимом интерполяции цветов используется команда void <strong>glShadeModel</strong>(GLenummode), вызов
	которой с параметром GL_SMOOTH включает интерполяцию (установка по умолчанию), а с GL_FLAT отключает.</p>
<p>Функция quad() вычерчивает четырехугольник, заданный точками в списке вершин, а функция colorcube() задает шесть
	граней таким образом, чтобы все они были внешними.</p>
<p>GLfloat vertices[][3]={{-1.0,-1.0,-1.0},{1.0,-1.0,-1.0},</p>
<p>{1.0,1.0,-1.0},{-1.0,1.0,-1.0},{-1.0,-1.0,1.0},</p>
<p>{1.0,-1.0,1.0},{1.0,1.0,1.0},{-1.0,1.0,1.0}};</p>
<p>GLfloat colors[][3]={{0.0,0.0,0.0},{1.0,0.0,0.0},</p>
<p>{1.0,1.0,0.0},{0.0,1.0,0.0},{0.0,0.0,1.0},</p>
<p>{1.0,0.0,1.0},{1.0,1.0,1.0},{0.0,1.0,1.0}};</p>
<p>void polygon(int a, int b, int c, int d)</p>
<p>{</p>
<p> glBegin(GL_POLYGON);</p>
<p> glColor3fv(colors[a]);</p>
<p> glVertex3fv(vertices[a]);</p>
<p> glColor3fv(colors[b]);</p>
<p> glVertex3fv(vertices[b]);</p>
<p> glColor3fv(colors[c]);</p>
<p> glVertex3fv(vertices[c]);</p>
<p> glColor3fv(colors[d]);</p>
<p> glVertex3fv(vertices[d]);</p>
<p> glEnd();</p>
<p>}</p>
<p>void colorcube()</p>
<p>{</p>
<p> polygon(0,3,2,1);</p>
<p> polygon(2,3,7,6);</p>
<p> polygon(0,4,7,3);</p>
<p> polygon(1,2,6,5);</p>
<p> polygon(4,5,6,7);</p>
<p> polygon(0,1,5,4);</p>
<p>}</p>
<p><strong>2. Проективные преобразования в OpenGL</strong></p>
<p>В составе OpenGL имеются две функции для задания перспективных проекций и одна для задания параллельных проекций.
	Каждая из функций определяет зону видимости – пирамиду или параллелепипед. Объекты, не попадающие в эту зону,
	отсекаются и не включаются в отображаемую сцену.</p>
<p><strong>3. Перспективные преобразования в OpenGL</strong></p>
<p>Параметры пирамиды видимости задаются функцией <strong>glFrustum()</strong>, смысл аргументов которой поясняет рис.
	4.1.</p>
<p><em>void </em><strong><em>glFrustum</em></strong><em>(GLdouble left, GLdouble right, GLdouble bottom, GLdouble top,
	GLdouble near, GLdouble far);</em></p>
<p>Значения аргументов near и far, задающих положение передней и задней отсекающих плоскостей, должны быть
	положительными и отсчитываться от центра проецирования вдоль оси проецирования. </p>
<p>Поскольку матрица проецирования умножается на текущую матрицу, сначала нужно задать режим работы с этой матрицей.
	Типичная последовательность операций представлена ниже. </p>
<p>glMatrixMode(GL_PROJECTION);</p>
<p><img alt="chap3-5.gif" src="1.png"/></p>
<p><em>Рис. 4.1</em></p>
<p>glLoadIdentity();</p>
<p>glFrustum(xmin, xmax, ymin, ymax, near, far);</p>
<p>Во многих приложениях предпочтительнее задавать не линейные параметры, характеризующие положение углов усеченной
	пирамиды видимости, а угол и поле зрения. Однако если картинная плоскость является прямоугольником, а не квадратом,
	то нужно задавать пару углов зрения: один в вертикальной плоскости, другой- в горизонтальной (рис. 4.2).</p>
<p><img alt="chap3-6.gif" src="2.png"/></p>
<p><em>Рис. 4.2</em></p>
<p><em>void </em><strong><em>gluPerspective</em></strong><em>(GLdouble fovy, GLdouble aspect, <br/>GLdouble near,
	GLdouble far);</em></p>
<p>Аргументы этой функции имеют следующий смысл:</p>
<ul>
	<li>fovy – угол зрения в вертикальной плоскости;</li>
	<li>aspect – отношение ширины окна картинной плоскости к его высоте;</li>
	<li>near и far – расстояние от центра проецирования до передней и задней отсекающих плоскостей.</li>
</ul>
<p><strong>4. Параллельное проецирование в OpenGL</strong></p>
<p>В составе OpenGL имеется только одна функция для задания параметров параллельного проецирования, которая формирует
	ортогональную проекцию. Зона видимости при этом превращается в параллелепипед (рис. 4.3.).</p>
<p><img alt="chap3-25.gif" src="3.png"/></p>
<p><em>Рис. 4.3</em></p>
<p><em>void </em><strong><em>glOrtho</em></strong><em>(GLdouble left, GLdouble right, GLdouble bottom, <br/>GLdouble
	top, GLdouble near, GLdouble far); </em></p>
<p>Аргументы вызова имеют тот же геометрический смысл, что и одноименные аргументы функции glFrustum().</p>
<p><strong>5. Задание положения и ориентации камеры</strong></p>
<p>В составе OpenGL имеется функция gluLookAt(), которая позволяет задать положение и ориентацию камеры (рис. 4.4).</p>
<p><em>void </em><strong><em>gluLookAt</em></strong><em>(GLdouble eyex, GLdouble eyey, GLdouble eyez, GLdouble centerx,
	GLdouble centery, GLdouble centerz, GLdouble upx, GLdouble upy, GLdouble upz);</em></p>
<p>Аргументы функции имеют следующий вид: </p>
<ul>
	<li>eyex, eyey, eyez – координаты точки наблюдения;</li>
	<li>centerx, centery, centerz – координаты контрольной точки объекта, указывающей центр сцены;</li>
	<li>upx, upy, upz- компоненты точки, которая задает положительное направления оси Y сцены.</li>
</ul>
<p><strong>Порядок выполнения работы</strong></p>
<ol>
	<li>Составить программу рисования куба.</li>
	<li>Получить перспективную и параллельную проекцию куба.</li>
	<li>Организовать перемещение камеры вокруг куба, изменяя координаты точки наблюдения – eyex, eyey, eyez. Для
		перемещения камеры использовать клавиатуру.
	</li>
</ol>
<p><strong>Контрольные вопросы</strong></p>
<ol>
	<li>Графический конвейер OpenGl.</li>
	<li>Виды проецирования. Параллельные и перспективные проекции.</li>
	<li>Способы получения триметрической, диметрической и изометрической проекции.</li>
</ol>
<p>Перспективные проеции. Точки схода.</p>
<h1><a id="_Toc454872987"></a>Лабораторная работа №5: “Структура программных продуктов”</h1>
<p><strong>Порядок выполнения работы </strong></p>
<p>1. Ознакомьтесь с теоретическими основами в настоящих указаниях и конспектах лекций. </p>
<p>2. Получите задание у преподавателя. </p>
<p>3. Сделайте скриншоты (кнопка клавиатуры PrtSc) выполненных заданий в текстовом (Word) файле <em>Фамилия_ЛР</em></p>
<p>4. Составьте отчет по лабораторной работе. </p>
<p>5. Отчитайте работу преподавателю.</p>
<p><strong>Цель работы</strong></p>
<p>Изучение методов работы с растровыми примитивами OpenGl и методов наложения текстур.</p>
<p><strong>1. Работа с изображением</strong></p>
<p>Существует множество графических форматов – bmp, pcx, gif, jpeg и прочие. OpenGL напрямую не поддерживает ни один из
	них. В OpenGL нет функций чтения/записи графических файлов, но поддерживается работа с массивами пикселей. Вы
	загружаете графический файл, используя библиотеки других фирм, в память и работаете с ними средствами OpenGL. В
	массиве данные о пикселах могут располагаться разными способами: RGB, BGR, RGBA; могут присутствовать не все
	компоненты; каждый элемент массива может занимать один байт, два, четыре или восемь; выравнивание может быть по
	байту, слову или двойному слову. В общем, форматов расположения данных о графическом изображении в памяти очень
	много. </p>
<p>Наиболее часто применяется формат, в котором информация о каждом пикселе хранится в формате RGB и занимает три байта,
	выравнивание по байту. В Auxiliary Library есть функция auxDIBImageLoad(LPCSTR), <a id="auxDIBImageLoad52"></a>которая
	загружает в память bmp-файл и возвращает указатель на структуру: </p>
<p> typedef struct _AUX_RGBImageRec {</p>
<p> GLint sizeX, sizeY;</p>
<p> unsigned char *data;</p>
<p>} AUX_RGBImageRec; </p>
<p>В OpenGL имеются функции для вывода массива пикселей на экран(glDrawPixels), <a id="glDrawPixels52"></a><a
		id="glCopyPixels52"></a>копирования(glCopyPixels), масштабирования(gluScaleImage). <a id="gluScaleImage52"></a>Здесь
	мы рассмотрим только glDrawPixels. Все остальные функции работы с изображениями устроены похожим образом. Для того
	чтобы отобразить графический файл в окне OpenGL, вы должны загрузить его в память, указать выравнивание, установить
	точку, с которой начинается вывод изображения, и вывести его на экран. Создайте новый проект. Объявите глобальную
	переменную – </p>
<p>AUX_RGBImageRec *image</p>
<p>Перед вызовом функции glutMainLoop() в функции main вставьте строку: </p>
<p>image = auxDIBImageLoad(«photo.bmp»); </p>
<p>Выравнивание устанавливается вызывом функции glPixelStorei <a id="glPixelStore52"></a>с параметром
	GL_UNPACK_ALIGNMENT и вторым параметром – целым числом, которое указывает выравнивание. </p>
<p><em>void glPixelStore{if}(GLenum pname, TYPEparam); </em></p>
<p>Функция установки способа хранения пикселов для выполнения следующих функций: glDrawPixels(), glReadPixels(),
	glBitmap(), glPolygonStipple(), glTexImage1D(), glTexImage2D(), glTexSubImage1D(), glTexSubImage2D(), and
	glGetTexImage().</p>
<p>Изображения выводятся прямо на экран. Поэтому все происходит в двухмерных координатах. Позиция, с которой начинается
	вывод изображения, указывается при помощи функции glRasterPos2d(x,y).</p>
<p>void glRasterPos{234}{sifd}(TYPE x, TYPE y, TYPE z, TYPE w);<br/>void glRasterPos{234}{sifd}v(TYPE *coords); </p>
<p>Функция установки текущей позиции растра: x, y, z, w – однородные координаты, определяющие позицию растра. Если
	используется функция glRasterPos2*(), то z подразумевается равным 0, а w равным 1.</p>
<p><a id="glRasterPos2d52"></a>Также Вы можете установить размер пикселя, вызвав функцию glPixelZoom. <a
		id="glPixelZoom52"></a>Первый параметр этой функции – ширина, второй – высота пикселя. Вызов этой функции с
	аргументами (1,1), что соответствует нормальному пикселю. Замените (1,1) на (3,2) и Вы увидите, как картинка
	растянется в три раза по горизонтали и в два раза по вертикали. Это случилось потому, что теперь каждый пиксель
	изображения соответствует прямоугольнику 3х2 в окне. </p>
<p>void glPixelZoom(GLfloat zoomx, GLfloat zoomy); </p>
<p>Функция устанавливает фактор увеличения/уменьшения при выполнении операции записи пикселя в буфер кадра
	(glDrawPixels() или glCopyPixels()) по x и y координатам. По умолчанию zoomx и zoomy равны 1.0. Если оба значения
	равны 2, то каждый пиксель исходного изображения выводится в виде 4 пикселей в буфере кадра. Отрицательное значение
	фактора выполняет зеркальное отображение изображения относительно текущей позиции растра.</p>
<p>И, наконец, вывод осуществляет функция glDrawPixels. Первые два параметра – это ширина и высота. Далее, вы указываете
	формат, в котором хранится информация в памяти, и тип элементов массива. Последним указывается массив данных. </p>
<p>void glDrawPixels(GLsizei width, GLsizei height, GLenum format, <br/>GLenum type, const GLvoid *pixels); </p>
<p>Функция выводит изображение прямоугольного массива пикселей размером width на height. Прямоугольник выводится,
	начиная с левого нижнего угла изображения в текущей позиции растра, format и type параметры могут принимать одно из
	значений, приведенных в Руководстве программиста по OpenGL. Массив pixels содержит данные о пикселях, которые должны
	быть выведены. </p>
<p>В функцию display вставьте следующий код: </p>
<p>glRasterPos2d(-4.5,-3); // нижний левый угол</p>
<p>glPixelZoom(1,1);</p>
<p>glPixelStorei(GL_UNPACK_ALIGNMENT, 1); // выравнивание</p>
<p>glDrawPixels(image-&gt;sizeX, image-&gt;sizeY, // ширина и высота</p>
<p> GL_RGB, GL_UNSIGNED_BYTE, // формат и тип</p>
<p> image-&gt;data); // сами данные</p>
<p>Также в OpenGL имеется функция glBitmap для отображения битовых массивов. Битовый массив – это последовательность
	байт, которые кодируют картинку из двух цветов. </p>
<p><strong>2. Наложение текстуры</strong></p>
<p>Одного вывода изображений недостаточно для создания полноценных трехмерных сцен. Часто возникает потребность
	накладывать изображение на трехмерные объекты и поворачивать/сдвигать их. Для этих целей существуют текстуры. Также
	текстуры помогут вам покрыть весь объект в виде мозаики. Скажем, когда у вас имеется кирпичная стена, то вам не надо
	загружать изображение с кучей кирпичей. Достаточно загрузить один кирпич и указать, что эту текстуру нужно
	размножить по всей плоскости. </p>
<p>Для того чтобы наложить текстуру на объект, вы должны: </p>
<p>1. Загрузить графический файл в память. </p>
<p>2. Создать имя-идентификатор текстуры. </p>
<p>3. Сделать его активным. </p>
<p>4. Создать саму текстуру в памяти. </p>
<p>5. Установить параметры текстуры. </p>
<p>6. Установить параметры взаимодействия текстуры с объектом. </p>
<p>7. Связать координаты текстуры с объектом. </p>
<p>1. Загрузка графического файла выполняется в соответствии с п. 1 лабораторной работы.</p>
<p>2. Создать имя-идентификатор текстуры. </p>
<p>При использовании в сцене нескольких текстур в OpenGL применяется подход, напоминающий создание списков изображений.
	Вначале с помощью команды </p>
<p>void glGenTextures(GLsizei n, GLuint*textures)</p>
<p>надо создать n идентификаторов для используемых текстур, которые будут записаны в массив textures.</p>
<p>Для единственной текстуры в приложении можно использовать следующую последовательность операторов:</p>
<p>static GLuint texName;</p>
<p>…</p>
<p>glGenTextures(1, &amp;texName);</p>
<p>3. Сделать имя текстуры активным.</p>
<p>Перед началом определения свойств очередной текстуры следует вызвать команду</p>
<p>void glBindTexture(GLenum target, GLuint texture),</p>
<p>где target может принимать значения GL_TEXTURE_1D или GL_TEXTURE_2D, а параметр texture должен быть равен
	идентификатору той текстуры, к которой будут относиться последующие команды. Для того чтобы в процессе рисования
	сделать текущей текстуру с некоторым идентификатором, достаточно опять вызвать команду glBindTexture() c
	соответствующим значением target и texture. Таким образом, команда glBindTexture() включает режим создания текстуры
	с идентификатором texture, если такая текстура еще не создана, либо режим ее использования, т. е. делает эту
	текстуру текущей. Например,</p>
<p>glBindTexture(GL_TEXTURE_2D, texName);</p>
<p>4. Создание текстуры в памяти.</p>
<p>Теперь создать саму текстуру в памяти. Массив байт в структуре AUX_RGBImageRec не является еще текстурой, потому что
	у текстуры много различных параметров. Создав текстуру, мы наделим ее определенными свойствами. Среди параметров
	текстуры вы указываете уровень детализации, способ масшабирования и связывания текстуры с объектом. Уровень
	детализации нужен для наложения текстуры на меньшие объекты, т.е. когда площадь на экране меньше размеров
	изображения. Нулевой уровень детализации соответствует исходному изображению размером 2<sup>n</sup>x2<sup>m</sup>,
	первый уровень – 2<sup>n</sup>-1x2<sup>m</sup>-1, k-й уровень – 2<sup>n</sup>-kx2<sup>m</sup><a
			id="glTexImage2D54"></a><a id="gluBuild2DMipmaps54"></a>-k. Число уровней соответствует min(n,m). Для
	создания текстуры имеется две функции glTexImage[1/2]D и gluBuild[1/2]DMipmaps. </p>
<p>glTexImage2D( gluBuild2DMipmaps(</p>
<p> GLenum target, GLenum target, </p>
<p> GLint lavel, GLint components, </p>
<p> GLint components, GLsizei width,</p>
<p> GLsizei width, GLsizei height,</p>
<p> GLsizei height, GLenum format,</p>
<p> GLint border, GLenum type,</p>
<p> GLenum format, const GLvoid* pixels) </p>
<p> GLenum type,</p>
<p> const GLvoid* pixels)</p>
<p>Основное различие в том, что первая функция создает текстуру одного определенного уровня детализации и воспринимает
	только изображения, размер которых кратен степени двойки. Вторая функция более гибкая. Она генерирует текстуры всех
	уровней детализации. Также эта функция не требует, чтобы размер изображения был кратен степени двойки. Она сама
	сожмет/растянет изображение подходящим образом, хотя возможно окажется, что и не вполне подходящим. Я воспользуюсь
	функцией glTexImage2D. Первый параметр этой функции должен быть GL_TEXTURE_2D. Второй – уровень детализации. Нам
	нужно исходное изображение, поэтому уровень детализации – ноль. Третий параметр указывает количество компонентов
	цвета. У нас изображение хранится в формате RGB. Поэтому значение этого параметра равно трем. Четвертый и пятый
	параметры – ширина и высота изображения. Шестой – ширина границы; у нас гарницы не будет, поэтому значение этого
	параметра – ноль. Далее, седьмой параметр – формат хранения пикселей в массиве – GL_RGB и тип – GL_UNSIGNED_BYTE. И,
	наконец, восьмой параметр – указатель на массив данных. Еще вы должны вызвать функцию glPixelStorei и задать, что
	выравнивание в массиве данных идет по байту.</p>
<p> Добавьте следующий код в функцию main. </p>
<p>glPixelStorei(GL_UNPACK_ALIGNMENT, 1);</p>
<p>glTexImage2D(GL_TEXTURE_2D, 0, 3, </p>
<p> photo_image-&gt;sizeX,</p>
<p> photo_image-&gt;sizeY,</p>
<p> 0, GL_RGB, GL_UNSIGNED_BYTE,</p>
<p> photo_image-&gt;data);</p>
<p>Аналогичный результат можно получить, вставив вызов gluBuild2DMipmaps с параметрами, указанными ниже. </p>
<p>gluBuild2DMipmaps(GL_TEXTURE_2D, 3, </p>
<p> photo_image-&gt;sizeX,</p>
<p> photo_image-&gt;sizeY,</p>
<p> GL_RGB, GL_UNSIGNED_BYTE,</p>
<p> photo_image-&gt;data);</p>
<p>5. Установить параметры текстуры. </p>
<p>Теперь нужно установить параметры текстуры. Для этого служит функция<a id="glTexParameter54"></a></p>
<p>glTexParameter[if](GLenum target, GLenum pname, GLenum param)</p>
<p>Первый параметр принимает значение GL_TEXTURE_1D или GL_TEXTURE_2D. Второй – pname – определяет параметр текстуры,
	который вы будете изменять. И третий параметр – это устанавливаемое значение. Если вы воспользовались
	gluBuild2DMipmaps вместо glTexImage2D, то вам не надо устанавливать следующие параметры, так как уже сформированы
	текстуры всех уровней детализации, и OpenGL сможет подобрать текстуру нужного уровня, если площадь объекта не
	совпадает с площадью текстуры. В противном случае, Вы должны добавить следующие строки: </p>
<p>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);</p>
<p>glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST); </p>
<p>Вы указали, что для уменьшения и увеличения текстуры используется <a id="GL\_NEAREST54"></a><a id="GL\_LINEAR54"></a>алгоритм
	GL_NEAREST. Это означает, что цветом пикселя объекта, на который накладывается текстура, становится цвет ближайшего
	пикселя элемента текстуры. Вместо GL_NEAREST можно указать GL_LINEAR, т.е. цвет элемента объекта будет вычисляться
	как среднее арифметическое четырех элементов текстуры. Имеются еще четыре алгоритма вычисления цвета элемента
	объекта. Их можно устанавливать, когда вы создали текстуру со всеми уровнями детализации, т.к. применяют алгоритмы
	GL_NEAREST и GL_LINEAR к одному или двум ближайшим уровням детализации. </p>
<p>6. Установка параметров взаимодействия текстуры с объектом.</p>
<p><a id="glTexEnv54"></a>Вы можете установить взаимодействие текстуры с объектом. Тут имеются два режима при
	использовании трех компонентов цвета. Первый режим, установленный по умолчанию, – когда у вас учитывается цвет
	объекта и цвет текстуры. Результирующий цвет получается перемножением компонентов цвета текстуры на компоненты цвета
	объекта. Скажем, если цвет текстуры – (r,g,b), а цвет объекта, на который она накладывается, – (r0,g0,b0), то
	результирующим цветом будет – (r*r0,g*g0,b*b0). В случае, если цвет объекта черный – (0,0,0), то вы не увидите на
	нем текстуру, так как она вся будет черной. Второй режим взаимодействия, когда цвет объекта не учитывается.
	Результирующим цветом будет цвет текстуры. Эти параметры можно установить следующим образом. </p>
<p>glTexEnv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE)</p>
<p>glTexEnv(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL)</p>
<p><a id="GL\_MODULATE54"></a><a id="GL\_DECAL54"></a>По умолчанию используется режим GL_MODULATE. На этом заканчивается
	создание текстуры.</p>
<p>6. Связь координат текстуры с объектом. </p>
<p>Осталось связать координаты текстуры с координатами объекта.</p>
<p>void glTexCoord{1234}{sifd}(TYPEcoords);<br/>void glTexCoord{1234}{sifd}v(TYPE *coords); </p>
<p>Функция устанавливает соответствие текущих координат текстуры (s, t, r, q) с координатами вершины примитива OpenGL,
	следующей за этой командой. При исползовании функции glTexCoord2*() небходимо определить только координаты s и
	t.</p>
<p>Например, чтобы связать координаты текстуры с вершинами прямоугольника, можно использовать следующую
	последовательность команд в функции display: </p>
<p> glEnable(GL_TEXTURE_2D);</p>
<p> glColor3d(1,1,1);</p>
<p> glBindTexture(GL_TEXTURE_2D, space_tex );</p>
<p> glBegin(GL_QUADS);</p>
<p> glTexCoord2d(0,0); glVertex3d(-5,-5, -0.1);</p>
<p> glTexCoord2d(0,1); glVertex3d(-5, 5, -0.1);</p>
<p> glTexCoord2d(1,1); glVertex3d( 5, 5, -0.1);</p>
<p> glTexCoord2d(1,0); glVertex3d( 5,-5, -0.1);</p>
<p> glEnd();</p>
<p> glDisable(GL_TEXTURE_2D);</p>
<p>glTexCoord2d сопоставляет координаты текстуры вершинам четырехугольника. Нижний левый угол текстуры имеет координаты
	(0,0), а верхний правый – (1,1). </p>
<p><strong>Порядок выполнения работы</strong></p>
<p>1. Получить средствами OpenGL изображение .bmp- файла, заданного преподавателем.</p>
<p>2. Наложить изображение этого файла на все грани куба из лабораторной работы № 4.</p>
<p><strong>Контрольные вопросы</strong></p>
<ol>
	<li>Вывод графических изображений на экран средствами OpenGL.</li>
	<li>Назначение текстуры. Наложение текстуры на объект средствами OpenGL.</li>
	<li>Форматы графических файлов.</li>
	<li>Организация видеопамяти персональных компьютеров в режимах SVGA.</li>
	<li> Организация видеопамяти персональных компьютеров в режимах VGA 12h, 13h.</li>
</ol>
<h1><a id="_Toc454872988"></a>Лабораторная работа №6: “Стиль программирования”</h1>
<p><strong>Порядок выполнения работы </strong></p>
<p>1. Ознакомьтесь с теоретическими основами в настоящих указаниях и конспектах лекций. </p>
<p>2. Получите задание у преподавателя. </p>
<p>3. Сделайте скриншоты (кнопка клавиатуры PrtSc) выполненных заданий в текстовом (Word) файле <em>Фамилия_ЛР</em></p>
<p>4. Составьте отчет по лабораторной работе. </p>
<p>5. Отчитайте работу преподавателю.</p>
<p><strong>Цель работы</strong></p>
<p>Изучение способов включения источников света в сцену и методов учета свойств материала в OpenGL</p>
<p><strong>1. Описание источников света в OpenGL</strong></p>
<p>В системе OpenGl поддерживаются источники света четырех типов: фонового освещения (ambient lighting), точечные
	источники (point sources), прожекторы (spotlights), удаленные источники света (distant light). В одной программе
	может использоваться до восьми источников света. Каждый источник света имеет свой набор параметров, в том числе
	программный код включения/выключения. Параметры, описывающие источник света, соответствуют параметрам модели Фонга.
	Для установки векторных параметров используется функция glLightfv(), которая имеет следующий формат обращения:</p>
<p>glLightfv(source, parameter, pointer_to_array);</p>
<p>Существует четыре векторных параметра, которые определяют положение и направление лучей источника и цветовой состав
	его составляющих – фоновой, диффузионной и зеркальной.</p>
<p>Для установки скалярных параметров в OpenGL служит функция glLightf():</p>
<p>glLightf(source, parameter, value);</p>
<p>Пусть, например, требуется включить в сцену источник GL_LIGHT0, который должен находиться в точке (1.0, 2.0, 3.0).
	Положение источника сохраняется в программе в виде точки в однородных координатах:</p>
<p>GLfloat light0_pos[]={1.0, 2.0, 3.0, 1.0};</p>
<p>Если четвертый компонент этой точки равен нулю, то точечный источник превращается в удаленный, для которого
	существенно только направление лучей:</p>
<p>GLfloat light0_dir[]={1.0, 2.0, 3.0, 0.0};</p>
<p>Далее определяется цветовой состав фоновой, диффузионной и зеркальной составляющих источника. Если в рассматриваемом
	примере источник имеет белую зеркальную составляющую, а фоновая и диффузионная составляющие должны быть красными, то
	фрагмент программы, формирующий источник, выглядит следующим образом:</p>
<p> GLfloat diffise0[]= {1.0, 0.0, 0.0, 1.0};</p>
<p> GLfloat ambient0[]={1.0, 0.0, 0.0, 1.0};</p>
<p> GLfloat specular0[]={1.0, 1.0, 1.0, 1.0};</p>
<p> glEnable(GL_LIGHTING);</p>
<p> glEnable(GL_LIGHT0);</p>
<p> glLightfv(GL_LIGHT0, GL_POSITION, light0_pos);</p>
<p> glLightfv(GL_LIGHT0, GL_AMBIENT, ambient0);</p>
<p> glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuse0);</p>
<p> glLightfv(GL_LIGHT0, GL_SPECULAR, specular0);</p>
<p>Функция glEnable() вызывается дважды: сначала для включения режима анализа освещения, а затем для включения в сцену
	конкретного источника.</p>
<p>В сцену можно включить и глобальное фоновое освещение, которое не связано ни с каким отдельным источником освещения.
	Если, например, требуется слабо подсветить все объекты сцены белым цветом, в программу следует включит такой
	фрагмент кода:</p>
<p>GLfloat global_ambient[]={0.1, 0.1, 0.1, 1.0};</p>
<p>glLightModelfv(GL_LIGHT_MODEL_AMBIENT, global_ambient);</p>
<p>В модели освещения член, учитывающий расстояние до источника, имеет вид:</p>
<p>f(d)= 1/(a+ b*d+ c*d^2)</p>
<p>и постоянную, линейную и квадратичную составляющие. Соответствующие коэффициенты для каждого источника задаются
	индивидуально с помощью функции установки скалярных параметров, например:</p>
<p>glLightf(GL_LIGHT0, GL_CONSTANT_ATTENATION, a);</p>
<p>Для преобразование точечного источника в прожектор нужно задать направление луча прожектора (GL_SPOT_DIRECTION),
	показатель функции распределения интенсивности (GL_SPOT_EXPONENT) и угол рассеяния луча (GL_SPOT_CUTTOF). Эти
	параметры устанавливаются с помощью функций glLightf() и glLightfv().</p>
<p>Параметры, устанавливаемые для источников света по умолчанию приведены в таблице 6.1.</p>
<p><em>Таблица 6.1</em></p>
<p><strong>Параметры, устанавливаемые для источников света по умолчанию</strong></p>
<table>
	<tr>
		<td><p>Имя параметра</p></td>
		<td><p>Значение</p></td>
		<td><p>Содержание</p></td>
	</tr>
	<tr>
		<td><p>GL_AMBIENT</p></td>
		<td><p>(0.0, 0.0, 0.0, 1.0)</p></td>
		<td><p>ambient RGBA intensity of light</p></td>
	</tr>
	<tr>
		<td><p>GL_DIFFUSE</p></td>
		<td><p>(1.0, 1.0, 1.0, 1.0)</p></td>
		<td><p>diffuse RGBA intensity of light</p></td>
	</tr>
	<tr>
		<td><p>GL_SPECULAR</p></td>
		<td><p>(1.0, 1.0, 1.0, 1.0)</p></td>
		<td><p>specular RGBA intensity of light</p></td>
	</tr>
	<tr>
		<td><p>GL_POSITION</p></td>
		<td><p>(0.0, 0.0, 1.0, 0.0)</p></td>
		<td><p>(<em>x, y, z, w</em>) position of light</p></td>
	</tr>
	<tr>
		<td><p>GL_SPOT_DIRECTION</p></td>
		<td><p>(0.0, 0.0, -1.0)</p></td>
		<td><p>(<em>x, y, z</em>) direction of spotlight</p></td>
	</tr>
	<tr>
		<td><p>GL_SPOT_EXPONENT</p></td>
		<td><p>0.0</p></td>
		<td><p>spotlight exponent</p></td>
	</tr>
	<tr>
		<td><p>GL_SPOT_CUTOFF</p></td>
		<td><p>180.0</p></td>
		<td><p>spotlight cutoff angle</p></td>
	</tr>
	<tr>
		<td><p>GL_CONSTANT_ATTENUATION</p></td>
		<td><p>1.0</p></td>
		<td><p>constant attenuation factor</p></td>
	</tr>
	<tr>
		<td><p>GL_LINEAR_ATTENUATION</p></td>
		<td><p>0.0</p></td>
		<td><p>linear attenuation factor</p></td>
	</tr>
	<tr>
		<td><p>GL_QUADRATIC_ATTENUATION</p></td>
		<td><p>0.0</p></td>
		<td><p>quadratic attenuation factor</p></td>
	</tr>
</table>
<p><strong>2. Спецификация материалов в OpenGL</strong></p>
<p>В OpenGL свойства материалов соответствуют поддерживаемым параметрам источников света и модели отражения Фонга.
	Программист имеет возможность связывать разные материалы с внутренней и внешней сторонами одной и той же
	поверхности. Все параметры, обрабатываемые в модели отражения, задаются вызовом двух функций:</p>
<p> glMaterialfv(face, type, pointer_to_array);</p>
<p> glMaterilf(face, type, value);</p>
<p>Для определения коэффициентов отражения для фоновой, диффузионной и зеркальной составляющих (k<sub>a</sub>,
	k<sub>d</sub>, k<sub>s</sub>) по каждому из первичных цветов в программу нужно включить определение трех массивов:
</p>
<p> GLfloat ambient[]= {0.2, 0.2, 0.2, 1.0};</p>
<p> GLfloat diffise[]= {1.0, 0.8, 0.0, 1.0};</p>
<p> GLfloat specular[]= {1.0, 1.0, 1.0, 1.0};</p>
<p>Первый задает небольшое значение коэффициента отражения фоновой составляющей, причем коэффициент одинаков для всех
	первичных цветов, что эквивалентно отражению белого цвета. Для диффузной составляющей набор коэффициентов по
	отдельным цветам задает в результате отражение желтого цвета, а для зеркальной составляющей коэффициенты отражения
	по всем первичным цветам опять одинаковы. Если внешние и внутренние стороны поверхностей имеют одинаковые параметры
	материала, то при вызове функции glMaterialfv() ей в качестве параметра передается константа GL_FRONT_AND_BACK:</p>
<p> glMaterialfv(G_FRONT_AND_BACK, GL_AMBIENT, ambient);</p>
<p> glMaterialfv(G_FRONT_AND_BACK, GL_DIFFUSE, diffuse);</p>
<p> glMaterialfv(G_FRONT_AND_BACK, GL_SPECULAR, specular);</p>
<p>Если параметры для зеркальной и диффузионной составляющих одинаковы, то можно задавать их одним вызовом функции
	glMaterialfv(), передав ей в качестве параметра type константу GL_DIFFUSE_AND_SPECULAR. При индивидуальном
	определении параметров материалов для внутренней и внешней стороны в качестве аргумента face используются
	соответственно константы GL_FRONT и GL_BACK. </p>
<p>Коэффициент резкости бликов – показатель степени зеркального отражения в модели Фонга – задается вызовом функции
	glMaterialfv(), которой в качестве параметра type передается константа GL_SHININESS:</p>
<p>glMaterialfv(GL_FRONT_AND_BACK, GL_SHININESS, 100);</p>
<p>Свойства материала являются параметрами режима – их текущие значения ассоциируются со всеми объектами, задаваемыми в
	программе, до тех пор, пока не будут изменены с помощью функций glMaterilfv() или glMaterialf().</p>
<p>В системе OpenGL можно включить в сцену излучающую поверхность, которая сама по себе является источником света. Со
	всей такой поверхностью ассоциируется постоянный свет, который задается так же, как и другие свойства материала.
	Например, для придания такой поверхности сине-зеленого (бирюзового) цвета нужно включить в программу следующий
	фрагмент:</p>
<p>GLfloat emission[]={0.0, 0.3, 0.3, 1.0};</p>
<p>glMaterialfv(GL_FRONT_AND_BACK, GL_EMISSION, emission);</p>
<p>Параметры, устанавливаемые для свойств материалов по умолчанию, приведены в табл. 6.2.</p>
<p><em>Таблица 6.2</em></p>
<p><strong>Значения по умолчанию для параметра glMaterial*()</strong></p>
<table>
	<tr>
		<td><p><strong>Имя параметра</strong></p></td>
		<td><p><strong>Значение</strong></p></td>
		<td><p><strong>Содержание</strong></p></td>
	</tr>
	<tr>
		<td><p>GL_AMBIENT</p></td>
		<td><p>(0.2, 0.2, 0.2, 1.0)</p></td>
		<td><p>ambient color of material</p></td>
	</tr>
	<tr>
		<td><p>GL_DIFFUSE</p></td>
		<td><p>(0.8, 0.8, 0.8, 1.0)</p></td>
		<td><p>diffuse color of material</p></td>
	</tr>
	<tr>
		<td><p>GL_AMBIENT_AND_DIFFUSE</p></td>
		<td></td>
		<td><p>ambient and diffuse color of material</p></td>
	</tr>
	<tr>
		<td><p>GL_SPECULAR</p></td>
		<td><p>(0.0, 0.0, 0.0, 1.0)</p></td>
		<td><p>specular color of material</p></td>
	</tr>
	<tr>
		<td><p>GL_SHININESS</p></td>
		<td><p>0.0</p></td>
		<td><p>specular exponent</p></td>
	</tr>
	<tr>
		<td><p>GL_EMISSION</p></td>
		<td><p>(0.0, 0.0, 0.0, 1.0)</p></td>
		<td><p>emissive color of material</p></td>
	</tr>
	<tr>
		<td><p>GL_COLOR_INDEXES</p></td>
		<td><p>(0,1,1)</p></td>
		<td><p>ambient, diffuse, and specular color indices</p></td>
	</tr>
</table>
<p><strong>3. Пример программы, использующей <br/>источник света и свойства материала</strong></p>
<p>#include &lt;GL/glut.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>/* Initialize material property, light source, lighting model,</p>
<p> * and depth buffer.</p>
<p> */</p>
<p>void init<strong>(</strong>void<strong>)</strong></p>
<p><strong>{</strong></p>
<p> GLfloat mat_specular<strong>[]</strong> <strong>=</strong> <strong>{</strong> 1.0<strong>,</strong>
	1.0<strong>,</strong> 1.0<strong>,</strong> 1.0 <strong>};</strong></p>
<p> GLfloat mat_shininess<strong>[]</strong> <strong>=</strong> <strong>{</strong> 50.0 <strong>};</strong></p>
<p> GLfloat light_position<strong>[]</strong> <strong>=</strong> <strong>{</strong> 1.0<strong>,</strong>
	1.0<strong>,</strong> 1.0<strong>,</strong> 0.0 <strong>};</strong></p>
<p> glClearColor <strong>(</strong>0.0<strong>,</strong> 0.0<strong>,</strong> 0.0<strong>,</strong>
	0.0<strong>);</strong></p>
<p> glShadeModel <strong>(</strong>GL_SMOOTH<strong>);</strong></p>
<p> glMaterialfv<strong>(</strong>GL_FRONT<strong>,</strong> GL_SPECULAR<strong>,</strong>
	mat_specular<strong>);</strong></p>
<p> glMaterialfv<strong>(</strong>GL_FRONT<strong>,</strong> GL_SHININESS<strong>,</strong>
	mat_shininess<strong>);</strong></p>
<p> glLightfv<strong>(</strong>GL_LIGHT0<strong>,</strong> GL_POSITION<strong>,</strong>
	light_position<strong>);</strong></p>
<p> glEnable<strong>(</strong>GL_LIGHTING<strong>);</strong></p>
<p> glEnable<strong>(</strong>GL_LIGHT0<strong>);</strong></p>
<p> glEnable<strong>(</strong>GL_DEPTH_TEST<strong>);</strong></p>
<p> glEnable<strong>(</strong>GL_COLOR_MATERIAL<strong>);</strong></p>
<p><strong>}</strong></p>
<p>void display<strong>(</strong>void<strong>)</strong></p>
<p><strong>{</strong></p>
<p> glClear <strong>(</strong>GL_COLOR_BUFFER_BIT <strong>|</strong> GL_DEPTH_BUFFER_BIT<strong>);</strong></p>
<p> glColor3f<strong>(</strong>1.0<strong>,</strong>0.0<strong>,</strong>0.0<strong>);</strong></p>
<p> glutSolidSphere <strong>(</strong>1.0<strong>,</strong> 20<strong>,</strong> 16<strong>);</strong></p>
<p> glFlush <strong>();</strong></p>
<p><strong>}</strong></p>
<p>void reshape <strong>(</strong>int w<strong>,</strong> int h<strong>)</strong></p>
<p><strong>{</strong></p>
<p> glViewport <strong>(</strong>0<strong>,</strong> 0<strong>,</strong> <strong>(</strong>GLsizei<strong>)</strong>
	w<strong>,</strong> <strong>(</strong>GLsizei<strong>)</strong> h<strong>);</strong></p>
<p> glMatrixMode <strong>(</strong>GL_PROJECTION<strong>);</strong></p>
<p> glLoadIdentity<strong>();</strong></p>
<p><strong>if</strong> <strong>(</strong>w <strong>&lt;=</strong> h<strong>)</strong></p>
<p> glOrtho <strong>(-</strong>1.5<strong>,</strong> 1.5<strong>,</strong> <strong>-</strong>1.5<strong>*(</strong>GLfloat<strong>)</strong>h<strong>/(</strong>GLfloat<strong>)</strong>w<strong>,</strong>
</p>
<p> 1.5<strong>*(</strong>GLfloat<strong>)</strong>h<strong>/(</strong>GLfloat<strong>)</strong>w<strong>,</strong>
	<strong>-</strong>10.0<strong>,</strong> 10.0<strong>);</strong></p>
<p><strong>else</strong></p>
<p> glOrtho
	<strong>(-</strong>1.5<strong>*(</strong>GLfloat<strong>)</strong>w<strong>/(</strong>GLfloat<strong>)</strong>h<strong>,</strong>
</p>
<p> 1.5<strong>*(</strong>GLfloat<strong>)</strong>w<strong>/(</strong>GLfloat<strong>)</strong>h<strong>,</strong>
	<strong>-</strong>1.5<strong>,</strong> 1.5<strong>,</strong> <strong>-</strong>10.0<strong>,</strong> 10.0<strong>);</strong>
</p>
<p> glMatrixMode<strong>(</strong>GL_MODELVIEW<strong>);</strong></p>
<p> glLoadIdentity<strong>();</strong></p>
<p><strong>}</strong></p>
<p>void keyboard<strong>(</strong>unsigned char key<strong>,</strong> int x<strong>,</strong> int y<strong>)</strong>
</p>
<p><strong>{</strong></p>
<p><strong>switch</strong> <strong>(</strong>key<strong>)</strong> <strong>{</strong></p>
<p><strong>case</strong> 27<strong>:</strong></p>
<p> exit<strong>(</strong>0<strong>);</strong></p>
<p><strong>break;</strong></p>
<p><strong>}</strong></p>
<p><strong>}</strong></p>
<p>int main<strong>(</strong>int argc<strong>,</strong> char<strong>**</strong> argv<strong>)</strong></p>
<p><strong>{</strong></p>
<p> glutInit<strong>(&amp;</strong>argc<strong>,</strong> argv<strong>);</strong></p>
<p> glutInitDisplayMode <strong>(</strong>GLUT_SINGLE <strong>|</strong> GLUT_RGB <strong>|</strong> GLUT_DEPTH<strong>);</strong>
</p>
<p> glutInitWindowSize <strong>(</strong>500<strong>,</strong> 500<strong>);</strong></p>
<p> glutInitWindowPosition <strong>(</strong>100<strong>,</strong> 100<strong>);</strong></p>
<p> glutCreateWindow <strong>(</strong>argv<strong>[</strong>0<strong>]);</strong></p>
<p> init <strong>();</strong></p>
<p> glutDisplayFunc<strong>(</strong>display<strong>);</strong></p>
<p> glutReshapeFunc<strong>(</strong>reshape<strong>);</strong></p>
<p> glutKeyboardFunc<strong>(</strong>keyboard<strong>);</strong></p>
<p> glutMainLoop<strong>();</strong></p>
<p><strong>return</strong> 0<strong>;</strong></p>
<p><strong>}</strong></p>
<p><strong>4. Задание на лабораторную работу</strong></p>
<ol>
	<li>Отладить программу, приведенную в п.3.</li>
	<li>Отключить все источники света, кроме глобального фонового освещения.</li>
	<li>Добавить точечный источник света.</li>
	<li>Превратить точечный источник света в прожектор.</li>
</ol>
<p>5. Изменить свойства материала в соответствии с вариантом, заданным преподавателем </p>
<p><strong>Контрольные вопросы</strong></p>
<ol>
	<li>Цветовые модели, используемые в компьютерной графике. RGB – модель.</li>
	<li>Методы закрашивания граней объекта Метод Гуро. Метод Фонга.</li>
	<li>Способы задания свойств источников света в OpenGL.</li>
</ol>
<p>Способы задания свойств материала в OpenGL.</p>
<h1><a id="_Toc454872989"></a>Лабораторная работа №7: “Языки программирования”</h1>
<p><strong>Порядок выполнения работы </strong></p>
<p>1. Ознакомьтесь с теоретическими основами в настоящих указаниях и конспектах лекций. </p>
<p>2. Получите задание у преподавателя. </p>
<p>3. Сделайте скриншоты (кнопка клавиатуры PrtSc) выполненных заданий в текстовом (Word) файле <em>Фамилия_ЛР</em></p>
<p>4. Составьте отчет по лабораторной работе. </p>
<p>5. Отчитайте работу преподавателю.</p>
<p><strong>Цель работы</strong></p>
<p>Изучение средств OpenGL для изображения кривых и поверхностей</p>
<p><strong>1. Кривые Безье</strong></p>
<p>Кривая Безье задается векторной функцией одной переменной</p>
<p>C(u) = [ X(u), Y(u), Z(u)],</p>
<p>где <strong>u</strong> изменяется в некоторой области, например, [0.0, 1.0].</p>
<p>Фрагмент поверхности Безье задается векторной функцией двух переменных</p>
<p>S(u, v) = [ X(u, v), Y(u, v), Z(u, v) ].</p>
<p>Для каждого значения <strong>u</strong> и <strong>v</strong> формула C( ) или S( ) вычисляет точку на кривой
	(поверхности). При использовании Безье-вычисления сначала выбирают функцию C( ) или S( ), включают ее
	(Безье-вычислитель), а затем используют команду glEvalCoord1( ) или glEvalCoord2( ) вместо команды glVertex*( ). В
	этом случае вершина кривой или поверхности может использоваться точно так же, как и любая другая вершина, например,
	для формирования точки или линии. Кроме того, другие команды автоматически генерируют серии вершин, образующих
	пространство регулярной однородной сетки по оси <strong>u</strong> (или по осям <strong>u</strong> и
	<strong>v</strong> ). </p>
<p>Если представляет набор контрольных точек, то уравнение C(u) =  – представляет собой кривую Безье при изменении
	<strong>u</strong> от 0.0 до 1.0, где – многочлен Бернштейна степени n, который задается следующим уравнением</p>
<p></p>
<p>В составе OpenGL имеются средства поддержки работы с кривыми и поверхностями Безье – Безье-вычислитель, которые
	позволяют вычислять значения полиномов Безье любого порядка. Безье вычислитель можно использовать для работы с
	полиномами от одной, двух, трех и четырех переменных.</p>
<p>Функция обработки полинома одной переменной настраивается в процессе инициализации OpenGL – программы посредством
	вызова функции </p>
<p>glMap1f(type, u_min, u_max, stride, order, point array)</p>
<p>Аргумент type задает тип объекта, который будет представлен полиномом Безье. Можно назначить в качестве значения
	этого аргумента константы, задающие трех- и четырехмерные геометрические точки, цвет в формате RGBA, нормали,
	индексированные цвета и координаты текстур ( от одно- до четырехмерных).</p>
<p> Указатель на массив опорных точек полинома передается функции через аргумент point_array. Аргументы u_min, u_max
	определяют область существования параметра полинома. Аргумент stride представляет собой количество значений
	параметра между сегментами кривой. Значение аргумента order должно быть равно количеству опорных точек. Для
	формирования кубической трехмерной кривой в форме В-сплайна, определенной на интервале (0,1), функции glMap1f()
	следует передать такой набор аргументов:</p>
<p> point data[]= {…};</p>
<p> glMap1f(GL_MAP_VERTEX_3, 0.0, 1.0, 3, 4, data);</p>
<p>После настройки функция активизируется посредством вызова:</p>
<p> glEnable(type);</p>
<p>Если функция расчета активизирована, то можно получить от нее значения полинома, вызвав функцию:</p>
<p> glEvalCoord1f(u);</p>
<p>Таким образом, обращение к glEvalCoord1f() может заменить обращение к функциям glVertex(), glColor(), glNormal().
	Пусть, например, функция расчета настроена на формирование кривой Безье на интервале (0,10) по некоторому массиву
	опорных точек. Набор из 100 точек кривой, равноотстоящих на этом интервале можно получить с помощью такого фрагмента
	программы:</p>
<p>glBegin(GL_LINE_STRIP)</p>
<p>for(i=0; i&lt;100; i++) glEvalCoord1f( (float)i/100.);</p>
<p>glEnd(); </p>
<p>Если значения параметра u распределены равномерно, то для вычисления точек на кривой следует использовать функции
	glMapGrid1f() и glEvalMesh1(), например:</p>
<p> glMapGrid1f(100, 0.0, 10.0);</p>
<p> glEvalMesh1(GL_LINE, 0, 100);</p>
<p>После вызова glMapGrid1f() устанавливается равномерная сетка в 100 отсчетов, а после вызова функции glEvalMesh1()
	будет сформирована кривая.</p>
<p>Пример программы вычисления и рисования полинома Безье.</p>
<p>#include &lt;GL/glut.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>GLfloat ctrlpoints<strong>[</strong>4<strong>][</strong>3<strong>]</strong> <strong>=</strong> <strong>{</strong></p>
<p><strong>{</strong> <strong>-</strong>4.0<strong>,</strong> <strong>-</strong>4.0<strong>,</strong>
	0.0<strong>},</strong> <strong>{</strong> <strong>-</strong>2.0<strong>,</strong> 4.0<strong>,</strong> 0.0<strong>},</strong>
</p>
<p><strong>{</strong>2.0<strong>,</strong> <strong>-</strong>4.0<strong>,</strong> 0.0<strong>},</strong>
	<strong>{</strong>4.0<strong>,</strong> 4.0<strong>,</strong> 0.0<strong>}};</strong></p>
<p>void init<strong>(</strong>void<strong>)</strong></p>
<p><strong>{</strong></p>
<p> glClearColor<strong>(</strong>0.0<strong>,</strong> 0.0<strong>,</strong> 0.0<strong>,</strong>
	0.0<strong>);</strong></p>
<p> glShadeModel<strong>(</strong>GL_FLAT<strong>);</strong></p>
<p> glMap1f<strong>(</strong>GL_MAP1_VERTEX_3<strong>,</strong> 0.0<strong>,</strong> 1.0<strong>,</strong>
	3<strong>,</strong> 4<strong>,</strong> <strong>
		&amp;</strong>ctrlpoints<strong>[</strong>0<strong>][</strong>0<strong>]);</strong></p>
<p> glEnable<strong>(</strong>GL_MAP1_VERTEX_3<strong>);</strong></p>
<p><strong>}</strong></p>
<p>void display<strong>(</strong>void<strong>)</strong></p>
<p><strong>{</strong></p>
<p> int i<strong>;</strong></p>
<p> glClear<strong>(</strong>GL_COLOR_BUFFER_BIT<strong>);</strong></p>
<p> glColor3f<strong>(</strong>1.0<strong>,</strong> 1.0<strong>,</strong> 1.0<strong>);</strong></p>
<p> glBegin<strong>(</strong>GL_LINE_STRIP<strong>);</strong></p>
<p><strong>for</strong> <strong>(</strong>i <strong>=</strong> 0<strong>;</strong> i <strong>&lt;=</strong>
	30<strong>;</strong> i<strong>++)</strong></p>
<p> glEvalCoord1f<strong>((</strong>GLfloat<strong>)</strong> i<strong>/</strong>30.0<strong>);</strong></p>
<p> glEnd<strong>();</strong></p>
<p> /* The following code displays the control points as dots. */</p>
<p> glPointSize<strong>(</strong>5.0<strong>);</strong></p>
<p> glColor3f<strong>(</strong>1.0<strong>,</strong> 1.0<strong>,</strong> 0.0<strong>);</strong></p>
<p> glBegin<strong>(</strong>GL_POINTS<strong>);</strong></p>
<p><strong>for</strong> <strong>(</strong>i <strong>=</strong> 0<strong>;</strong> i <strong>&lt;</strong>
	4<strong>;</strong> i<strong>++)</strong></p>
<p> glVertex3fv<strong>(&amp;</strong>ctrlpoints<strong>[</strong>i<strong>][</strong>0<strong>]);</strong></p>
<p> glEnd<strong>();</strong></p>
<p> glFlush<strong>();</strong></p>
<p><strong>}</strong></p>
<p>void reshape<strong>(</strong>int w<strong>,</strong> int h<strong>)</strong></p>
<p><strong>{</strong></p>
<p> glViewport<strong>(</strong>0<strong>,</strong> 0<strong>,</strong> <strong>(</strong>GLsizei<strong>)</strong>
	w<strong>,</strong> <strong>(</strong>GLsizei<strong>)</strong> h<strong>);</strong></p>
<p> glMatrixMode<strong>(</strong>GL_PROJECTION<strong>);</strong></p>
<p> glLoadIdentity<strong>();</strong></p>
<p><strong>if</strong> <strong>(</strong>w <strong>&lt;=</strong> h<strong>)</strong></p>
<p> glOrtho<strong>(-</strong>5.0<strong>,</strong> 5.0<strong>,</strong> <strong>-</strong>5.0<strong>*(</strong>GLfloat<strong>)</strong>h<strong>/(</strong>GLfloat<strong>)</strong>w<strong>,</strong>
</p>
<p> 5.0<strong>*(</strong>GLfloat<strong>)</strong>h<strong>/(</strong>GLfloat<strong>)</strong>w<strong>,</strong>
	<strong>-</strong>5.0<strong>,</strong> 5.0<strong>);</strong></p>
<p><strong>else</strong></p>
<p>
	glOrtho<strong>(-</strong>5.0<strong>*(</strong>GLfloat<strong>)</strong>w<strong>/(</strong>GLfloat<strong>)</strong>h<strong>,</strong>
</p>
<p> 5.0<strong>*(</strong>GLfloat<strong>)</strong>w<strong>/(</strong>GLfloat<strong>)</strong>h<strong>,</strong>
	<strong>-</strong>5.0<strong>,</strong> 5.0<strong>,</strong> <strong>-</strong>5.0<strong>,</strong>
	5.0<strong>);</strong></p>
<p> glMatrixMode<strong>(</strong>GL_MODELVIEW<strong>);</strong></p>
<p> glLoadIdentity<strong>();</strong></p>
<p><strong>}</strong></p>
<p>void keyboard<strong>(</strong>unsigned char key<strong>,</strong> int x<strong>,</strong> int y<strong>)</strong>
</p>
<p><strong>{</strong></p>
<p><strong>switch</strong> <strong>(</strong>key<strong>)</strong> <strong>{</strong></p>
<p><strong>case</strong> 27<strong>:</strong></p>
<p> exit<strong>(</strong>0<strong>);</strong></p>
<p><strong>break;</strong></p>
<p><strong>}</strong></p>
<p><strong>}</strong></p>
<p>int main<strong>(</strong>int argc<strong>,</strong> char<strong>**</strong> argv<strong>)</strong></p>
<p><strong>{</strong></p>
<p> glutInit<strong>(&amp;</strong>argc<strong>,</strong> argv<strong>);</strong></p>
<p> glutInitDisplayMode <strong>(</strong>GLUT_SINGLE <strong>|</strong> GLUT_RGB<strong>);</strong></p>
<p> glutInitWindowSize <strong>(</strong>500<strong>,</strong> 500<strong>);</strong></p>
<p> glutInitWindowPosition <strong>(</strong>100<strong>,</strong> 100<strong>);</strong></p>
<p> glutCreateWindow <strong>(</strong>argv<strong>[</strong>0<strong>]);</strong></p>
<p> init <strong>();</strong></p>
<p> glutDisplayFunc<strong>(</strong>display<strong>);</strong></p>
<p> glutReshapeFunc<strong>(</strong>reshape<strong>);</strong></p>
<p> glutKeyboardFunc <strong>(</strong>keyboard<strong>);</strong></p>
<p> glutMainLoop<strong>();</strong></p>
<p><strong>return</strong> 0<strong>;</strong></p>
<p><strong>}</strong></p>
<p><strong>2. Поверхности Безье</strong></p>
<p>Математически фрагмент поверхности Безье задается уравнением</p>
<p>S(u,v)=</p>
<p>где – представляет собой множество контрольных точек, а функции – те же самые многочлены Бернштейна, что и для одного
	измерения. Значения могут представлять вершины, нормали, цвета или текстурные координаты. </p>
<p>Поверхности Безье формируются в OpenGL примерно по той же методике, что и кривые, только роль функции инициализации
	играет не glMap1*(), а glMap2*(), а для считывания результатов следует обращаться к функции glEvalCoord2*() вместо
	glEvalCoord1*(). В обеих функциях нужно специфицировать данные, относящиеся к двум независимым параметрам u и v.
	Например, функция glMap2f() имеет такой формат вызова:</p>
<p>glMap2f(type, u_min, u_max, u_stride, u_order, v_min, v_max, v_stride, v_order, point_array);</p>
<p>Настройка функции вычисления на работу с бикубической поверхностью Безье, определенной на области (0,1)х(0,1),
	выполняется таким вызовом glMap2f():</p>
<p>glMap2f(GL_MAP_VERTEX_3, 0.0, 1.0, 3, 4, 0.0, 1.0, 12, 4, data);</p>
<p>Для обоих независимых переменных нужно задать порядок полинома (аргументы u_order и v_order) и количество значений
	параметра между сегментами (аргументы u_stride и v_stride), что обеспечивает дополнительную гибкость при
	формировании поверхности. Обратите внимание на то, что значение v_stride для второго параметра равно 12, поскольку в
	массиве опорных точек data данные хранятся по строкам. Поэтому для перехода к следующему элементу этой же строки
	нужно «перешагнуть» три числа в формате float, а для перехода к следующему элементу в этом же столбце нужно
	«перешагнуть» через 3*4=12 чисел в формате float. Способ вызова программы расчета зависит от того, какой результат
	мы хотим получить, – вывести на экран сеть или сформировать многоугольники для последующего раскрашивания. Если
	ставится задача сформировать на экране сеть, то соответствующий фрагмент программы должен выглядеть примерно
	так:</p>
<p> for(j=0; j&lt;100; j++)</p>
<p>{</p>
<p> glBegin(GL_LINE_STRIP);</p>
<p> for(i=0; i&lt;100; i++)</p>
<p> glEvalCoord2f((float)i/100.0, (float)j/100.0);</p>
<p> glEnd();</p>
<p> glBegin(GL_LINE_STRIP);</p>
<p> for(i=0; i&lt;100; i++)</p>
<p> glEvalCoord2f((float)j/100.0, (float)i/100.0);</p>
<p> glEnd();</p>
<p> }</p>
<p>Если же желательно сформировать множество многоугольников, то фрагмент должен выглядеть так:</p>
<p> for(j=0; j&lt;99; j++)</p>
<p> {</p>
<p> glBegin(GL_QUAD_STRIP)</p>
<p> for(i=0; i&lt;=100; i++)</p>
<p> {</p>
<p> glEvalCoord2f( (float)i/100.0, (float)j/100.0);</p>
<p> glEvalCoord2f( (float)(i+1)/100.0, (float)j/100.0);</p>
<p> }</p>
<p> glEnd();</p>
<p> } </p>
<p>Для работы на равномерной сетке следует использовать функции glMapGrid2*() и glEvalMesh2(). Тогда в самое начало
	программы, в ту часть, которая отвечает за инициализацию, нужно включить такой фрагмент:</p>
<p>glMapGrid2f(100, 0.0, 1.0, 100, 0.0, 1.0);</p>
<p>В функции отображения display() нужно вызвать glEvalMesh2():</p>
<p>glEvalMesh2(GL_FILL, 0, 100, 0, 100);</p>
<p>Для работы алгоритмов тонирования (закрашивания) сформированной поверхности при настройке режима учета освещения
	нужно дополнительно вызвать функцию glEnable(), передав ей в качестве аргумента константу GL_AUTO_NORMAL:</p>
<p>glEnable(GL_AUTO_NORMAL);</p>
<p>Это позволит OpenGL автоматически вычислять вектор нормали к каждому участку формируемой поверхности и использовать
	этот вектор при закрашивании участков этой поверхности.</p>
<p>Пример программы аппроксимации с помощью поверхности Безье функции z=sin(x+y):</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>#include &lt;GL/glut.h&gt;</p>
<p>#include &lt;math.h&gt;</p>
<p>#include &lt;stdio.h&gt;</p>
<p>GLfloat ctrlpoints<strong>[</strong>6<strong>][</strong>6<strong>][</strong>3<strong>];</strong></p>
<p>void initlights<strong>(</strong>void<strong>)</strong></p>
<p><strong>{</strong></p>
<p> GLfloat ambient<strong>[]</strong> <strong>=</strong> <strong>{</strong>1.0<strong>,</strong> 1.0<strong>,</strong>
	1.0<strong>,</strong> 1.0<strong>};</strong></p>
<p> GLfloat position<strong>[]</strong> <strong>=</strong> <strong>{</strong>0.0<strong>,</strong> 0.0<strong>,</strong>
	2.0<strong>,</strong> 1.0<strong>};</strong></p>
<p> GLfloat mat_diffuse<strong>[]</strong> <strong>=</strong> <strong>{</strong>1.0<strong>,</strong>
	1.0<strong>,</strong> 1.0<strong>,</strong> 1.0<strong>};</strong></p>
<p> GLfloat mat_specular<strong>[]</strong> <strong>=</strong> <strong>{</strong>1.0<strong>,</strong>
	1.0<strong>,</strong> 1.0<strong>,</strong> 1.0<strong>};</strong></p>
<p> GLfloat mat_shininess<strong>[]</strong> <strong>=</strong> <strong>{</strong>50.0<strong>};</strong></p>
<p> glEnable<strong>(</strong>GL_LIGHTING<strong>);</strong></p>
<p> glEnable<strong>(</strong>GL_LIGHT0<strong>);</strong></p>
<p> glLightfv<strong>(</strong>GL_LIGHT0<strong>,</strong> GL_AMBIENT<strong>,</strong> ambient<strong>);</strong></p>
<p> glLightfv<strong>(</strong>GL_LIGHT0<strong>,</strong> GL_POSITION<strong>,</strong> position<strong>);</strong></p>
<p> glMaterialfv<strong>(</strong>GL_FRONT<strong>,</strong> GL_DIFFUSE<strong>,</strong> mat_diffuse<strong>);</strong>
</p>
<p> glMaterialfv<strong>(</strong>GL_FRONT<strong>,</strong> GL_SPECULAR<strong>,</strong>
	mat_specular<strong>);</strong></p>
<p> glMaterialfv<strong>(</strong>GL_FRONT<strong>,</strong> GL_SHININESS<strong>,</strong>
	mat_shininess<strong>);</strong></p>
<p><strong>}</strong></p>
<p>void display<strong>(</strong>void<strong>)</strong></p>
<p><strong>{</strong></p>
<p> glClear<strong>(</strong>GL_COLOR_BUFFER_BIT <strong>|</strong> GL_DEPTH_BUFFER_BIT<strong>);</strong></p>
<p> glPushMatrix<strong>();</strong></p>
<p> glRotatef<strong>(</strong>85.0<strong>,</strong> 1.0<strong>,</strong> 0.0<strong>,</strong> 0.0<strong>);</strong>
</p>
<p> glEvalMesh2<strong>(</strong>GL_FILL<strong>,</strong> 0<strong>,</strong> 10<strong>,</strong> 0<strong>,</strong>
	10<strong>);</strong></p>
<p> glPopMatrix<strong>();</strong></p>
<p> glFlush<strong>();</strong></p>
<p><strong>}</strong></p>
<p>void init<strong>(</strong>void<strong>)</strong></p>
<p><strong>{</strong></p>
<p> float x<strong>,</strong>y<strong>;</strong></p>
<p> int i<strong>,</strong>j<strong>;</strong></p>
<p><strong>for</strong> <strong>(</strong>i<strong>=</strong>0<strong>;</strong> i<strong>
	&lt;</strong>6<strong>;</strong>i<strong>++)</strong></p>
<p><strong>{</strong></p>
<p> x<strong>=</strong>3.1415<strong>/</strong>5.0<strong>*(</strong>float<strong>)</strong>i<strong>;</strong></p>
<p><strong>for(</strong>j<strong>=</strong>0<strong>;</strong> j<strong>&lt;</strong>6<strong>;</strong>
	j<strong>++)</strong></p>
<p><strong>{</strong></p>
<p> y<strong>=</strong>3.1415<strong>/</strong>5.0<strong>*(</strong>float<strong>)</strong>j<strong>;</strong></p>
<p> ctrlpoints<strong>[</strong>i<strong>][</strong>j<strong>][</strong>0<strong>]=</strong>x<strong>;</strong></p>
<p> ctrlpoints<strong>[</strong>i<strong>][</strong>j<strong>][</strong>1<strong>]=</strong>y<strong>;</strong></p>
<p>
	ctrlpoints<strong>[</strong>i<strong>][</strong>j<strong>][</strong>2<strong>]=</strong>sin<strong>(</strong>x<strong>+</strong>y<strong>);</strong>
</p>
<p><strong>}</strong></p>
<p><strong>}</strong></p>
<p> glClearColor<strong>(</strong>0.0<strong>,</strong> 0.0<strong>,</strong> 0.0<strong>,</strong>
	0.0<strong>);</strong></p>
<p> glEnable<strong>(</strong>GL_DEPTH_TEST<strong>);</strong></p>
<p> glMap2f<strong>(</strong>GL_MAP2_VERTEX_3<strong>,</strong> 0<strong>,</strong> 4<strong>,</strong>
	3<strong>,</strong> 4<strong>,</strong></p>
<p> 0<strong>,</strong> 4<strong>,</strong> 18<strong>,</strong> 4<strong>,</strong> <strong>
	&amp;</strong>ctrlpoints<strong>[</strong>0<strong>][</strong>0<strong>][</strong>0<strong>]);</strong></p>
<p> glEnable<strong>(</strong>GL_MAP2_VERTEX_3<strong>);</strong></p>
<p> glEnable<strong>(</strong>GL_AUTO_NORMAL<strong>);</strong></p>
<p> glMapGrid2f<strong>(</strong>10<strong>,</strong> 0.0<strong>,</strong> 4.0<strong>,</strong> 10<strong>,</strong>
	0.0<strong>,</strong> 4.0<strong>);</strong></p>
<p> initlights<strong>();</strong> /* for lighted version only */</p>
<p><strong>}</strong></p>
<p>void reshape<strong>(</strong>int w<strong>,</strong> int h<strong>)</strong></p>
<p><strong>{</strong></p>
<p> glViewport<strong>(</strong>0<strong>,</strong> 0<strong>,</strong> 400<strong>,</strong> 400<strong>);</strong></p>
<p> glMatrixMode<strong>(</strong>GL_PROJECTION<strong>);</strong></p>
<p> glLoadIdentity<strong>();</strong></p>
<p> glOrtho<strong>(-</strong>1.0<strong>,</strong>2.0<strong>,</strong> <strong>-</strong>1.0<strong>,</strong>
	2.0<strong>,</strong> <strong>-</strong>2.0<strong>,</strong> 2.0<strong>);</strong></p>
<p> glMatrixMode<strong>(</strong>GL_MODELVIEW<strong>);</strong></p>
<p> glLoadIdentity<strong>();</strong></p>
<p><strong>}</strong></p>
<p>void keyboard<strong>(</strong>unsigned char key<strong>,</strong> int x<strong>,</strong> int y<strong>)</strong>
</p>
<p><strong>{</strong></p>
<p><strong>switch</strong> <strong>(</strong>key<strong>)</strong> <strong>{</strong></p>
<p><strong>case</strong> 27<strong>:</strong></p>
<p> exit<strong>(</strong>0<strong>);</strong></p>
<p><strong>break;</strong></p>
<p><strong>}</strong></p>
<p><strong>}</strong></p>
<p>int main<strong>(</strong>int argc<strong>,</strong> char <strong>**</strong>argv<strong>)</strong></p>
<p><strong>{</strong></p>
<p> glutInit<strong>(&amp;</strong>argc<strong>,</strong> argv<strong>);</strong></p>
<p> glutInitDisplayMode<strong>(</strong>GLUT_SINGLE <strong>|</strong> GLUT_RGB <strong>|</strong>
	GLUT_DEPTH<strong>);</strong></p>
<p> glutInitWindowSize <strong>(</strong>500<strong>,</strong> 500<strong>);</strong></p>
<p> glutInitWindowPosition <strong>(</strong>100<strong>,</strong> 100<strong>);</strong></p>
<p> glutCreateWindow<strong>(</strong>argv<strong>[</strong>0<strong>]);</strong></p>
<p> init<strong>();</strong></p>
<p> glutReshapeFunc<strong>(</strong>reshape<strong>);</strong></p>
<p> glutDisplayFunc<strong>(</strong>display<strong>);</strong></p>
<p> glutKeyboardFunc<strong>(</strong>keyboard<strong>);</strong></p>
<p> glutMainLoop<strong>();</strong></p>
<p><strong>return</strong> 0<strong>;</strong></p>
<p><strong>}</strong></p>
<p><strong>Порядок выполнения лабораторной работы</strong></p>
<ol>
	<li>Отладить и запустить программу рисования кривой Безье, приведенную в тексте лабораторной работы.</li>
	<li>Изобразить кривую Безье на основе данных, заданных преподавателем.</li>
	<li>Отладить и запустить программу рисования поверхности Безье, приведенную в тексте лабораторной работы.</li>
	<li>Изобразить поверхность Безье на основе данных, заданных преподавателем.</li>
</ol>
<p><strong>Контрольные вопросы</strong></p>
<ol>
	<li>Математические основы использования бета-сплайнов в компьютерной графике.</li>
	<li>Интерполяция и аппроксимация с использованием сплайнов.</li>
	<li>Кривые и поверхности Безье. Математические основы.</li>
</ol>
<p>Построение кривых и поверхностей Безье средствами OpenGL.</p>
<h1><a id="_Toc454872990"></a>Лабораторная работа №8: “Модульное программирование”</h1>
<p><strong>Порядок выполнения работы </strong></p>
<p>1. Ознакомьтесь с теоретическими основами в настоящих указаниях и конспектах лекций. </p>
<p>2. Получите задание у преподавателя. </p>
<p>3. Сделайте скриншоты (кнопка клавиатуры PrtSc) выполненных заданий в текстовом (Word) файле <em>Фамилия_ЛР</em></p>
<p>4. Составьте отчет по лабораторной работе. </p>
<p>5. Отчитайте работу преподавателю.</p>
<p><strong>Цель работы</strong></p>
<p>Изучение механизма выбора OpenGL – средства, реализующего функции логического устройства типа «селектор» </p>
<p><strong>1. Выбор и обратная связь</strong></p>
<p>Некоторые графические прикладные программы просто рисуют статическое изображение двух и трехмерных объектов. Другие
	приложения позволяют пользователю идентифицировать объект на экране, а затем перемещать, изменять, удалять или еще
	как-то управлять этими объектами. Графическая система OpenGL предназначена для поддержки таких интерактивных
	приложений. Для помощи в решении проблемы выбора объекта сцены для перемещения, вращения и других преобразований
	OpenGL использует механизм выбора, который автоматически сообщает, какие объекты нарисованы внутри указанной области
	окна.</p>
<p>Обычно OpenGL работает в режиме выбора. Другой режим, который может использоваться для выбора объектов – обратная
	связь. В режиме обратной связи вы используете ваши графические аппаратные средства и OpenGL для выполнения обычных
	вычислений сцены, однако вместо использования вычисленных результатов для рисования изображения на экране OpenGL
	возвращает вам информацию о рисунке.</p>
<p>И в режиме выбора и в режиме обратной связи информация о рисунке возвращается приложению вместо того, чтобы
	направляться в буфер кадра, как это делается в режиме исполнения. Таким образом, экран остается неизменным пока
	OpenGL находится в режиме выбора или обратной связи. В лабораторной работе рассматривается только один из указанных
	механизмов создания интерактивных приложений – режим выбора.</p>
<p><strong>2. Выбор</strong></p>
<p>Как правило, когда Вы планируете использование механизма выбора OpenGL, Вы сначала рисуете вашу сцену в буфер кадра,
	а затем включаете режим выбора и перерисовываете сцену. Когда вы находитесь в режиме выбора, содержимое буфера кадра
	не изменяется, пока вы не выйдете из этого режима. Когда вы выходите из режима выбора OpenGL, возвращает список
	примитивов, которые попадают в видимый объем. Каждый пересекающий (попадающий полностью или частично в видимый
	объем) примитив, вызывает ответ выбора (selection hit). Список примитивов возвращается в виде ответных записей (hit
	records), представляющих собой массив целочисленных имен и связанных данных, соответствующих текущему содержанию
	стека имен. Вы создаете стек имен (stack), загружая в него имена, когда вы используете команды рисования примитивов,
	находясь в режиме выбора. Таким образом, когда возвращен список имен, вы можете его использовать для определения
	примитивов, которые могли бы быть выбраны пользователем на экране.</p>
<p>В дополнение к этому механизму выбора OpenGL представляет сервисную программу, предназначенную для упрощения выбора в
	некоторых случаях, ограничивая рисование маленькой областью окна просмотра. Как правило, эта подпрограмма
	используется, чтобы определить, какие объекты рисуются в близи курсора.</p>
<p><strong>3. Использование механизма выбора <br/>в интерактивной графической программе</strong></p>
<p>Чтобы использовать механизм выбора, вы должны выполнить следующие шаги:</p>
<p>1. Определить с помощью команды glSelectBuffer массив, который будет использоваться для возвращаемых ответных
	записей.</p>
<ol>
	<li>Войти в режим выбора, задав константу GL_SELECT в команде glRenderMode.</li>
	<li>Инициализировать стек имен, используя команды glInitNames( ) и glPushName().</li>
	<li>Определить видимый объем, который вы хотите использовать для выбора. Обычно он отличается от видимого объема, в
		котором первоначально рисуется сцена. Поэтому, вы вероятно захотите сохранить, а затем восстановить текущее
		состояние преобразования с помощью команд glPushMatrix( ) и glPopMatrix( ).
	</li>
	<li>Поочередно вызывать команды рисования примитивов и команды управления стеком имен, чтобы каждому примитиву,
		представляющему интерес, было назначено соответствующее имя.
	</li>
	<li>Выйти из режима выбора и обработать возвращенные данные выбора (ответные записи).</li>
</ol>
<p>Пример программы, использующей механизм выбора в интерактивной графической программе:</p>
<p>#include &lt;GL/glut.h&gt;</p>
<p>#include &lt;stdlib.h&gt;</p>
<p>#include &lt;stdio.h&gt;</p>
<p>void drawTriangle <strong>(</strong>GLfloat x1<strong>,</strong> GLfloat y1<strong>,</strong> GLfloat
	x2<strong>,</strong></p>
<p> GLfloat y2<strong>,</strong> GLfloat x3<strong>,</strong> GLfloat y3<strong>,</strong> GLfloat z<strong>)</strong>
</p>
<p><strong>{</strong></p>
<p> glBegin <strong>(</strong>GL_TRIANGLES<strong>);</strong></p>
<p> glVertex3f <strong>(</strong>x1<strong>,</strong> y1<strong>,</strong> z<strong>);</strong></p>
<p> glVertex3f <strong>(</strong>x2<strong>,</strong> y2<strong>,</strong> z<strong>);</strong></p>
<p> glVertex3f <strong>(</strong>x3<strong>,</strong> y3<strong>,</strong> z<strong>);</strong></p>
<p> glEnd <strong>();</strong></p>
<p><strong>}</strong></p>
<p><strong>{</strong></p>
<p> glColor3f <strong>(</strong>1.0<strong>,</strong> 1.0<strong>,</strong> 1.0<strong>);</strong></p>
<p> glBegin <strong>(</strong>GL_LINE_LOOP<strong>);</strong></p>
<p> glVertex3f <strong>(</strong>x1<strong>,</strong> y1<strong>,</strong> <strong>-</strong>z1<strong>);</strong></p>
<p> glVertex3f <strong>(</strong>x2<strong>,</strong> y1<strong>,</strong> <strong>-</strong>z1<strong>);</strong></p>
<p> glVertex3f <strong>(</strong>x2<strong>,</strong> y2<strong>,</strong> <strong>-</strong>z1<strong>);</strong></p>
<p> glVertex3f <strong>(</strong>x1<strong>,</strong> y2<strong>,</strong> <strong>-</strong>z1<strong>);</strong></p>
<p> glEnd <strong>();</strong></p>
<p> glBegin <strong>(</strong>GL_LINE_LOOP<strong>);</strong></p>
<p> glVertex3f <strong>(</strong>x1<strong>,</strong> y1<strong>,</strong> <strong>-</strong>z2<strong>);</strong></p>
<p> glVertex3f <strong>(</strong>x2<strong>,</strong> y1<strong>,</strong> <strong>-</strong>z2<strong>);</strong></p>
<p> glVertex3f <strong>(</strong>x2<strong>,</strong> y2<strong>,</strong> <strong>-</strong>z2<strong>);</strong></p>
<p> glVertex3f <strong>(</strong>x1<strong>,</strong> y2<strong>,</strong> <strong>-</strong>z2<strong>);</strong></p>
<p> glEnd <strong>();</strong></p>
<p> glBegin <strong>(</strong>GL_LINES<strong>);</strong> /* 4 lines */</p>
<p> glVertex3f <strong>(</strong>x1<strong>,</strong> y1<strong>,</strong> <strong>-</strong>z1<strong>);</strong></p>
<p> glVertex3f <strong>(</strong>x1<strong>,</strong> y1<strong>,</strong> <strong>-</strong>z2<strong>);</strong></p>
<p> glVertex3f <strong>(</strong>x1<strong>,</strong> y2<strong>,</strong> <strong>-</strong>z1<strong>);</strong></p>
<p> glVertex3f <strong>(</strong>x1<strong>,</strong> y2<strong>,</strong> <strong>-</strong>z2<strong>);</strong></p>
<p> glVertex3f <strong>(</strong>x2<strong>,</strong> y1<strong>,</strong> <strong>-</strong>z1<strong>);</strong></p>
<p> glVertex3f <strong>(</strong>x2<strong>,</strong> y1<strong>,</strong> <strong>-</strong>z2<strong>);</strong></p>
<p> glVertex3f <strong>(</strong>x2<strong>,</strong> y2<strong>,</strong> <strong>-</strong>z1<strong>);</strong></p>
<p> glVertex3f <strong>(</strong>x2<strong>,</strong> y2<strong>,</strong> <strong>-</strong>z2<strong>);</strong></p>
<p> glEnd <strong>();</strong></p>
<p><strong>}</strong></p>
<p>void drawScene <strong>(</strong>void<strong>)</strong></p>
<p><strong>{</strong></p>
<p> glMatrixMode <strong>(</strong>GL_PROJECTION<strong>);</strong></p>
<p> glLoadIdentity <strong>();</strong></p>
<p> gluPerspective <strong>(</strong>40.0<strong>,</strong> 4.0<strong>/</strong>3.0<strong>,</strong>
	1.0<strong>,</strong> 100.0<strong>);</strong></p>
<p> glMatrixMode <strong>(</strong>GL_MODELVIEW<strong>);</strong></p>
<p> glLoadIdentity <strong>();</strong></p>
<p> gluLookAt <strong>(</strong>7.5<strong>,</strong> 7.5<strong>,</strong> 12.5<strong>,</strong> 2.5<strong>,</strong>
	2.5<strong>,</strong> <strong>-</strong>5.0<strong>,</strong> 0.0<strong>,</strong> 1.0<strong>,</strong>
	0.0<strong>);</strong></p>
<p> glColor3f <strong>(</strong>0.0<strong>,</strong> 1.0<strong>,</strong> 0.0<strong>);</strong> /* green triangle */
</p>
<p> drawTriangle <strong>(</strong>2.0<strong>,</strong> 2.0<strong>,</strong> 3.0<strong>,</strong>
	2.0<strong>,</strong> 2.5<strong>,</strong> 3.0<strong>,</strong> <strong>-</strong>5.0<strong>);</strong></p>
<p> glColor3f <strong>(</strong>1.0<strong>,</strong> 0.0<strong>,</strong> 0.0<strong>);</strong> /* red triangle */
</p>
<p> drawTriangle <strong>(</strong>2.0<strong>,</strong> 7.0<strong>,</strong> 3.0<strong>,</strong>
	7.0<strong>,</strong> 2.5<strong>,</strong> 8.0<strong>,</strong> <strong>-</strong>5.0<strong>);</strong></p>
<p> glColor3f <strong>(</strong>1.0<strong>,</strong> 1.0<strong>,</strong> 0.0<strong>);</strong> /* yellow triangles
	*/</p>
<p> drawTriangle <strong>(</strong>2.0<strong>,</strong> 2.0<strong>,</strong> 3.0<strong>,</strong>
	2.0<strong>,</strong> 2.5<strong>,</strong> 3.0<strong>,</strong> 0.0<strong>);</strong></p>
<p> drawTriangle <strong>(</strong>2.0<strong>,</strong> 2.0<strong>,</strong> 3.0<strong>,</strong>
	2.0<strong>,</strong> 2.5<strong>,</strong> 3.0<strong>,</strong> <strong>-</strong>10.0<strong>);</strong></p>
<p> drawViewVolume <strong>(</strong>0.0<strong>,</strong> 5.0<strong>,</strong> 0.0<strong>,</strong>
	5.0<strong>,</strong> 0.0<strong>,</strong> 10.0<strong>);</strong></p>
<p><strong>}</strong></p>
<p>void processHits <strong>(</strong>GLint hits<strong>,</strong> GLuint buffer<strong>[])</strong></p>
<p><strong>{</strong></p>
<p> unsigned int i<strong>,</strong> j<strong>;</strong></p>
<p> GLuint names<strong>,</strong> <strong>*</strong>ptr<strong>;</strong></p>
<p> printf <strong>(</strong>«hits <strong>=</strong> <strong>%</strong>d\n»<strong>,</strong> hits<strong>);</strong>
</p>
<p> ptr <strong>=</strong> <strong>(</strong>GLuint <strong>*)</strong> buffer<strong>;</strong></p>
<p><strong>for</strong> <strong>(</strong>i <strong>=</strong> 0<strong>;</strong> i <strong>&lt;</strong>
	hits<strong>;</strong> i<strong>++)</strong> <strong>{</strong> /* for each hit */</p>
<p> names <strong>=</strong> <strong>*</strong>ptr<strong>;</strong></p>
<p> printf <strong>(</strong>» number of names <strong>for</strong> hit <strong>=</strong>
	<strong>%</strong>d\n»<strong>,</strong> names<strong>);</strong> ptr<strong>++;</strong></p>
<p> printf<strong>(</strong>» z1 is <strong>%</strong>g<strong>;</strong>&quot;, (float) *ptr/0x7fffffff); ptr++;</p>
<p> printf<strong>(</strong>» z2 is <strong>%</strong>g\n»<strong>,</strong> <strong>(</strong>float<strong>)</strong>
	<strong>*</strong>ptr<strong>/</strong>0x7fffffff<strong>);</strong> ptr<strong>++;</strong></p>
<p> printf <strong>(</strong>» the name is «<strong>);</strong></p>
<p><strong>for</strong> <strong>(</strong>j <strong>=</strong> 0<strong>;</strong> j <strong>&lt;</strong> names<strong>;</strong>
	j<strong>++)</strong> <strong>{</strong> /* for each name */</p>
<p> printf <strong>(</strong>&quot;%d «, *ptr); ptr++;</p>
<p><strong>}</strong></p>
<p> printf <strong>(</strong>&quot;\n»);</p>
<p><strong>}</strong></p>
<p><strong>}</strong></p>
<p>#define BUFSIZE 512</p>
<p>void selectObjects<strong>(</strong>void<strong>)</strong></p>
<p><strong>{</strong></p>
<p> GLuint selectBuf<strong>[</strong>BUFSIZE<strong>];</strong></p>
<p> GLint hits<strong>;</strong></p>
<p> glSelectBuffer <strong>(</strong>BUFSIZE<strong>,</strong> selectBuf<strong>);</strong></p>
<p><strong>(</strong>void<strong>)</strong> glRenderMode <strong>(</strong>GL_SELECT<strong>);</strong></p>
<p> glInitNames<strong>();</strong></p>
<p> glPushName<strong>(</strong>0<strong>);</strong></p>
<p> glPushMatrix <strong>();</strong></p>
<p> glMatrixMode <strong>(</strong>GL_PROJECTION<strong>);</strong></p>
<p> glLoadIdentity <strong>();</strong></p>
<p> glOrtho <strong>(</strong>0.0<strong>,</strong> 5.0<strong>,</strong> 0.0<strong>,</strong> 5.0<strong>,</strong>
	0.0<strong>,</strong> 10.0<strong>);</strong></p>
<p> glMatrixMode <strong>(</strong>GL_MODELVIEW<strong>);</strong></p>
<p> glLoadIdentity <strong>();</strong></p>
<p> glLoadName<strong>(</strong>1<strong>);</strong></p>
<p> drawTriangle <strong>(</strong>2.0<strong>,</strong> 2.0<strong>,</strong> 3.0<strong>,</strong>
	2.0<strong>,</strong> 2.5<strong>,</strong> 3.0<strong>,</strong> <strong>-</strong>5.0<strong>);</strong></p>
<p> glLoadName<strong>(</strong>2<strong>);</strong></p>
<p> drawTriangle <strong>(</strong>2.0<strong>,</strong> 7.0<strong>,</strong> 3.0<strong>,</strong>
	7.0<strong>,</strong> 2.5<strong>,</strong> 8.0<strong>,</strong> <strong>-</strong>5.0<strong>);</strong></p>
<p> glLoadName<strong>(</strong>3<strong>);</strong></p>
<p> drawTriangle <strong>(</strong>2.0<strong>,</strong> 2.0<strong>,</strong> 3.0<strong>,</strong>
	2.0<strong>,</strong> 2.5<strong>,</strong> 3.0<strong>,</strong> 0.0<strong>);</strong></p>
<p> drawTriangle <strong>(</strong>2.0<strong>,</strong> 2.0<strong>,</strong> 3.0<strong>,</strong>
	2.0<strong>,</strong> 2.5<strong>,</strong> 3.0<strong>,</strong> <strong>-</strong>10.0<strong>);</strong></p>
<p> glPopMatrix <strong>();</strong></p>
<p> glFlush <strong>();</strong></p>
<p> hits <strong>=</strong> glRenderMode <strong>(</strong>GL_RENDER<strong>);</strong></p>
<p> processHits <strong>(</strong>hits<strong>,</strong> selectBuf<strong>);</strong></p>
<p><strong>}</strong></p>
<p>void init <strong>(</strong>void<strong>)</strong></p>
<p><strong>{</strong></p>
<p> glEnable<strong>(</strong>GL_DEPTH_TEST<strong>);</strong></p>
<p> glShadeModel<strong>(</strong>GL_FLAT<strong>);</strong></p>
<p><strong>}</strong></p>
<p>void display<strong>(</strong>void<strong>)</strong></p>
<p><strong>{</strong></p>
<p> glClearColor <strong>(</strong>0.0<strong>,</strong> 0.0<strong>,</strong> 0.0<strong>,</strong>
	0.0<strong>);</strong></p>
<p> glClear<strong>(</strong>GL_COLOR_BUFFER_BIT <strong>|</strong> GL_DEPTH_BUFFER_BIT<strong>);</strong></p>
<p> drawScene <strong>();</strong></p>
<p> selectObjects <strong>();</strong></p>
<p> glFlush<strong>();</strong></p>
<p><strong>}</strong></p>
<p>void keyboard<strong>(</strong>unsigned char key<strong>,</strong> int x<strong>,</strong> int y<strong>)</strong>
</p>
<p><strong>{</strong></p>
<p><strong>switch</strong> <strong>(</strong>key<strong>)</strong> <strong>{</strong></p>
<p><strong>case</strong> 27<strong>:</strong></p>
<p> exit<strong>(</strong>0<strong>);</strong></p>
<p><strong>break;</strong></p>
<p><strong>}</strong></p>
<p><strong>}</strong></p>
<p>/* Main Loop */</p>
<p>int main<strong>(</strong>int argc<strong>,</strong> char<strong>**</strong> argv<strong>)</strong></p>
<p><strong>{</strong></p>
<p> glutInit<strong>(&amp;</strong>argc<strong>,</strong> argv<strong>);</strong></p>
<p> glutInitDisplayMode <strong>(</strong>GLUT_SINGLE <strong>|</strong> GLUT_RGB <strong>|</strong> GLUT_DEPTH<strong>);</strong>
</p>
<p> glutInitWindowSize <strong>(</strong>200<strong>,</strong> 200<strong>);</strong></p>
<p> glutInitWindowPosition <strong>(</strong>100<strong>,</strong> 100<strong>);</strong></p>
<p> glutCreateWindow <strong>(</strong>argv<strong>[</strong>0<strong>]);</strong></p>
<p> init<strong>();</strong></p>
<p> glutDisplayFunc<strong>(</strong>display<strong>);</strong></p>
<p> glutKeyboardFunc<strong>(</strong>keyboard<strong>);</strong></p>
<p> glutMainLoop<strong>();</strong></p>
<p><strong>return</strong> 0<strong>;</strong></p>
<p><strong>}</strong></p>
<p><strong>Порядок выполнения лабораторной работы</strong></p>
<ol>
	<li>Отладить и запустить программу, приведенную в тексте лабораторной работы.</li>
	<li>Составить интерактивную графическую программу, использующую механизм выбора по заданию преподавателя.</li>
</ol>
<p><strong>Контрольные вопросы</strong></p>
<ol>
	<li>Программистская модель интерактивной машинной графики.</li>
	<li>Классы логических устройств ввода. Селектор.</li>
	<li>Реализация логического устройства ввода типа «селектор» средствами OpenGL.</li>
</ol>
<h1><a id="_Toc454872991"></a>Лабораторная работа №9, 10, 11, 12, 13, 14: “Структурное программирование”</h1>
<p><strong>Цель работы:</strong> Получить практические навыки по установке и управлению CMS Wordpress</p>
<p><strong>CMS Wordpress</strong></p>
<p><strong>WordPress</strong> — CMS с открытым исходным кодом, распространяемая под GNU GPL. Написан на PHP, в качестве
	базы данных использует MySQL. Сфера применения — от блогов до достаточно сложных новостных ресурсов и даже
	интернет-магазинов. Встроенная система «тем» и «плагинов» вместе с удачной архитектурой позволяет конструировать
	практически любые проекты.</p>
<p>На сегодняшний день WordPress — самая популярная система для ведения блогов. </p>
<ul>
	<li>возможность публикации с помощью сторонних программ и сервисов;</li>
	<li>моментальная публикация;</li>
	<li>простота установки, настройки;</li>
	<li>поддержка веб-стандартов (XHTML, CSS);</li>
	<li>поддержка RSS, Atom, trackback, pingback;</li>
	<li>подключаемые модули (плагины) с уникальной простой системой их взаимодействия с кодом;</li>
	<li>поддержка так называемых «тем», позволяющих легко менять как внешний вид, так и способы вывода данных;</li>
	<li>«темы» реализованы как наборы файлов-шаблонов на PHP, что положительно сказывается на скорости и гибкости;</li>
	<li>громадные библиотеки «тем» и «плагинов»;</li>
	<li>заложенный потенциал архитектуры позволяет легко реализовывать сложные решения;</li>
	<li>наличие ЧПУ (человеко-понятный URL);</li>
	<li>наличие русских переводов.</li>
</ul>
<p><strong>Борьба со спамом</strong></p>
<p>Стандартно в WordPress входит плагин Akismet, который достаточно эффективно борется с этим злом. Кроме этого можно
	создать черный список и фильтры из слов. С их помощью можно просто заблокировать любой комментарий, который содержит
	запрещенное слово или отправить его на модерацию. Наибольшую же эффективность в борьбе со спамом можно добиться с
	помощью т.н. капчи — картинки с набором символов. В этом случае ставится полный заслон от автоматических
	спам-роботов. Установка большинства плагинов антиспама очень проста, зачатую достаточно только его активировать в
	админ-панели (например, популярная SpamKarma). С помощью специального плагина есть возможность модерировать
	спам-комментарии. Причем доступны как обычные комментарии, так и пинги и трекбаки. В целом же плагинов для антиспама
	множество (я насчитал больше семидесяти).</p>
<p><strong>Интеграция с форумом</strong></p>
<p>Для WordPress'а разработан и рекомендуется форум BBPress (есть и руссификация), который полностью интегрируется в
	блог. Правда, возможности у этого форум более чем скромные. На официальном сайте WordPress'а используется именно
	этот форум. Также существуют плагины, которые позволяют частично интегрировать некоторые популярные форумы в блог.
	Правда для этого требуются хорошие знания программирования, и при этом, все равно стопроцентной интеграции не
	получится — все-таки это разные системы.</p>
<p><strong>Шаблоны оформления</strong></p>
<p>Для WordPress'а созданы тысячи шаблонов и многие из них выполнены на очень хорошем дизайнерском уровне. Устройство
	WordPress таково, что под него несложно переделать, скажем, html-шаблон. В шаблонах испольуются обычные PHP-функции,
	поэтому никаких сложностей с изучением т.н. языков шаблонов нет. По созданию шаблонов существует довольно много
	статей, даже есть он-лайн генератор. Готовые шаблоны достаточно загрузить в отдельный каталог и после этого в
	админ-панели выбрать понравившийся. Существует также возможность переключать шаблоны и посетителями.</p>
<p><strong>Расширенная функциональность (плагины)</strong></p>
<p>WordPress можно расширить за счет плагинов — это различные php-скрипты, которые автоматически подключаются к
	основному «ядру». Таким образом можно не просто добавить нужную функциональность, но и изменить уже существующую.
	Создать плагин не очень сложно, все зависит от уровня знания PHP. Подключение к WordPress'у совсем просто: плагин
	копируется в специальный каталог и активируется в админ-панели. Некоторые плагины можно настраивать, некоторые нужно
	прописывать в шаблоне, а некоторые работают полностью автоматически. </p>
<p>Плагинов для WordPress написано несколько тысяч (только на одном wp-plugins.net — 2568, но думаю, что целом цифру
	можно удвоить), поэтому можно найти плагин практически под любые нужды. Исключение составляют плагины, которые
	требуют значительной переделки шаблона. С ними обычно приходится повозиться. </p>
<p><strong>Поддержка авторов (один блог) и многопользовательские блоги</strong></p>
<p>WordPress достаточно хорошо зарекомендовал себя как многоавторский блог. Во всяком случае стандартные возможности у
	него не вызывают опасений. А вот для того, чтобы расширить их, потребуется использование дополнительных плагинов.
	Например это касается добавления произвольных полей в профиль автора, аватарка, фото и т.п. Парадокс в том, что в
	WordPress'е уже заложен практически весь потенциал для этого, но так и не доведен до конца. </p>
<p>Для управления авторами используется система ролей. С помощью специального плагина можно легко (визуально)
	отредактировать любую роль или разрешить/запретить выполнять какие-либо действия отдельному автору. </p>
<p>Для многопользовательских блогов существует отдельная версия: WordPress Multi User. Требования и возможности у неё
	практически такие же как и у обычного WordPress'а, хотя есть некоторые отличия. На WordPressMU работает один из
	крупнейших блог-сервисов WordPress.com, на котором зарегистрировано почти 1,3 миллиона блогов. </p>
<p><strong>Комментирование</strong></p>
<p>Для любой записи можно разрешить или запретить комментирование. Отдельно можно разрешить прием пингов/трекбаков, а
	также автоматический пинг по адресам, указаным в тексте записи. При помощи отдельных плагинов можно сделать
	древовидные комментарии, а также разбить отображение комментариев по страницам. Можно добавить аватарки или favicon.
	Текстовый редактор комментария можно снабдить кнопками форматирования и смайлами. Есть также плагин (работает на
	AJAX), который позволяет в течение некоторого времени редактировать посетителю свой комментарий.</p>
<p><strong>Экспорт/импорт данных</strong></p>
<p>WordPress позволяет экспортировать записи и комментарии блога в XML-файл. Можно экспортировать записи отдельного
	автора. Для импорта записей в WordPress можно воспользоваться 9 способами. Это основные блоговские «движки»
	(например: ЖЖ, Blogger, Textpattern), а также в RSS и свой XML-формат.</p>
<p><strong>Установка Wordpress</strong></p>
<p> Для установки Wordpress на локальный компьютер необходимо установить пакет Denwer для выполнения PHP-скриптов и
	работой с базой данных MySQL.</p>
<h1><a id="_Toc454872992"></a>Лабораторная работа №15, 16, 17, 18, 19: “Объектно-ориентированное программирование”</h1>
<p>Цель: научимся соединяться с базой данных, вытаскивать из нее информацию, подключать блоки к сайту. </p>
<p>В итоге получится простой сайт, написанный на php, который состоит из нескольких страниц (главная, основная
	терминология, история и т.д.). Каждая страница имеет фиксированный дизайн, таблица фиксированной ширины, разбитая на
	2 части, под шапку и под контент. Контент также разбит на 2 части, часть для навигации и часть для самого текста.
	Кроме видимой части, существует невидимая часть, которая занимается управлением сайтом. В ней можно редактировать,
	добавлять и удалять статьи (рис. 1). </p>
<p></p>
<p><strong> </strong></p>
<p><strong>Рассмотрим структуру будущего сайта: </strong></p>
<p>Общая часть будет иметь несколько php файлов и две папки (img – папка с изображениями, blocks – хранит в себе блоки).
	Файл index.php будет отвечать за главную страницу. </p>
<p>Администраторская часть будет состоять из нескольких файлов, отвечающих за редактирование и т.д. </p>
<p>Также нам понадобится база данных для всего сайта, она будет хранить тексты для каждой страницы и т.д. </p>
<p></p>
<p><strong>2 Определяем сайт и создаем каркас </strong></p>
<p>Создадим папки для сайта, главный файл и подключим таблицу стилей. </p>
<p>Во первых необходимо убедится что у вас установлен сервер. </p>
<p> Затем создаем папку kssite, размещенную по адресу </p>
<p>C:\WebServers\home\localhost\www\kssite. После создания папки переходим в программу Adobe Dreamweaver, на вкладке
	файлы выбираем управление webсайтами (рис. 2). </p>
<p><img src="4.jpeg"/></p>
<p></p>
<p>Рисунок 2 – Управление сайтами </p>
<p></p>
<p></p>
<p>В появившемся окне выбираем папку, которую создали и нажимаем ok </p>
<p>(рис. 3). </p>
<p></p>
<p></p>
<p>Рисунок 3 – Определение сайта </p>
<p></p>
<p>Выбираем готово (рис. 4). </p>
<p><img src="5.jpeg"/></p>
<p>Рисунок 4 – Управление сайтами </p>
<p>Теперь сайт загружен (рис. 5)! </p>
<p><img src="6.jpeg"/></p>
<p>Рисунок 5 – Загруженный сайт </p>
<p>Создадим первый PHP файл, для этого в появившемся окне выберем PHP файл. Сохраним его как index.php (рис. 6). </p>
<p><img src="7.jpeg"/></p>
<p>Рисунок 6 – Создание PHP файла </p>
<p> Сравните, чтобы ваш код и кодировка были такими же (рис. 7). </p>
<p><img src="8.jpeg"/></p>
<p>Рисунок 7 – Необходимая кодировка </p>
<p>Если отличаются данные параметры, то пройдите на вкладку редактировать\установки и выберете необходимые параметры
	(рис. 8). </p>
<p><img src="9.jpeg"/></p>
<p>Рисунок 8 – Установки </p>
<p>Подцепим таблицу стилей (рис. 9): </p>
<p>Для этого выбираем файл\создать\CSS и сохраняем файл под именем style.css. В данном файле будут храниться все стили
	необходимые для оформления сайта. </p>
<p>Переходим в файл index.PHP, выбираем проект\стиль </p>
<p><img src="10.jpeg"/></p>
<p>Рисунок 9 – Присоединение таблицы стилей к сайту Выбираем нашу таблицу и нажимаем ок (рис. 10). </p>
<p><img src="11.jpeg"/></p>
<p>Рисунок 10 – Выбор таблицы стилей Создадим основной каркас сайта: </p>
<p>Для этого в проекте во вкладке общий выберем таблицу и дадим ей следующие параметры (рис. 11). </p>
<p><img src="12.jpeg"/></p>
<p>Рисунок 11 – Создание таблицы Должно получиться следующее (рис. 12): </p>
<p><img src="13.jpeg"/></p>
<p>Рисунок 12 – Вид таблицы </p>
<p>Поставим выравнивание по центру и цвет рамки белый. </p>
<p>Пропишем стиль для рамки. </p>
<p>Для этого в файле style.css пропишем: </p>
<p>.main_border {border: 1px solid #000000;} </p>
<p>Затем переходим к проекту, снизу видим тег &lt;table&gt;, нажимаем на него правой кнопкой и выбирает стиль
	.main_border. </p>
<p>Сохраним все изменения и откроем сайт в браузере (рис. 13). </p>
<p><img src="14.jpeg"/></p>
<p>Рисунок 13 – Таблица в браузере </p>
<p>Пропишем стиль для абзацев: </p>
<p>p {font-family:Verdana; font-size:12px; margin: 15px;} </p>
<p></p>
<p><strong>3 Приводим сайт к исходному виду </strong></p>
<p>В данном уроке создадим фон, шапку сайта. </p>
<p>Создайте шапку сайта размером 690 на 100 пикселей. Создайте в папке kssite папку img и поместите туда созданную шапку
	сайта. </p>
<p>Затем переходим в Adobe Dreamweaver. В файле index.php открываем проект сайта. Справа открываем папку img и мышкой
	перетаскиваем изображение в таблицу. В появившемся окне нажимаем вкладку ok (рис. 14).</p>
<p></p>
<p><img src="15.jpeg"/></p>
<p>Рисунок 14 – Окно специальных возможностей тега image </p>
<p>Должно получиться следующее (рис. 15): </p>
<p></p>
<p><img src="16.jpeg"/></p>
<p>Рисунок 15 – Готовая шапка сайта </p>
<p></p>
<p>В нижнюю ячейку добавим таблицу, чтобы разбить ее на две части, в левой части будут располагаться кнопки, в правой –
	сам текст (рис. 16). </p>
<p></p>
<p></p>
<p><img src="17.jpeg"/></p>
<p></p>
<p>Рисунок 16 – Добавление таблицы </p>
<p>Ширину левой ячейки зададим примерно 175px. Перейдем в код и пропишем это. Ширину правой ячейки можно удалить. </p>
<p>Получим: </p>
<p>&lt;td width=&quot;175px&quot;&gt;&amp;nbsp;&lt;/td&gt; </p>
<p>        &lt;td &gt;&amp;nbsp;&lt;/td&gt; </p>
<p>Левой ячейке придадим слегка голубоватый цвет. Для этого пропишем стиль: </p>
<p>.left {background-color: #EDF5FE; border-right:1px solid #99CCFF;} </p>
<p>Сохраняем стиль, переходим в проект файла index. Снизу правой кнопкой нажимаем на тег &lt;td&gt; и выбираем наш класс
	(рис. 17). </p>
<p><img src="18.jpeg"/></p>
<p></p>
<p>Рисунок 17 – Выбор класса для таблицы </p>
<p>Создадим фон сайта. Для этого пропишем стиль: </p>
<p>body {background-color: #FFFFFF; font-family: Verdana; font-size:12px; </p>
<p>} </p>
<p>Сохраняем и проверяем в браузере. Вот что должно получиться (рис.18): </p>
<p><img src="19.jpeg"/></p>
<p></p>
<p>Рисунок 18 – Фон сайта </p>
<p>Теперь можно вставить текст. Подготовьте текст для главной страницы. И скопируйте его в проект файла index.php в
	правую ячейку. Должно получиться следующее (рис. 19). </p>
<p><img src="20.jpeg"/></p>
<p>Рисунок 19 – Сайт с текстом в браузере </p>
<p>Создадим навигацию сайта. Для этого мы подготовили HTML и CSS код для навигации. </p>
<p>CSS код: </p>
<p>p.title { </p>
<p>background-color:#0265DD; </p>
<p>color: #ffffff; font-weight:bold; margin:5px; </p>
<p>padding:5px; </p>
<p>} </p>
<p>#search-result { </p>
<p>width: 50%; </p>
<p>} </p>
<p>#box111 { /*height: 50%;*/ width: 200%; /*position:absolute; top: 20%; </p>
<p>left: 45%;*/ </p>
<p>} </p>
<p></p>
<p>#coolmenu{ border: 1px solid gray; /*Стиль рамки */ border-bottom-width: 0; width: 93%; /*Ширина меню */ </p>
<p>background-color: #f6f6f6; /*Фоновый цвет ячейки*/ margin:5px; /*Ширина отступов*/ </p>
<p>} </p>
<p>* html #coolmenu{ </p>
<p>width: 150px;/*Ширина меню для Internet Explorer*/ </p>
<p>} </p>
<p>#coolmenu a{ font: bold 13px Verdana; /*Шрифт текста*/ padding: 2px; /*Внутренний отсутп текста ссылки от краев
	ячейки*/ padding-left: 4px;/*Внутренний отсутп текста ссылки от левого края ячейки*/ display: block; width: 100%;
	/*Ширина ячейки*/ color: #000000; /*Цвет текста*/ </p>
<p>text-decoration: none; /*Подчеркивание у ссылок - нет*/ border-bottom: 1px solid gray; </p>
<p>} </p>
<p>html&gt;body #coolmenu a{ </p>
<p>width: auto; </p>
<p>} </p>
<p>#coolmenu a:hover{ </p>
<p>background-color: #cccccc; /*Фоновый цвет ячейки при наведение курсора*/ color: #000000; /*Цвет текста при наведении
	курсора*/ </p>
<p></p>
<p>Скопируйте его в файл со стилями. HTML код: </p>
<p>&lt;p align=&quot;center&quot; class=&quot;title&quot;&gt; Навигация </p>
<p>       &lt;/p&gt;           </p>
<p> &lt;/div&gt; &lt;div p=&quot;coolmenu&quot;&gt; </p>
<p>&lt;center&gt; </p>
<p>&lt;/center&gt;  </p>
<p>&lt;center&gt;&lt;a href=&quot;index.php&quot;&gt;  </p>
<p>&lt;img src=&quot;img/11.gif&quot;align=&quot;center&quot;&gt;&lt;/a&gt;&lt;/center&gt; &lt;br&gt; </p>
<p>&lt;center&gt;&lt;a href=&quot;termin.php&quot;&gt;  </p>
<p>&lt;img src=&quot;img/22.gif&quot;align=&quot;center&quot;&gt;&lt;/a&gt;&lt;/center&gt; &lt;br&gt; </p>
<p>&lt;center&gt;&lt;a href=&quot;history.php&quot;&gt;  </p>
<p>&lt;img src=&quot;img/33.gif&quot;align=&quot;center&quot;&gt;&lt;/a&gt;&lt;/center&gt; &lt;br&gt; </p>
<p>&lt;center&gt;&lt;a href=&quot;perechen.php&quot;&gt;  </p>
<p>&lt;img src=&quot;img/34.gif&quot;align=&quot;center&quot;&gt;&lt;/a&gt;&lt;/center&gt; &lt;br&gt; </p>
<p>&lt;center&gt;&lt;a href=&quot;analiz.php&quot;&gt;  </p>
<p>&lt;img src=&quot;img/44.gif&quot;align=&quot;center&quot;&gt;&lt;/a&gt;&lt;/center&gt; &lt;br&gt; </p>
<p>&lt;center&gt;&lt;a href=&quot;type.php&quot;&gt;  </p>
<p>&lt;img src=&quot;img/55.gif&quot;align=&quot;center&quot;&gt;&lt;/a&gt;&lt;/center&gt; &lt;br&gt; </p>
<p>&lt;center&gt;&lt;a href=&quot;end.php&quot;&gt;  </p>
<p>&lt;img src=&quot;img/66.gif&quot;align=&quot;center&quot;&gt;&lt;/a&gt;&lt;/center&gt; &lt;br&gt; </p>
<p>&lt;center&gt;&lt;a href=&quot;literatura.php&quot;&gt;  </p>
<p>&lt;img src=&quot;img/88.gif&quot;align=&quot;center&quot;&gt;&lt;/a&gt;&lt;/center&gt; </p>
<p></p>
<p>Скопируйте его в левый блок, предварительно поставив вертикальное выравнивание по верхнему краю. Затем перейдите в
	код и вставьте данный фрагмент кода. Для навигации мы использовали нарисованные кнопки. Можете их заменить на текст.
	Сохраните и проверьте в браузере (рис. 20). </p>
<p><img src="21.jpeg"/></p>
<p>Рисунок 20 – Внешний вид сайта и его каркас </p>
<p>Внешний вид и каркас сайта готовы! </p>
<p></p>
<p><strong>4 Разбиваем сайт на PHP блоки </strong></p>
<p>Разобьем сайт на блоки. Один блок будет содержать шапку сайта, а второй – левый блок, те навигацию. Это будет очень
	удобно, тк если что-то необходимо будет изменить на сайте, нужно будет изменить лишь один файл. </p>
<p>В папке kssite создадим папку blocks. </p>
<p>Найдем в файле index.php код, отвечающий за шапку сайта и вырежем данный фрагмент: </p>
<p>&lt;tr&gt; </p>
<p>    &lt;td&gt;&lt;img src=&quot;img/header.jpg&quot; width=&quot;686&quot; height=&quot;130&quot;
	/&gt;&lt;/td&gt; </p>
<p>  &lt;/tr&gt; </p>
<p>На его месте впишем следующую строчку: </p>
<p>&lt;? include (&quot;blocks/header.php&quot;); ?&gt; </p>
<p>Данной строчкой мы подключили файл header.php находящийся в папке blocks. Теперь создадим в папке blocks файл
	header.php и скопируем в него ранее вырезанный код шапки нашего сайта. Сохраняем файлы и проверяем сайт в браузере.
	Все отлично работает! </p>
<p>То же самое проделаем с навигацией. </p>
<p>Вырежем из файла index.php код навигации: </p>
<p></p>
<p>   &lt;p align=&quot;center&quot; class=&quot;title&quot;&gt; Навигация </p>
<p>       &lt;/p&gt;           </p>
<p> &lt;/div&gt;  </p>
<p> &lt;div p=&quot;coolmenu&quot;&gt; </p>
<p>&lt;center&gt; </p>
<p>&lt;/center&gt;  </p>
<p>&lt;center&gt;&lt;a href=&quot;index.php&quot;&gt;  </p>
<p>&lt;img src=&quot;img/11.gif&quot;align=&quot;center&quot;&gt;&lt;/a&gt;&lt;/center&gt; &lt;br&gt; </p>
<p>&lt;center&gt;&lt;a href=&quot;termin.php&quot;&gt;  </p>
<p>&lt;img src=&quot;img/22.gif&quot;align=&quot;center&quot;&gt;&lt;/a&gt;&lt;/center&gt; &lt;br&gt; </p>
<p>&lt;center&gt;&lt;a href=&quot;history.php&quot;&gt;  </p>
<p>&lt;img src=&quot;img/33.gif&quot;align=&quot;center&quot;&gt;&lt;/a&gt;&lt;/center&gt; &lt;br&gt; </p>
<p>&lt;center&gt;&lt;a href=&quot;perechen.php&quot;&gt;  </p>
<p>&lt;img src=&quot;img/34.gif&quot;align=&quot;center&quot;&gt;&lt;/a&gt;&lt;/center&gt; &lt;br&gt; </p>
<p>&lt;center&gt;&lt;a href=&quot;analiz.php&quot;&gt;  </p>
<p>&lt;img src=&quot;img/44.gif&quot;align=&quot;center&quot;&gt;&lt;/a&gt;&lt;/center&gt; &lt;br&gt; </p>
<p>&lt;center&gt;&lt;a href=&quot;type.php&quot;&gt;  </p>
<p>&lt;img src=&quot;img/55.gif&quot;align=&quot;center&quot;&gt;&lt;/a&gt;&lt;/center&gt; &lt;br&gt; </p>
<p>&lt;center&gt;&lt;a href=&quot;end.php&quot;&gt;  </p>
<p>&lt;img src=&quot;img/66.gif&quot;align=&quot;center&quot;&gt;&lt;/a&gt;&lt;/center&gt; &lt;br&gt; </p>
<p>&lt;center&gt;&lt;a href=&quot;literatura.php&quot;&gt;  </p>
<p>&lt;img src=&quot;img/88.gif&quot;align=&quot;center&quot;&gt;&lt;/a&gt;&lt;/center&gt; </p>
<p></p>
<p>Вставим на его место строку для подключения файла lefttd: </p>
<p>&lt;? include (&quot;blocks/lefttd.php&quot;); ?&gt; </p>
<p>Создадим в папке blocks файл lefttd.php и вставим в него вырезанный код. Не забудьте сохранить и проверить
	получившееся в браузере! </p>
<p></p>
<p><strong>5 Добавляем базовые страницы </strong></p>
<p>В данном уроке заполним информацией остальные страницы. </p>
<p>Для начала перейдите в проект файла index.php, нажмите на тег &lt;td&gt; и выберете выравнивание по верхнему
	краю. </p>
<p>Теперь можно скопировать файл index.php и создать страницу для основной терминологии. Сохраним копию файла index.php
	как termin.php. Скопируем в проект файла termin.php уже подготовленную информацию. В названии пропишем «Основная
	терминология» (рис. 21). </p>
<p></p>
<p></p>
<p>Рисунок 21 – Проект файла termin.php Сохраняем и проверяем в браузере (рис. 22): </p>
<p>Рисунок 22 – Страница «Основная терминология» Аналогично создаем остальные страницы. </p>
<p></p>
<p><strong>6 Создаем БД и заполняем таблицы </strong></p>
<p>Для создания БД заходим на localhost и проходим по ссылке <a href="http://localhost/Tools/phpMyAdmin">http://localhost/Tools/phpMyAdmin.</a>
	Создаем базу kssite (рис. 23). </p>
<p>Рисунок 23 – Создание базы данных </p>
<p></p>
<p>Добавим таблицу с настройками, которая будет содержать тексты. </p>
<p>Создаем таблицу main, в ней нам понадобится 4 поля (рис. 24). </p>
<p>Рисунок 24 – Добавление таблицы в БД </p>
<p>Задаем следующие параметры и нажимаем сохранить (рис. 25). </p>
<p>Рисунок 25 – Параметры таблицы settings </p>
<p>Видим что у нас появилась таблица main в нашей базе. Будем ее заполнять, для этого нажимаем кнопку вставить (рис.
	26). </p>
<p></p>
<p></p>
<p>Рисунок 26 – Форма для заполнения полей в таблице settings </p>
<p>Вводим название страницы index, копируем заголовок данной страницы и вырезаем из файла index.php текст страницы с
	тегами. Тоже самое делаем для файла termin.php. Затем выбираем вставить новую запись и нажимаем пошел </p>
<p>(рис. 27). </p>
<p></p>
<p><img src="22.jpeg"/></p>
<p></p>
<p>Рисунок 27 – Заполнение полей в таблице settings </p>
<p>Данные с остальных страниц занесите в базу самостоятельно! После создания последней записи вместо вставить новую
	запись выберете возврат. </p>
<p>Выберем нашу таблицу и нажмем обзор (рис. 28). Все записи добавились в таблицу! </p>
<p>Рисунок 28 – Обзор таблицы settings </p>
<p></p>
<p><strong>7 Извлекаем данные из БД </strong></p>
<p>В данном уроке будем вытаскивать информацию на свои места. </p>
<p>Переходим в dreamweaver, в файл index. Соединимся с нашей базой. </p>
<p>Для начала мы должны соединиться с mysql сервером: </p>
<p>&lt;? mysql_connect (&quot;localhost&quot;,&quot;root&quot;,&quot;&quot;); ?&gt; </p>
<p>И занесем это в переменную db </p>
<p>&lt;? </p>
<p>$db = mysql_connect (&quot;localhost&quot;,&quot;root&quot;,&quot;&quot;); ?&gt; </p>
<p>Далее пропишем функцию выбора БД. </p>
<p>&lt;?php </p>
<p>$db = mysql_connect (&quot;localhost&quot;,&quot;root&quot;,&quot;&quot;); mysql_select_db(&quot;kssite&quot;,$db); ?&gt; </p>
<p>Вынесем эту информацию в отдельный файл, чтобы впоследствии при подключении к базе обращаться к функции include. </p>
<p>Создадим новый файл bd.php и сохраним его в папку blocks (рис. 29). </p>
<p><img src="23.jpeg"/></p>
<p></p>
<p>Рисунок 29 – файл bd.php </p>
<p>Чтобы подключить базу к файлу index.php пропишем в нем: </p>
<p>&lt;?php </p>
<p>include (&quot;blocks/bd.php&quot;); ?&gt; </p>
<p>Сформируем запрос к БД и поместим его в переменную result и далее из этой переменной вытащим массив с данными в
	переменную myrow (рис. 30). </p>
<p><img src="24.jpeg"/></p>
<p>Рисунок 30 – Формирование запроса к БД </p>
<p>Для вывода текста и заголовка на их месте пропишем следующее: </p>
<p>&lt;?php echo $myrow ['title']; ?&gt; на месте заголовка; &lt;?php echo $myrow ['text']; ?&gt; на месте текста. </p>
<p>Сохраняем изменения и проверяем в браузере. Должен отобразиться текст. В остальных файлах пропишите функцию include и
	через оператор echo введите текст и заголовок статьи, аналогично файлу index.php. </p>
<p></p>
<p><strong>8 Создание блока админа </strong></p>
<p>В данном уроке создадим блок администратора, из которого можно будет редактировать уроки. Данная часть невидима. </p>
<p>Создадим внутри нашего сайта папку admin. Администраторский блок по внешнему виду обычно похож на сайт, поэтому в нее
	можно скопировать файл index.php, стили, папки blocks и img. Далее переходим в Adobe Dreamweaver и займемся
	редактированием блока администратора. Из базы мы ничего не будем извлекать, поэтому соединение с БД и извлечение из
	нее информации удаляем. </p>
<p>Между тегами &lt;title&gt; пропишем: «Главная страница блока администратора». Вместо текста пропишем: «&lt;p&gt;Добро
	пожаловать в админский блок!&lt;/p&gt;». Сохраняем изменения, переходим в браузере и в адрес прописываем: <a
			href="http://localhost/kssite/admin/">http://localhost/kssite/admin/ </a>(рис. 31). </p>
<p>Должно получиться следующее: </p>
<p><img src="25.jpeg"/></p>
<p>Рисунок 31 – Админская страница </p>
<p>Теперь займемся файлом lefttd.php, уберем в нем кнопки и добавим кнопку редактирования. Скопируем в папку img файл
	10.gif – кнопка редактирования (рис. 32). </p>
<p>Оставим следующий код: </p>
<p><img src="26.jpeg"/></p>
<p>Рисунок 32 – Создание кнопки редактирования </p>
<p>Проверьте в браузере (рис. 33): </p>
<p></p>
<p><img src="27.jpeg"/></p>
<p></p>
<p>Рисунок 33 – Кнопка редактирования текстов в админской странице </p>
<p></p>
<p>В следующем уроке непосредственно займемся редактированием текстов. </p>
<p><strong>9 Редактирование текстов из админки </strong></p>
<p>В папке admin создадим php файл под названием edit_text.php (рис. 34). </p>
<p>Создадим цикл из которого выводятся названия всех страниц: </p>
<p>Рисунок 34 – Код файла edit.php </p>
<p>В файле lefttd.php исправим ссылку на edit_text. Сохраним изменения и проверим их в браузере (рис. 35). </p>
<p>Рисунок 35 – Вывод текстов для редактирования </p>
<p>Займемся файлом red_text, который будет уже заниматься редактированием. Файл red_text выглядит следующим образом
	(рис. 36): </p>
<p>Рисунок 36 – Код файла red_text.php </p>
<p>В итоге у вас должна выводиться в браузере форма для редактирования текстов при нажатии на название статьи (рис.
	37): </p>
<p>Рисунок 37 – Форма для редактирования текста в браузере </p>
<p><strong>10 Доступ к админке по паролю </strong></p>
<p>Создаем в папке admin файл lock.php и копируем в него следующий код: </p>
<p>&lt;?php </p>
<p>include(&quot;blocs/bd.php&quot;); </p>
<p>if (!isset($_SERVER['PHP_AUTH_USER'])) </p>
<p>{ </p>
<p> Header (&quot;WWW-Authenticate: Basic realm=\&quot;Admin Page\&quot;&quot;); </p>
<p> Header (&quot;HTTP/1.0 401 Unauthorized&quot;); exit(); </p>
<p>} </p>
<p>else { if (!get_magic_quotes_gpc()) { </p>
<p>$_SERVER['PHP_AUTH_USER']= mysql_escape_string($_SERVER['PHP_AUTH_USER']); </p>
<p> $_SERVER['PHP_AUTH_PW']= mysql_escape_string($_SERVER['PHP_AUTH_PW']); </p>
<p> } </p>
<p> $query = &quot;SELECT pass FROM userlist WHERE </p>
<p>user='&quot;.$_SERVER['PHP_AUTH_USER'].&quot;'&quot;; </p>
<p>$lst = @mysql_query($query); </p>
<p> if (!$lst) { </p>
<p> Header (&quot;WWW-Authenticate: Basic realm=\&quot;Admin Page\&quot;&quot;); </p>
<p> Header (&quot;HTTP/1.0 401 Unauthorized&quot;); exit(); </p>
<p> } </p>
<p> if (mysql_num_rows($lst) == 0) </p>
<p> { </p>
<p> Header (&quot;WWW-Authenticate: Basic realm=\&quot;Admin Page\&quot;&quot;); </p>
<p> Header (&quot;HTTP/1.0 401 Unauthorized&quot;); exit(); </p>
<p> } </p>
<p> $pass = @mysql_fetch_array($lst); </p>
<p> if ($_SERVER['PHP_AUTH_PW']!= $pass['pass']) </p>
<p> { </p>
<p> Header (&quot;WWW-Authenticate: Basic realm=\&quot;Admin Page\&quot;&quot;); </p>
<p> Header (&quot;HTTP/1.0 401 Unauthorized&quot;); exit(); </p>
<p> } </p>
<p>} </p>
<p>?&gt;  </p>
<p>Теперь необходимо подключить данный файл ко всем файлам админского блока. Для этого в начале каждого файла, который
	находится в папке admin прописываем следующую строчку: </p>
<p>&lt;? </p>
<p>include (&quot;lock.php&quot;); </p>
<p>?&gt; </p>
<p>Теперь нам необходимо создать табличку, в которой будет три пола id, user и pass. Перейдем в phpmyadmin, выберем нашу
	базу и создадим таблицу userlist. Задаем ей следующие параметры (рис. 38): </p>
<p></p>
<p><img src="28.jpeg"/></p>
<p></p>
<p>Рисунок 38 – Параметры таблицы userlist Вставим в таблицу запись, например (рис. 39): </p>
<p></p>
<p>Рисунок 39 – Заполнение таблицы userlist </p>
<p></p>
<p>Выбираем возврат и нажимаем “пошел”. </p>
<p>Сохраняем все изменения и пытаемся в браузере зайти на админскую страницу (рис. 40). </p>
<p><img src="29.jpeg"/></p>
<p>Рисунок 40 – Окно запроса пароля в админской странице </p>
<h1><a id="_Toc454872993"></a>Лабораторная работа №20: “Программирование и оптимизация программ”</h1>
<p><strong>Цель. </strong>Отработка навыков веб-мастеринга. </p>
<p><strong>Ожидаемый результат. </strong>Создание ТЗ на разработку сайта и его реализация. </p>
<p><strong>Цель работы </strong>– составить ТЗ на разработку корпоративного сайта. </p>
<p><strong> </strong></p>
<p><strong>Ход работы </strong></p>
<p><strong> </strong></p>
<p><strong>3.1.2. Общие сведения</strong></p>
<p><a id="_Toc315698524"></a><strong>Назначение документа</strong></p>
<p>Настоящее Техническое задание определяет требования и порядок разработки веб-сайта «upload».</p>
<p><a id="_Toc315698525"></a><strong>Наименование Исполнителя и Заказчика</strong></p>
<p>Заказчик: __________».</p>
<p>Исполнитель: _________.</p>
<p><a id="_Toc315698526"></a><strong>Краткие сведения о компании</strong></p>
<p>Компания _______________ занимается продажей компьютерной техники. До настоящего времени веб-сайта у компании не
	было.</p>
<p><a id="_Toc315698527"></a><strong>Основание для разработки сайта</strong></p>
<p>Основанием для разработки сайта является Договор №__ между Исполнителем и Заказчиком.</p>
<p><a id="_Toc315698528"></a><strong>Плановые сроки начала и окончания работ по созданию сайта</strong></p>
<p>Начало работ: 21.04.2016</p>
<p>Окончание работ: 21.05.2016</p>
<p>Содержание и длительность отдельных этапов работ приведены в разделе 4 настоящего ТЗ. Сроки, состав и очерёдность
	работ являются ориентировочными и могут изменяться по согласованию с Заказчиком.</p>
<p><a id="_Toc315698529"></a><strong>Порядок оформления и предъявления результатов работ</strong></p>
<p>Работы по созданию сайта производятся и принимаются поэтапно.</p>
<p>По окончании каждого из этапов работ, перечисленных в разделе 4 настоящего ТЗ, Исполнитель представляет Заказчику
	соответствующие результаты, и стороны подписывают Акт сдачи-приёмки работ.</p>
<p><a id="_Toc315698530"></a><strong>3.1.3. Назначение и цели создания сайта</strong></p>
<p><a id="_Toc315698531"></a><strong>Назначение сайта</strong></p>
<p>Сайт должен представлять ООО «Маяк» в Интернете, поддерживать её положительный и современный имидж, знакомить
	посетителей с продукцией компании.</p>
<p><a id="_Toc315698532"></a><strong>Цели создания сайта</strong></p>
<p>Цель сайта – познакомить посетителей с компанией, направлениями её деятельности и продукцией, предоставить информацию
	о способах приобретения продукции.</p>
<p><a id="_Toc315698534"></a><strong>Целевая аудитория</strong></p>
<p>В целевой аудитории веб-сайта можно выделить следующие группы:</p>
<ol>
	<li>Покупатели;</li>
	<li>Партнёры;</li>
	<li>Посетители тренингов.</li>
</ol>
<p><a id="_Toc315698535"></a><strong>3.1.4. Требования к сайту</strong></p>
<p><a id="_Toc315698537"></a><strong>Требования к структуре и функционированию сайта</strong></p>
<p>Сайт должен представлять собой информационную структуру, доступную в сети Интернет под доменным именем «upload».</p>
<p>Сайт должен состоять из взаимосвязанных разделов с чётко разделёнными функциями.</p>
<p><a id="_Toc315698538"></a><strong>Требования к персоналу</strong></p>
<p>Для поддержания сайта и эксплуатации веб-интерфейса системы управления сайтом (CMS) от персонала не должно
	требоваться специальных технических навыков, знания технологий или программных продуктов, за исключением общих
	навыков работы с персональным компьютером и стандартным веб-браузером (MS Internet Explorer 7.0 или выше).</p>
<p><a id="_Toc315698539"></a><strong>Требования к сохранности информации</strong></p>
<p>В системе управления сайтом должен быть предусмотрен механизм резервного копирования структуры и содержимого базы
	данных. Процедура резервного копирования должна производиться сотрудником, ответственным за поддержание сайта, не
	реже 1 раза в неделю. Резервное копирование графического содержимого должно осуществляться вручную.</p>
<p><a id="_Toc315698540"></a><strong>Требования к разграничению доступа</strong></p>
<p>Информация, размещаемая на сайте, является общедоступной.</p>
<p>Пользователей сайта можно разделить на 3 части в соответствии с правами доступа:</p>
<p>Посетители имеют доступ только к общедоступной части сайта.</p>
<p>Доступ к административной части имеют пользователи с правами редактора и администратора.</p>
<p>Редактор может редактировать материалы разделов.</p>
<p>Администратор может выполнять все те же действия, что и Редактор, и кроме того:</p>
<p>- добавлять пользователей с правами Редактора;</p>
<p>- добавлять и удалять разделы сайта.</p>
<p>Доступ к административной части должен осуществляться с использованием уникального логина и пароля. Логин выдаётся
	администратором сайта. Пароль генерируется автоматически и высылается пользователю на адрес, указанный при
	регистрации. В первый раз при попытке войти в административную часть система должна предлагать пользователю сменить
	пароль (ввести вручную новый пароль).</p>
<p>Для обеспечения защиты от несанкционированного доступа к административной части при составлении паролей рекомендуется
	придерживаться следующих правил:</p>
<ol>
	<li>Длина пароля должна быть не менее 8 символов.</li>
</ol>
<p>Пароль должен состоять из цифр и латинских букв в разных регистрах; желательно включать в пароль другие символы,
	имеющиеся на клавиатуре (например, символы / ? ! &lt; &gt; [ ] { } и т.д.)</p>
<p>Пароль не должен являться словарным словом или набором символов, находящихся рядом на клавиатуре. В идеале пароль
	должен состоять из бессмысленного набора символов.</p>
<p>Все пароли необходимо менять с определённой периодичностью, оптимальный срок - от трёх месяцев до года.</p>
<p><a id="_Toc315698541"></a><strong>Требования к функциям (задачам), выполняемым сайтом</strong></p>
<p>Сайт должен состоять из следующих разделов:</p>
<p>- Главная страница</p>
<p>- Корзина покупок</p>
<p>- Товары</p>
<p><a id="_Toc315698544"></a><strong>Навигация</strong></p>
<p>Пользовательский интерфейс сайта должен обеспечивать наглядное, интуитивно понятное представление структуры
	размещённой на нем информации, быстрый и логичный переход к разделам и страницам. Навигационные элементы должны
	обеспечивать однозначное понимание пользователем их смысла: ссылки на страницы должны быть снабжены заголовками,
	условные обозначения соответствовать общепринятым. Графические элементы навигации должны быть снабжены
	альтернативной подписью.</p>
<p>Система должна обеспечивать навигацию по всем доступным пользователю ресурсам и отображать соответствующую
	информацию. Для навигации должна использоваться система контент-меню. Меню должно представлять собой текстовый блок
	(список гиперссылок) в левой колонке или в верхней части страницы (в зависимости от утверждённого дизайна).</p>
<p>Для разделов, содержащих подразделы, должно быть предусмотрено выпадающее подменю.</p>
<p>При выборе какого-либо из пунктов меню пользователем должна загружаться соответствующая ему информационная страница
	(новостная лента, форма обратной связи и пр.), а в блоке меню (или в основной части страницы в зависимости от
	утверждённого дизайна) открываться список подразделов выбранного раздела. </p>
<p><a id="_Toc315698545"></a><strong>Наполнение сайта (контент)</strong></p>
<p>Страницы всех разделов сайта должны формироваться программным путём на основании информации из базы данных на
	сервере.</p>
<p>Модификация содержимого разделов должна осуществляться посредством администраторского веб-интерфейса (системы
	управления сайтом), который без применения специальных навыков программирования (без использования программирования
	и специального кодирования или форматирования) должен предусматривать возможность редактирования информационного
	содержимого страниц сайта. Наполнение информацией должно проводиться с использованием шаблонов страниц сайта. </p>
<p>В рамках разработки сайта Исполнитель должен обеспечить ввод представленной Заказчиком статической информации в
	создаваемые динамические разделы (с учётом предусмотренной настоящим ТЗ функциональности). Текстовая информация
	должна предоставляться Заказчиком в виде отдельных файлов формата MS Word 2003 (DOC). Названия файлов должны
	соответствовать названиям разделов. Перед передачей текстов Исполнителю они должны быть вычитаны и отредактированы.
	Графический материал должен предоставляться в формате JPG. По возможности, названия графических файлов должны
	отражать содержимое файла. Изображения для галерей и разделов сайта должны размещаться в папках или архивах с
	названиями соответственно галерее или разделу сайта, для которых они предназначаются.</p>
<p>Исполнитель должен обеспечить обработку иллюстраций для приведения их в соответствие с техническими требованиями и
	HTML-вёрстку подготовленных материалов. При необходимости дополнительной обработки (набор, вычитка, сканирование,
	ретушь, монтаж, перевод и т.п.) силами Исполнителя она должна осуществляться в рамках отдельного соглашения с
	Заказчиком.</p>
<p>После сдачи сайта в эксплуатацию информационное наполнение разделов, включая обработку и подготовку к публикации
	графических материалов, должно осуществляться Заказчиком самостоятельно или на основании отдельного договора на
	поддержку сайта.</p>
<p><strong>3.1.5. Система навигации (карта сайта)</strong></p>
<p>Взаимосвязь между разделами и подразделами сайта (карта сайта) представлена на рисунке Ошибка: источник перекрёстной
	ссылки не найден.</p>
<p><img src="30.png"/></p>
<p>Рисунок <a id="_Ref240344621"></a>– Карта сайта.</p>
<p><a id="_Toc315698547"></a><strong>Требования к функциональным возможностям</strong></p>
<p><a id="_Toc315698548"></a><strong>Система управления контентом (CMS)</strong></p>
<p>Система управления контентом (административная часть сайта) должна предоставлять возможность добавления,
	редактирования и удаления содержимого статических и динамических страниц. Также должна быть предусмотрена
	возможность добавления информации без отображения на сайте. </p>
<p>Система управления контентом должна иметь стандартный для Windows интерфейс, отвечающий следующим требованиям:</p>
<p>- реализация в графическом оконном режиме;</p>
<p>- единый стиль оформления;</p>
<p>- интуитивно понятное назначение элементов интерфейса;</p>
<p>- отображение на экране только тех возможностей, которые доступны конкретному пользователю;</p>
<p>- отображение на экране только необходимой для решения текущей прикладной задачи информации;</p>
<p>- отображение на экране хода длительных процессов обработки;</p>
<p>- диалог с пользователем должен быть оптимизирован для выполнения типовых и часто используемых операций.</p>
<p>- для операций по массовому вводу информации должна быть предусмотрена минимизация количества нажатий на клавиатуру
	для выполнения стандартных действий.</p>
<p><a id="_Toc315698549"></a><strong>Типовые статические страницы</strong></p>
<p>Типовые страницы могут изменяться, редактироваться или дополняться в административной части сайта.</p>
<p>Для каждой типовой статической страницы в административной части заполняются такие поля:</p>
<p>- Заголовок (длина не более 125 символов).</p>
<p>- Полный текст страницы (количество сопроводительных иллюстраций в нём не ограничено, количество символов в одной
	статье – не более 15000; тексту может быть придано подчёркнутое, <em>наклонное</em> и <strong>жирное</strong>
	начертание).</p>
<p><a id="_Toc315698551"></a><strong>3.1.6. Требования к дизайну</strong></p>
<p><a id="_Toc315698552"></a><strong>Общие требования</strong></p>
<p>Стиль сайта можно описать как современный, деловой. В качестве фонового цвета рекомендуется использовать белый.
	Оформление не должно ущемлять информативность: хотя на сайте и должно быть довольно много графики, он должен быть
	удобен пользователям в плане навигации и интересен для многократного посещения.</p>
<p><a id="_Toc315698553"></a><strong>Типовые навигационные и информационные элементы</strong></p>
<p>- Шапка сайта</p>
<p>- Основное меню</p>
<p>- Боковое меню</p>
<p>- Основное поле контента</p>
<p>- Подложка</p>
<p><a id="_Toc315698554"></a><strong>Шапка сайта</strong></p>
<p>Шапка сайта должна содержать логотип и название компании, изображение (коллаж), а также контактную информацию.
	Логотип является ссылкой на главную страницу сайта. </p>
<p><a id="_Toc315698555"></a><strong>Основное и боковое меню</strong></p>
<p>Основное меню должно располагаться в верхней части окна (под шапкой) и содержать ссылки на все разделы первого
	уровня.</p>
<p>Боковое меню должно располагаться в левой части окна и содержать ссылки на разделы, связанные тематически с текущим,
	если таковые существуют для выбранного раздела первого уровня.</p>
<p><a id="_Toc315698556"></a><strong>Основное поле контента</strong></p>
<p>Основное поле контента должно располагаться в центре страницы. В этом поле отображается основное содержание
	выбранного раздела. Стилевое оформление материалов и их элементов (ссылок, заголовков, основного текста,
	изображений, форм, таблиц и т.п.) должно быть единым для всех страниц веб-сайта.</p>
<p><a id="_Toc315698558"></a><a id="_Toc300315200"></a><a id="_Toc268867539"></a><a id="_Toc241654321"></a><strong>3.1.7.
	Эскизы страниц</strong></p>
<p><strong>Страница с товарами</strong></p>
<p>В верхней части типовой страницы должна располагаться шапка и навигационное меню сайта; левая часть страницы содержит
	боковое меню; в правой боковой области расположен текстовой контент, содержащий текст или иллюстрации</p>
<p>Рисунок – Страница товаров.</p>
<p><strong>Типовая статическая страница</strong></p>
<p>В верхней части типовой страницы должна располагаться шапка и навигационное меню сайта; центральная часть содержит
	рекламу (баннер); нижняя часть содержит два полезных модуля, а в самом низу положка</p>
<p>Рисунок – Типовая страница.</p>
<p><a id="_Toc315698560"></a><a id="_Toc300315205"></a><strong>3.1.8. Требования к видам обеспечения</strong></p>
<p><a id="_Toc315698562"></a><a id="_Toc300315207"></a><a id="_Toc241654324"></a><strong>Требования к хранению
	данных</strong></p>
<p>Все данные сайта должны храниться в структурированном виде под управлением реляционной СУБД. Исключения составляют
	файлы данных, предназначенные для просмотра и скачивания (изображения, видео, документы и т.п.). Такие файлы
	сохраняются в файловой системе, а в БД размещаются ссылки на них.</p>
<p><a id="_Toc315698563"></a><a id="_Toc300315208"></a><a id="_Toc241654325"></a><strong>Требования к языкам
	программирования</strong></p>
<p>Для реализации статических страниц и шаблонов должны использоваться язык CSS. Исходный код должен разрабатываться в
	соответствии со стандартами W3C . Для реализации интерактивных элементов клиентской части должны использоваться
	языки JavaScript и PHP. Для реализации динамических страниц должен использоваться язык PHP.</p>
<p><a id="_Toc315698564"></a><a id="_Toc300315209"></a><a id="_Toc241654327"></a><strong>Требования к лингвистическому
	обеспечению</strong></p>
<p>Сайт должен быть выполнен на русском и английском языках. Должна быть предусмотрена возможность переключения между
	русским и английским языками на любой из страниц сайта.</p>
<p><a id="_Toc315698565"></a><a id="_Toc300315210"></a><a id="_Toc241654328"></a><a id="_Ref240091525"></a><a
		id="_Ref240091521"></a><strong>Требования к программному обеспечению</strong></p>
<p>Программное обеспечение клиентской части должно удовлетворять следующим требованиям:</p>
<ul>
	<li>
		<ul>
			<li>Веб-браузер: Internet Explorer 7.0 и выше, или Firefox 3.5 и выше, или Opera 9.5 и выше, или Safari
				3.2.1 и выше, или Chrome 2 и выше;
			</li>
			<li>Включённая поддержка javascript, Flash и cookies.</li>
		</ul>
	</li>
</ul>
<p><a id="_Toc315698566"></a><a id="_Toc300315211"></a><a id="_Toc241654329"></a><a id="_Ref240091527"></a><a
		id="_Toc315698566"></a><a id="_Toc300315211"></a><a id="_Toc241654329"></a><a id="_Ref240091527"></a></p>
<p><a id="_Toc315698566"></a><a id="_Toc300315211"></a><a id="_Toc241654329"></a><a id="_Ref240091527"></a><strong>Требования
	к аппаратному обеспечению</strong></p>
<p>Аппаратное обеспечение серверной части должно удовлетворять следующим требованиям:</p>
<ol>
	<li>ОС: Windows XP / Vista / 7 или выше;</li>
	<li>Память: 256 Mb или выше;</li>
	<li>Места на диске:500 Mb;</li>
	<li><a id="_Toc315698567"></a><a id="_Ref238829324"></a>Наличие интернет-соединения;</li>
</ol>
<p><strong>Состав и содержание работ по созданию сайта</strong></p>
<p>Подробное описание этапов работы по созданию сайта приведено в таблице.</p>
<p>Таблица. Этапы создания сайта.</p>
<table>
	<tr>
		<td><p>№ п/п</p></td>
		<td><p>Виды работ</p></td>
		<td><p>Трудоёмкость, дней</p></td>
	</tr>
	<tr>
		<td></td>
		<td><p>Получение ТЗ</p></td>
		<td><p>2</p></td>
	</tr>
	<tr>
		<td></td>
		<td><p>Сбор информации и ознакомление с предметной областью</p></td>
		<td><p>5</p></td>
	</tr>
	<tr>
		<td></td>
		<td><p>Выбор объектного построения программы</p></td>
		<td><p>2</p></td>
	</tr>
	<tr>
		<td></td>
		<td><p>Разработка общей методики создания продукта</p></td>
		<td><p>2</p></td>
	</tr>
	<tr>
		<td></td>
		<td><p>Разработка основного алгоритма</p></td>
		<td><p>12</p></td>
	</tr>
	<tr>
		<td></td>
		<td><p>Создание интерфейса</p></td>
		<td><p>5</p></td>
	</tr>
	<tr>
		<td></td>
		<td><p>Отладка</p></td>
		<td><p>4</p></td>
	</tr>
	<tr>
		<td></td>
		<td><p>Подготовка технической документации</p></td>
		<td><p>7</p></td>
	</tr>
	<tr>
		<td></td>
		<td><p>Сдача продукта</p></td>
		<td><p>2</p></td>
	</tr>
	<tr>
		<td></td>
		<td><p>ИТОГО:</p></td>
		<td><p>41</p></td>
	</tr>
</table>
<h1><a id="_Toc454872994"></a>Литература</h1>
<ol>
	<li>Рудаков А.В. Технология разработки программных продуктов. – М.: “Издательский центр “Академия”, 2013;</li>
	<li>Рудаков А. В. Технология разработки программных продуктов. Практикум. – М.: “Издательский центр “Академия”,
		2014;
	</li>
	<li>Котляров В. П. Основы тестирования программного обеспечения. – М.: “Интернет-Университет Информационных
		Технологий; БИНОМ. Лаборатория знаний”, 2012;
	</li>
	<li>Э. Орама, Г. Уилсона. Идеальная разработка ПО. Рецепты лучших программистов. – СПб.: “Питер”, 2012;</li>
	<li>Партыка Т. Л., Попов И.И. Информационная безопасность. – М.: “Форум”, “ИНФРА- М”, 2010;</li>
	<li>Н. В. Макарова, В. Б. Волков. Информатика. – СПб.: “Питер”, 2011;</li>
	<li>Вендров А.М. Проектирование программного обеспечения экономических информационных систем: Учебник. - 2-е изд.,
		перераб. и доп. – М.: Финансы и статистика, 2012;
	</li>
	<li>C/C++. Структурное Программирование: Практикум / Т. А. Павловская. Ю. А. Щупак. – СПб.: “Питер”, 2013;</li>
	<li>Лафоре. Р. Объектно-ориентированное программирование в C++. – СПб.: “Питер”, 2013;</li>
</ol>
{% endraw %}